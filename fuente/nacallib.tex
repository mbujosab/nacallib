% Created 2024-04-06 sáb 18:39
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[top=1in, bottom=1.in, left=1in, right=1in]{geometry}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[theorems, skins]{tcolorbox}
\usepackage[version=3]{mhchem}
\usepackage[numbers,super,sort&compress]{natbib}
\usepackage{natmove}
\usepackage{url}
\usepackage[cache=false]{minted}
\usepackage[strings]{underscore}
\usepackage[linktocpage,pdfstartview=FitH,colorlinks,
linkcolor=blue,anchorcolor=blue,
citecolor=blue,filecolor=blue,menucolor=blue,urlcolor=blue]{hyperref}
\usepackage{attachfile}
\usepackage{setspace}
\usepackage{nacal}
\usepackage[spanish, ]{babel}
\usepackage{pdfpages}
\usepackage{parskip}
\author{Marcos Bujosa}
\date{\today}
\title{Notación Asociativa para un Curso de Álgebra Lineal (NAcAL)\\\medskip
\large \url{https://github.com/mbujosab/nacallib} (Versión:  0.2.0)}
\begin{document}

\tableofcontents

\maketitle


\section*{Introducción}
\label{sec:org0768976}
\subsection*{Declaración de intenciones}
\label{sec:org3bc0224}
Uno de los objetivos que me he propuesto para el curso Matemáticas II (Álgebra Lineal) es mostrar
que escribir matemáticas y usar un lenguaje de programación son prácticamente la misma cosa. Este
modo de proceder debería ser un ejercicio muy didáctico ya que:
\begin{quote}
Un PC es muy torpe y se limita a ejecutar literalmente lo que se le indica (un PC no interpreta
interpolando para intentar dar sentido a lo que se le dice\ldots{} eso lo hacemos las personas, pero no
los ordenadores).

Consecuentemente este ejercicio impone una disciplina a la que en general el alumno no está
acostumbrado: \emph{el ordenador hará lo que queremos solo si las expresiones tienen sentido e indican
correctamente lo que queremos.} Si el ordenador no hace lo que queremos, será porque que no hemos
escrito las ordenes de manera correcta (lo que supone que también hemos escrito incorrectamente las
expresiones matemáticas).
\end{quote}

Con esta idea en mente:

\begin{enumerate}
\item La notación del \href{https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf}{Curso de Álgebra Lineal} pretende ser operativa; es decir, su uso debe ser
directamente traducible a operaciones a realizar por un ordenador. Para lograr una mayor
simplificación, la notación explota de manera intensiva la asociatividad.

\item Muchas de las demostraciones del \href{https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf}{libro} son algorítmicas. En particular aquellas las relacionadas
con la eliminación. De esta manera las demostraciones describen literalmente la programación de
los correspondientes algoritmos.
\end{enumerate}

\subsection*{Un módulo específico para el curso de Álgebra Lineal}
\label{sec:orgec90df3}
Aunque Python dispone de módulos para operar con vectores y matrices, he decidido escribir mi propio
módulo. De este modo logro que la notación del \href{https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf}{libro} y las expresiones empleadas con este módulo
para Python se parezcan lo más posible. Este documento describe tanto el uso del módulo \href{https://pypi.org/project/nacal/}{NAcAL} como
su código.
\begin{center}
 \textsc{Tenga en cuenta que esto no es un
 \href{https://docs.python.org/es/3/tutorial/index.html}{tutorial} de
 Python}. 
\end{center}
Mi labor es enseñar Álgebra Lineal (no Python). Afortunadamente usted dispone de muchos cursos y
material en la web para aprender Python. No obstante, he escrito unos Notebooks de Jupyter que
ofrecen unas breves nociones de programación en Python (aunque muy incompletas).
\begin{center}
  Antes de seguir, repase el Notebook
  \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F01_ListasYTuplas.ipynb}{\textbf{``Listas y tuplas''}}
    en la carpeta
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F}{``TutorialPython''}
    en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython}
\end{center}
Y recuerde que 
\begin{center}
\begin{tabular}{c}
\textbf{¡hacer matemáticas y programar son prácticamente la misma cosa!}\\
\end{tabular}
\end{center}


\part{La clase \texttt{Sistema} y sus subclases \texttt{BlockV}, \texttt{Vector}, \texttt{BlockM} y \texttt{Matrix}}
\label{sec:orga987f6d}


El primer capítulo presenta una \emph{clase} para las \emph{listas ordenadas de objetos} denominada \texttt{Sistema}.

Los capítulos siguientes definen ciertas subclases (y subclases de subclases) de la clase \texttt{Sistema}:

\begin{itemize}
\item \texttt{BlockV} es una subclase que puede mostrarse verticalmente en su representación \LaTeX{}.

\item \texttt{Vector} es un \texttt{BlockV} formado exclusivamente por números (implementa los vectores de \(\R[n]\)).

\begin{itemize}
\item \texttt{V0} y \texttt{V1} son \texttt{Vectores} que de ceros y de unos respectivamente.
\end{itemize}

\item \texttt{BlockM} es una subclase de \texttt{Sistema} cuyos elementos son \texttt{BlockVs} con el mismo número de
elementos. Permite trabajar con arreglos rectangulares de objetos. Por ser arreglos rectangulares
podremos definir su transposición y con ello generar \texttt{BlockM} cuyas componentes están formadas por
los \texttt{BlockVs} que contienen las primeras componentes, luego las segundas, etc.

\item \texttt{Matrix} es un \texttt{BlockM} formado exclusivamente por \texttt{Vectores} (matrices de \(\R[n\times m]\)) .

\begin{itemize}
\item \texttt{M0} y \texttt{M1} son \texttt{Matrices} de ceros y de unos respectivamente. La subclase \texttt{I} permite definir
fácilmente matrices identidad.
\end{itemize}

\item Por último se definen ciertas subclases de \texttt{Sistemas} (en algunos casos son específicamente
\texttt{Matrices}) que resultan tras la aplicación de algún proceso específico de eliminación. Estos
\texttt{Sistemas} poseen algunos atributos adicionales tales como los \texttt{pasos} de eliminación que se han
dado hasta llegar a su obtención.
\end{itemize}


\chapter{La clase \texttt{Sistema}}
\label{sec:org39a2e79}

En el \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#chapter.1}{libro} del curso se dice que
\begin{center}
  Un \emph{sistema} es una lista ordenada de objetos.
\end{center}
Aunque Python posee de manera nativa las \texttt{list} (listas), \texttt{NAcAL} define una clase específica
denominada \texttt{Sistema}. De esta manera \texttt{NAcAL} puede implementar tanto los métodos específicos
descritos en el curso como la notación empleada en el \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#chapter.1}{libro}, donde los sistemas genéricos se
muestran entre \emph{corchetes} y con los elementos de la lista \emph{seguidos de} `` \texttt{;}''.\footnote{\texttt{NAcAL}
también replica la notación de otros sistemas particulares tales como los vectores de \(\R[n]\) y las
matrices.} No solo eso, cada uno de los elementos de un \texttt{Sistema} se muestra con su propia
representación \texttt{latex} (si la tiene). Por ejemplo, el \texttt{Sistema}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
Sistema([ Vector([1,2,3]), I(2), T({1,2}) ]) 
\end{minted}
contiene un vector de \R[3], la matriz identidad 2 por 2 y una transformación intercambio entre las
componentes 1 y 2 de un sistema. En un Notebook de Jupyter veremos dicho \texttt{Sistema} así
$$\begin{bmatrix}\begin{pmatrix}1\\ 2\\ 3\end{pmatrix};& \left[ \begin{array}{cc}1&0\\0&1\\ \end{array} \right];& \underset{\left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]}{\pmb{\tau}};\end{bmatrix}$$

\noindent
(es decir, con la misma notación descrita en el curso de Álgebra Lineal).

Aunque los \texttt{Sistemas} y las \texttt{listas} de Python se diferencian en su representación y en algunos de
sus métodos, otros métodos que comunes. De hecho, en algunos aspectos un \texttt{Sistema} se comporta
exactamente igual que una \texttt{list} (por ejemplo, un \texttt{Sistema} también es iterable). La mayoría de
métodos definidos en \texttt{NAcAL} son específicos de los \texttt{Sistemas}, y otros métodos se han modificado
para reservar los símbolos de algunos \href{https://docs.python.org/3/reference/datamodel.html\#specialnames}{\emph{métodos mágicos}} de Python para ciertas operaciones
algebraicas. Por ejemplo, las \texttt{listas} de Python se concatenan con ``+'', pero los \texttt{Sistemas} se
concatenan con el método \texttt{concatena()}. Así \texttt{NAcAL} reserva el símbolo ``+'' para sumar \texttt{Sistemas}
componente a componente como se hace en Álgebra Lineal. Con ello se logra que lo que veamos y
escribamos en un Notebook de Jupyter sea lo más parecido posible a lo que vemos y escribimos en un
\href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#chapter.1}{curso de Álgebra Lineal}.

\newpage

\section{Implementación de los sistemas (o listas ordenadas) en la clase \texttt{Sistema}}
\label{sec:org3365426}

\subsection{Texto de ayuda}
\label{sec:org7719eda}

El texto de ayuda de la clase \texttt{Sistema} es auto-explicativo y Python
lo muestra al teclear \texttt{help(Sistema)}:

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la clase Sistema]{python}
"""Clase para listas ordenadas con reprentación latex

Un Sistema es una lista ordenada de objetos. Los Sistemas se instancian
con una lista, tupla u otro Sistema. 

Parámetros:
    arg (list, tuple, Sistema): lista, tupla o Sistema de objetos.

Atributos:
    lista       (list): lista de objetos.
    n            (int): número de elementos del sistema.
    corteSistema (set): índices de los elementos tras los que mostrar
                        una separación en la representación LaTeX
Ejemplos:
>>> # Crea un nuevo Sistema a partir de una lista, tupla o Sistema
>>> Sistema( [ 10, 'hola', T({1,2}) ]  )           # con lista
>>> Sistema( ( 10, 'hola', T({1,2}) )  )           # con tupla
>>> Sistema( Sistema( [ 10, 'hola', T({1,2}) ] ) ) # con Sistema

[10; 'hola'; T({1, 2});]

"""
\end{minted}

\subsection{Método de inicialización}
\label{sec:org2225fd7}

La clase se inicia con el método: \texttt{def\_\_init\_\_(self,...)}.

\begin{itemize}
\item Un \texttt{Sistema} se instancia con el argumento \texttt{arg} (que es una \hyperref[sec:org4573279]{\emph{ristra}} de objetos ---Sección
\ref{sec:org4573279}).

\item Añadimos un breve texto de ayuda que Python mostrará con: \texttt{help Sistema.\_\_init\_\_}

\item Cuando \texttt{arg} es una lista, tupla o \texttt{Sistema}, el atributo \texttt{self.lista} guarda una lista en forma
de \texttt{list} (lista de Python) con los elementos contenidos en \texttt{arg}.

\item Cuando \texttt{arg} no es una lista, tupla, o \texttt{Sistema} se devuelve un mensaje de error.

\item El atributo \texttt{.n} contiene el número de elementos del \texttt{Sistema}.

\item El atributo \texttt{.corteSistema} tiene que ver con una modificación de la \hyperref[sec:orgd4628dd]{Representación de la clase
\texttt{Sistema}} para \emph{visualmente} cortar el \texttt{Sistema} en sublistas con unas líneas verticales en las
posiciones indicadas en este atributo (Véase la Sección \ref{sec:orgd4628dd}).
\end{itemize}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la clase Sistema]{python}

def __init__(self, arg):
    """Inicializa un Sistema con una lista, tupla o Sistema"""
    if es_ristra(arg):
        self.lista = list(arg)
    else:
        raise ValueError('El argumento debe ser una lista, tupla, o Sistema.')
    
    self.n = len(self)
    self.corteSistema = set()

\end{minted}

En las siguientes secciones se definen los métodos de la clase \texttt{Sistema}, empezando por aquellos que
fuerzan a que un \texttt{Sistema} se comporte como una \texttt{list} de Python en ciertos aspectos.

\medskip

\subsection{Métodos similares a los de una \texttt{list}}
\label{sec:org0171e4f}
Los siguientes métodos replican en la clase \texttt{Sistema} algunos aspectos de la clase \texttt{list} de Python.

Para que un \texttt{Sistema} sea iterable necesitamos los métodos ``mágicos'' \texttt{\_\_getitem\_\_} (para
seleccionar componentes) y \texttt{\_\_setitem\_\_} (para modificar componentes).  Así, con \texttt{A[0]} obtendremos
el primer elemento del sistema \texttt{A} y con \texttt{A[2] = 0} sustituiremos su tercer elemento por cero.\footnote{¡Recuerde que en Python los índices comienzan en \texttt{0}!  Aunque \texttt{NAcAL} incorpora este ``pythonesco''
modo de indexar \texttt{Sistemas}, posteriormente (Sección \ref{sec:org7aef252}) se añade otro método adicional que implementa el operador selector
`` \texttt{|} '' y que, tal como se hace en el \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#chapter.1}{libro}, emplea el \texttt{1} como primer índice.}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __getitem__(self, i):
    """Devuelve el i-ésimo coeficiente del Sistema"""
    return self.lista[i]

def __setitem__(self, i, nuevo_valor):
    """Modifica el i-ésimo coeficiente del Sistema"""
    self.lista[i] = nuevo_valor
        
\end{minted}

Con \texttt{len(A)} contamos el número de elementos del \texttt{Sistema}. 


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __len__(self):
    """Número de elementos del Sistema """
    return len(self.lista)

\end{minted}

Con \texttt{copy} podemos hacer una copia, por ejemplo \texttt{B = A.copy()} hace una copia del sistema \SV{A}
generando un nuevo sistema del mismo \emph{tipo} (de la misma clase o subclase) y con una \texttt{lista} de
elementos igual que la de \texttt{A}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def copy(self):
    """ Genera un Sistema copiando la lista de otro """
    return type(self)(self.lista)

\end{minted}

Así, si \texttt{A = Vector([1,2,3])} entonces \texttt{B = A.copy()} es un nuevo \texttt{Vector} con idéntica \texttt{lista} de
elementos que \texttt{A}. Sin embargo, \texttt{B = Sistema(A)} devuelve un el sistema genérico \texttt{Sistema([1,2,3])}.

Además, al disponer del método \texttt{\_\_getitem\_\_}, también podemos generar un sistema con la misma
\texttt{lista} de elementos que otro del sistema haciendo \emph{``slicing''}: \texttt{B = Sistema(A[:])}, pues \texttt{A[:]}
nos devuelve la \texttt{lista} de \texttt{A}.

Más adelante se implementa otro \hyperref[sec:org95f5670]{Método para copiar un Sistema y sus atributos} (\texttt{fullcopy()}) que no
aparece aquí porque no es un método de las \texttt{lists} de Python.

\medskip

Comprobamos si \texttt{A} y \texttt{B} son iguales con \texttt{A==B} y si son distintos con \texttt{A!=B}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __eq__(self, other):
    """Indica si es cierto que dos Sistemas son iguales"""
    return self.lista == other.lista

def __ne__(self, other):
    """Indica si es cierto que dos Sistemas son distintos"""
    return self.lista != other.lista

\end{minted}

Con \texttt{A.reverse()} invertimos el orden de los elementos de \texttt{A} (por tanto cambiamos el sistema
\texttt{A}). Con \texttt{reversed(A)} obtenemos un nuevo \texttt{Sistema} con los elementos de \texttt{A} en el orden inverso a
como aparecen en \texttt{A}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def reverse(self):
    """Da la vuelta al orden de la lista del sistema"""
    self.corteSistema = {len(self)-i for i in self.corteSistema}
    self.lista.reverse()
    
def __reversed__(self):
    """Reversed(S) devuelve una copia de S con la lista en orden inverso"""
    copia = self.fullcopy()
    copia.corteSistema = {len(self)-i for i in self.corteSistema}
    copia.lista = list(reversed(self.lista))
    return copia
    
\end{minted}

\subsection{Concatenación de \texttt{Sistemas}}
\label{sec:org7cd714a}

Concatenamos dos \texttt{Sistemas} con el método \texttt{concatena()}.

(\emph{Primero definimos un método auxiliar que se usa cuando} \texttt{divisionesVisuales} \emph{es} \texttt{True}).

Cuando intentamos concatenar un \texttt{Sistema} con algo que no lo es obtenemos un mensaje de error.

Cuando el \texttt{Sistema} no es vacío el procedimiento arranca con una copia completa de dicho sistema (es
decir, una copia que también incluye valor del atributo \texttt{.corteSistema}). Pero si el \texttt{Sistema} es
vacío obtenemos una copia completa del segundo sistema (y con dicha copia el método termina).

\texttt{A.concatena(B)} es un nuevo \texttt{Sistema} cuya \texttt{lista} es la concatenación de la \texttt{lista} del sistema
\texttt{A} seguida de la \texttt{lista} del sistema \texttt{B}; por tanto, el número \texttt{n} de elementos del \texttt{Sistema}
resultante es la suma del número de elementos de \texttt{A} más el de \texttt{B}.

Si queremos visualizar cortes o divisiones que separen sublistas del \texttt{Sistema}, a las divisiones
visuales pre-existentes en ambos \texttt{Sistemas}, se añade otra en la posición que separa los sistemas
originales. El método \texttt{nuevoConjuntoMarcas()} devuelve el conjunto de índices donde representar
dichos cortes.

Si los elementos de la lista resultante no tienen la misma longitud (por ejemplo, si concatenamos
dos matrices con distinto número de filas), entonces el sistema no puede ser representado como un
arreglo rectangular de objetos porque no tiene dicha estructura. En tal caso el tipo de objeto
resultante será un \texttt{Sistema} genérico.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método de la clase Sistema para concatenar dos sistemas]{python}

def concatena(self, other, marcasVisuales=False):
    """Concatena dos Sistemas"""
    
    def nuevoConjuntoMarcas(Sistema_A, Sistema_B):
        return Sistema_A.corteSistema.union(
            {len(Sistema_A)},
            {len(Sistema_A)+indice for indice in Sistema_B.corteSistema}
        )
    
    if not isinstance(other, Sistema):
        raise ValueError('Un Sistema solo se puede concatenar a otro Sistema')

    if self:
        sistemaAmpliado = self.fullcopy()
    else:
        return other.fullcopy()
        
    sistemaAmpliado.lista = self.lista + other.lista
    sistemaAmpliado.n = len(self) + len(other)
        
    if marcasVisuales: 
        sistemaAmpliado.corteSistema = nuevoConjuntoMarcas(self, other)

    return sistemaAmpliado if self.es_arreglo_rectangular() else Sistema(sistemaAmpliado)

\end{minted}

El método \texttt{junta()} crea el \texttt{Sistema} resultante de concatenar una
lista de sistemas. Por ejemplo \texttt{A.junta([B,C,D])} devuelve el sistema
cuya \texttt{lista} es la concatenación de las \texttt{listas} de los sistemas \texttt{A},
\texttt{B}, \texttt{C} y \texttt{D}. Si \texttt{marcas} es \texttt{True} se muestran los cortes entre los
distintos subsistemas.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método que junta una lista de Sistemas en un único Sistema]{python}

def junta(self, lista, marcas=False):
    """Junta una lista o tupla de Sistemas en uno solo concatenando las
    correspondientes listas de los distintos Sistemas

    """
    reune = lambda lista,marcas: lista[0] if len(lista)==1 else lista[0].concatena(reune(lista[1:],marcas), marcas)    
    return reune([self] + [sistema for sistema in lista], marcas)
    
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método que amplía la lista de un Sistema con nuevos elementos]{python}

def amplia(self, args, marcas=False):
    """Añade más elementos al final de la lista de un Sistema"""
    A = self.fullcopy()
    return A.concatena(Sistema(CreaLista(args)), marcas)

\end{minted}

\subsection{Sustitución y simplificación de expresiones simbólicas en un \texttt{Sistema}}
\label{sec:org197b88c}

\subsubsection{Sustitución de variables simbólicas.}
\label{sec:org812cc9d}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Sustitución de variables simbólicas]{python}

def subs(self, reglasDeSustitucion=[]):
    """ Sustitución de variables simbólicas """
    reglas = CreaLista(reglasDeSustitucion)
    NuevoSistema = self.fullcopy()
    NuevoSistema.lista = [sympy.S(elemento).subs(CreaLista(reglas)) for elemento in NuevoSistema]
    return NuevoSistema

\end{minted}

El argumento es una lista de \href{https://docs.sympy.org/latest/tutorials/intro-tutorial/basic\_operations.html}{reglas de sustitución} formadas por pares
\texttt{(símbolo, valor)}; por ejemplo \texttt{[(a,2), (b,0), (c,a)]}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
A = Sistema([ a, b, c ])
A.subs([(a,222), (b,sympy.sqrt(5)), (c,a)])
\end{minted}

$$\left[ \begin{array}{ccc}222;& \sqrt{5};& a;\end{array} \right]$$

Cuando hay una única regla de sustitución, basta escribir como
argumento el correspondiente par. Por ejemplo: \texttt{A.subs( (a,0) )}.

\subsubsection{Métodos para \href{https://docs.sympy.org/latest/tutorials/intro-tutorial/simplification.html}{simpificar} expresiones simbólicas}
\label{sec:org000d8af}

Simplificación de las expresiones simbólicas contenidas en la \texttt{lista} de un \texttt{Sistema}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Simplificación de expresiones simbólicas en la lista de un Sistema]{python}

def simplify(self):
    """ Simplificación de expresiones simbólicas """
    self.lista = [simplify(elemento) for elemento in self.lista]
                                                               
def factor(self):
    """ Factorización de expresiones simbólicas """
    self.lista = [factor(elemento) for elemento in self.lista]

def expand(self):
    """ Factorización de expresiones simbólicas """
    self.lista = [expand(elemento) for elemento in self.lista]

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
x, y, z = sympy.symbols('x y z')
A = Sistema([(x**3 + x**2 - x - 1)/(x**2 + 2*x + 1), x**2*z + 4*x*y*z + 4*y**2*z])
\end{minted}

$$\left[ \begin{array}{cc}\frac{x^{3} + x^{2} - x - 1}{x^{2} + 2 x + 1};& x^{2} z + 4 x y z + 4 y^{2} z;\end{array} \right]$$


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
A.simplify()
\end{minted}

$$\left[ \begin{array}{cc}x - 1;& z \left(x^{2} + 4 x y + 4 y^{2}\right);\end{array} \right]$$

\subsection{Otros métodos de la clase \texttt{Sistema}}
\label{sec:orgc4439ae}
\subsubsection{Método para copiar un Sistema con todos sus atributos}
\label{sec:org95f5670}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def fullcopy(self):
    """ Copia la lista de otro Sistema y sus atributos"""
    new_instance = self.copy()
    new_instance.__dict__.update(self.__dict__)
    return new_instance

\end{minted}

\subsubsection{Método para recuperar el \texttt{Sistema} genérico de cualquier subclase de \texttt{Sistema}}
\label{sec:orgb3dda27}

Con el método \texttt{sis} obtendremos el \texttt{Sistema} correspondiente a
cualquier \texttt{Sistema} o subclase de \texttt{Sistema}. Así, si \texttt{A} es una
\texttt{Matrix}, con \texttt{A.sis()} obtenemos el \texttt{Sistema} de \texttt{Vectores}
(columnas) asociado.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def sis(self):
    """Devuelve el Sistema en su forma genérica"""
    return Sistema(self.lista)

\end{minted}

\subsubsection{Comprobación de que un \texttt{Sistema} es nulo}
\label{sec:org816766f}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def es_nulo(self, sust=[]):
    """Indica si es cierto que el Sistema es nulo"""
    return self.subs(sust) == self*0

def no_es_nulo(self, sust=[]):
    """Indica si es cierto que el Sistema no es nulo"""
    return self.subs(sust) != self*0

\end{minted}

\subsubsection{Comprobación de que un \texttt{Sistema}  tiene estructura de arreglo rectangular}
\label{sec:org70ab244}

Un \texttt{Sistema} es un arreglo rectangular de objetos si es un \texttt{Sistema}
de \texttt{Sistemas} con idéntica longitud (como en el caso de una matriz,
pues todas sus columnas tienen el mismo número de elementos).

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def es_arreglo_rectangular(self):
    """Indica si el Sistema tiene estructura de arreglo rectangular"""

    def solo_contiene_sistemas(sis):
        return all([isinstance(elemento, Sistema) for elemento in sis])

    def elementos_con_la_misma_logitud(sis):
        primerElemento = sis|1
        return all([len(primerElemento)==len(elemento) for elemento in sis])

    if solo_contiene_sistemas(self) and elementos_con_la_misma_logitud(self):
        return True
    else:
        return False

def no_es_arreglo_rectangular(self):
    """Indica si el Sistema no tiene estructura de arreglo rectangular"""
    return not self.es_arreglo_rectangular()

\end{minted}

\subsubsection{Comprobación de que todos los elementos de un \texttt{Sistema} son del mismo tipo}
\label{sec:orga95fb64}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def es_de_composicion_uniforme(self):
   """Indica si es cierto que todos los elementos son del mismo tipo"""
   if all([es_numero(c) for c in self]):
      return True
   else:
      return all(type(elemento)==type(self|1) for elemento in self)

\end{minted}

\subsubsection{Comprobación de que todos los elementos de un \texttt{Sistema} son del mismo tipo y tienen la misma longitud}
\label{sec:org7df0590}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def es_de_composicion_y_longitud_uniforme(self):
   """Indica si es cierto que todos los elementos son del mismo tipo y
   longitud

   """
   if self.es_de_composicion_uniforme() and es_numero(self|1):
      return True   
   elif self.es_de_composicion_uniforme() and not es_numero(self|1):
      return all(len(elemento)==len(self|1) for elemento in self)
   else:
      return False
   
\end{minted}

\subsubsection{Búsqueda del primer, o del último, elemento no nulo del \texttt{Sistema}}
\label{sec:org8b8131d}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def primer_no_nulo(self, reglasDeSustitucion=[]):
    """Devuelve una lista con la posición del primer no nulo o vacía si
    todos los elementos son nulos

    """
    sistema = self.subs(reglasDeSustitucion)
    return next( ([indice] for indice, elemento in enumerate(sistema, 1) if CreaSistema(elemento).no_es_nulo()), [])

def ultimo_no_nulo(self, reglasDeSustitucion=[]):
    """Devuelve una lista con la posición del primer no nulo o vacía si
    todos los elementos son nulos

    """
    sistema = reversed(self.copy()).subs(reglasDeSustitucion)
    return next( ([len(self)-indice] for indice,elemento in enumerate(sistema) if CreaSistema(elemento).no_es_nulo()), [])

elementoPivote     = lambda self: self.extractor(self.primer_no_nulo()) if self.primer_no_nulo() else False

elementoAntiPivote = lambda self: self.extractor(self.ultimo_no_nulo()) if self.ultimo_no_nulo() else False

\end{minted}

\subsubsection{Extractor de un elemento dada una lista de indices (coordenadas)}
\label{sec:orge29e76c}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def extractor(self, listaDeIndices=[]):
    """Selección consecutiva por la derecha del sistema A empleando la
    lista de enteros de c. Ej.: si c = [5,1,2] devuelve A|5|1|2

    """
    objeto = self
    for indice in listaDeIndices:
        objeto = objeto|indice
    return objeto if listaDeIndices else []

\end{minted}

\subsubsection{Reordena un \texttt{Sistema} para generar un \texttt{BlockM}}
\label{sec:org68ef6c6}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
   
def reshape(self, orden=[]):
    "Reordena los elementos de un Sistema para generar un BlockM"
    if not orden or isinstance(orden, int):
        return self
    elif orden[0]*orden[1] == self.n:
        return ~BlockM(list(zip(*(iter(self.lista),)*orden[0])))
    else:
        raise ValueError('Orden incompatible con el número de elementos')
        return None

\end{minted}

\subsection{Métodos que devuelven \texttt{SubEspacios}}
\label{sec:orgbdc7534}
\subsubsection{Espacio generado los los elementos del \texttt{Sistema}}
\label{sec:org9fb7cd6}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def span(self, sust=[], Rn=[]):
    return SubEspacio(self.sis(), sust, Rn)

\end{minted}

\subsubsection{Espacio Nulo de un \texttt{Sistema} de composición y longitud uniforme}
\label{sec:org55d941f}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def espacio_nulo(self, sust=[], Rn=[]):
    if self: Rn = self.n
    K = self.elim(0, False, sust)
    E = I(self.n) & T(K.pasos[1])
    lista = [v for j,v in enumerate(E,1) if (K|j).es_nulo()]
    return SubEspacio(Sistema(lista)) if lista else SubEspacio(Sistema([]), Rn=Rn)

\end{minted}

\subsection{Método de resolución de sistema de Ecuaciones lineales}
\label{sec:orgf723497}
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def sel(self, v, sust=[]):
    """Devuelve la lista o EAfin con las soluciones x de sistema*x=v

    """
    A           = self.amplia(-v)
    operaciones = A.elim(1,False,sust).pasos[1]
    testigo     = 0| (I(A.n) & T(operaciones)) |0
    Normaliza   = T([]) if testigo==1 else T([( fracc(1,testigo), A.n )])
    pasos       = operaciones+[Normaliza] if Normaliza else operaciones
    K           = A & T(pasos)
    
    if (K|0).no_es_nulo():
        return Sistema([])
    else:
        solP = factor(I(self.n).amplia(V0(self.n)) & T(pasos))|0
        if self.espacio_nulo().sgen.es_nulo():
            return Sistema([solP])
        else:
            return EAfin(self.espacio_nulo().sgen, solP, 1)

\end{minted}

\section{Operaciones algebraicas sobre \texttt{Sistemas}}
\label{sec:orgd77f10a}

\subsection{Implementación del operador selector por la derecha para la clase \texttt{Sistema}}
\label{sec:org7aef252}

Esta sección muestra la implementación del operador selector tal como
se describe en el curso, es decir, la selección de elementos de un
\texttt{Sistema} con el operador \texttt{|} actuando por la derecha. El siguiente
texto de ayuda es auto-explicativo y Python lo muestra al teclear
\texttt{help(Sistema.\_\_or\_\_)}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para el operador selector por la derecha para la clase Sistema]{python}
"""Extrae el j-ésimo componente del Sistema; o crea un Sistema con la
tupla de elementos indicados (los índices comienzan por el número 1)

Parámetros:
    j (int, list, tuple, slice): Índice (o lista de índices) del 
          elementos (o elementos) a seleccionar

Resultado:
          ?: Si j es int, devuelve el elemento j-ésimo del Sistema.
    Sistema: Si j es list, tuple o slice devuelve el Sistema formado por
          los elementos indicados en la lista, tupla o slice de índices.

Ejemplos:
>>> # Extrae el j-ésimo elemento del Sistema 
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | 2

Vector([0, 2])

>>> # Sistema formado por los elementos indicados en la lista (o tupla)
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | [2,1]
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | (2,1)

[Vector([0, 2]); Vector([1, 0])]

>>> # Sistema formado por los elementos indicados en el slice
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | slice(1,3,2)

[Vector([1, 0]), Vector([3, 0])]

"""
\end{minted}

Cuando el argumento \texttt{j} es un número entero (\texttt{int}), se selecciona el
\texttt{j}-ésimo elemento del sistema (recuerde que en Python los índices de
objetos iterables comienzan en cero; consecuentemente, al seleccionar
el \texttt{j}-ésimo elemento del sistema \texttt{A} con el operador selector
(\texttt{A|j}), lo que realmente estamos ejecutando es la operación
\texttt{A.lista[j-1]}).

Se emplea el método (\texttt{self|indice}) (siendo \texttt{indice} un \texttt{int}) para
definir el operador selector cuando \texttt{j} es una lista o tupla de
índices y generar así un sistema con las componentes indicadas. El
sistema obtenido será del mismo tipo que \texttt{self}, es decir, o un
\texttt{Sistema} genérico, o un \texttt{BlockV}, o un \texttt{Vector}, o una \texttt{BlockM}, o
una \texttt{Matrix} dependiendo de a qué objeto se aplica el selector.

Cuando el argumento \texttt{j} es de tipo \texttt{slice(start,stop,step)}, se crea
un \texttt{Sistema} con la selección de ciertos componentes; comenzando por
aquél cuyo índice es \texttt{start}, y seleccionando de \texttt{step} en \texttt{step}
componentes hasta llegar al de índice \texttt{stop}. Dicho sistema será del
mismo tipo que \texttt{self}. Si el primer argumento de \texttt{slice} es \texttt{None} se
seleccionan los componentes empezando por el primero. Si el segundo
argumento de \texttt{slice} es \texttt{None} se recorren todos los índices hasta
llegar al último componente. Si se omite el tercer argumento de
\texttt{slice} (o si el tercer argumento es \texttt{None}) entonces \texttt{step} es igual
a uno. Así, \texttt{slice(None,None)} selecciona todos los componentes;
\texttt{slice(2,None,2)} selecciona los componentes pares hasta el final; y
\texttt{slice(4,11,3)} selecciona un componente de cada tres comenzando por
el cuarto y hasta llegar al undécimo (es decir, los índices 4, 7 y
10).

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Operador selector por la derecha para la clase Sistema]{python}

def __or__(self,j):
    <<Texto de ayuda para el operador selector por la derecha para la clase Sistema>>
    if isinstance(j, int):
        return self[j-1]
        
    elif isinstance(j, (list,tuple) ):
        return type(self) ([ self|indice for indice in j ])
    
    elif isinstance(j, slice):
        start = None if j.start is None else j.start-1 
        stop  = None if j.stop  is None else (j.stop if j.stop>0 else j.stop-1)
        step  = j.step  or 1
        return type(self) (self[slice(start,stop,step)])

\end{minted}

El operador selector por la derecha funciona de la misma manera tanto
para la clase \texttt{Sistema} como para cualquiera de sus subclases.

\subsection{Implementación del operador selector por la izquierda para la clase \texttt{Sistema}}
\label{sec:orgcc8d78b}

En el curso de Álgebra Lineal admitimos la selección de elementos por
la izquierda, \(\;\elemL{\Vect{v}}{i}=\elemR{\Vect{v}}{i}\).

La implementación de esta operación es inmediata\dots{} si el selector
por la izquierda hace lo mismo que el selector por la derecha, basta
con llamar al selector por la derecha: \texttt{self|i}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Operador selector por la izquierda para la clase Sistema]{python}

def __ror__(self,i):
    """Hace exactamente lo mismo que el método __or__ por la derecha."""
    return self | i

\end{minted}

(\emph{Tenga en cuenta que este método cambia en las subclases \texttt{BlockM} y \texttt{Matrix}, pues lo usaremos para seleccionar las filas de dichos arreglos rectangulares de objetos.})

\subsection{Suma y diferencia de \texttt{Sistemas}}
\label{sec:org6a14b5e}

Con la definición de la clase \texttt{Sistema} y el operador selector \texttt{|} por
la derecha, ya podemos definir las operaciones de suma de dos sistemas
y de producto de un sistema por un escalar. Fíjese que las
definiciones de las operaciones en Python (usando el operador \texttt{|}) son
idénticas a las empleadas en el \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#section.1.2}{curso}, donde hemos definido la suma de
dos vectores de \R[n] como el vector tal que
\begin{displaymath}
  \fbox{\begin{math} \elemR{(\Vect{a}+\Vect{b})}{i}=\eleVR{a}{i}+\eleVR{b}{i} \end{math}}
  \quad\text{para}\quad i=1:n
\end{displaymath}
y la \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#section.1.5}{suma de matrices} como la matriz tal que
\begin{displaymath}
  \fbox{\begin{math} \elemRP{\Mat{A}+\Mat{B}}{j}=\VectC{A}{j}+\VectC{B}{j} \vphantom{\Big(} \end{math}}
  \quad\text{para}\quad i=1:n.
\end{displaymath}
Ambas son casos particulares de sumas elemento a elemento entre dos sistemas de \(n\) elementos:
\begin{displaymath}
  \fbox{\begin{math} \elemRP{\SV{a}+\SV{b}}{i}=\elemR{\SV{a}}{i}+\elemR{\SV{b}}{i} \end{math}}
  \quad\text{para}\quad i=1:n.
\end{displaymath}
Usando el operador selector podemos ``literalmente'' transcribir esta definición

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
Sistema ([ (self|i) + (other|i) for i in range(1,len(self)+1) ])
\end{minted}
donde \texttt{self} es el sistema \SV{A}, \texttt{other} es \SV{B}, y
\texttt{range(1,self.n+1)} es el rango de valores: \(1:n\).

Hay que tener en cuenta que cuando el \texttt{Sistema} es un \texttt{Vector} el
resultado es un \texttt{Vector} y cuando el \texttt{Sistema} es una \texttt{Matrix} el
resultado es una \texttt{Matrix}. Es decir, el código debe devolver un objeto
del mismo tipo que \texttt{self}. Esto lo logramos sustituyendo \texttt{Sistema} por
\texttt{type(self)} en el código anterior. Así, la implementación final es:

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
type(self) ([ (self|i) + (other|i) for i in range(1,len(self)+1) ])
\end{minted}
Por último, nótese que para que la implementación funcione es
necesario que los elementos \(\elemR{\SV{a}}{i}\) y \(\elemR{\SV{b}}{i}\)
sean sumables, es decir, es necesario que la operación

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
(self|i) + (other|i)
\end{minted}
esté definida para cada \texttt{i}. (De manera análoga definimos diferencia
entre \texttt{Sistemas}).

Python muestra el texto de ayuda para la suma tecleando \texttt{help(Sistema.\_\_add\_\_)}.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para el operador resta en la clase Sistema]{python}
"""Devuelve el Sistema resultante de sumar dos Sistemas

Parámetros: 
    other (Sistema): Otro sistema del mismo tipo y misma longitud

Ejemplos:
>>> Sistema([10, 20, 30]) + Sistema([-1, 1, 1])

Sistema([9, 21, 31]) 
>>> Vector([10, 20, 30]) + Vector([-1, 1, 1])

Vector([9, 21, 31]) 
>>> Matrix([[1,5],[5,1]]) + Matrix([[1,0],[0,1]]) 

Matrix([Vector([2, 5]); Vector([5, 2])]) """
\end{minted}

Python muestra el texto de ayuda para la diferencia tecleando \texttt{help(Sistema.\_\_sub\_\_)}.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para el operador diferencia en la clase Sistema]{python}
"""Devuelve el Sistema resultante de restar dos Sistemas

Parámetros: 
    other (Sistema): Otro sistema del mismo tipo y misma longitud

Ejemplos:
>>> Sistema([10, 20, 30]) - Sistema([1, 1, -1])

Sistema([9, 19, 31])
>>> Vector([10, 20, 30]) - Vector([1, 1, -1])

Vector([9, 19, 31])
>>> Matrix([[1,5],[5,1]]) - Matrix([[1,0],[0,1]]) 

Matrix([Vector([0, 5]); Vector([5, 0])]) 
"""
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Suma y diferencia de Sistemas]{python}

def __add__(self, other):
    <<Texto de ayuda para el operador suma en la clase Sistema>>
    if not type(self)==type(other) or not len(self)==len(other):
        raise ValueError ('Solo se suman Sistemas del mismo tipo y misma longitud')
    suma = self.fullcopy()
    suma.lista = [ (self|i) + (other|i) for i in range(1,len(self)+1) ]
    suma.corteSistema.update(other.corteSistema)
    return factor(suma)
            
def __sub__(self, other):
    <<Texto de ayuda para el operador diferencia en la clase Sistema>>
    if not type(self)==type(other) or not len(self)==len(other):
        raise ValueError ('Solo se restan Sistemas del mismo tipo y misma longitud')
    diferencia = self.fullcopy()
    diferencia.lista = [ (self|i) - (other|i) for i in range(1,len(self)+1) ]
    diferencia.corteSistema.update(other.corteSistema)
    return factor(diferencia)
            
\end{minted}

\subsection{Producto de un \texttt{Sistema} por un escalar a su izquierda}
\label{sec:org67c960b}

El producto de un sistema \SV{a} por un escalar \(x\) a su izquierda es
el \emph{sistema}
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\SV{a}}{i}=x \elemRPE{\SV{a}}{i}
  \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
cuya transcripción literal es
\begin{center}
  \Verb/ Sistema ( [ x*(self|i) for i in range(1,len(self)+1) ] ) /
\end{center}

donde \texttt{x} es un número (\texttt{int}, \texttt{float} o un objeto del módulo \href{https://docs.sympy.org/latest/index.html}{Sympy}
\texttt{sympy.Basic}) y \texttt{self} es \SV{A}.

Casos particulares son el producto de un \emph{vector} \Vect{a}
por un escalar \(x\) a su izquierda, que es el \emph{vector}:
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\Vect{a}}{i}=x \eleVRPE{a}{i}
  \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
Y el producto de una \emph{matriz} \Mat{A} por un escalar \(x\) a su
izquierda, que es la \emph{matriz}:
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\Mat{A}}{j}=x\VectCPE{A}{j}
    \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
Como en los casos particulares se obtienen \emph{sistemas} de tipos
particulares (\emph{vectores} en el primer caso y \emph{matrices} en el
segundo), debemos sustituir \texttt{Sistema} por \texttt{type(self)} para
obtener sistemas del mismo tipo que \texttt{self}:
\begin{center}
  \Verb/ type(self) ( [ x*(self|i) for i in range(1,len(self)+1) ] ) /
\end{center}

Texto de ayuda para el operador producto por la izquierda en la clase \texttt{Sistema}
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para el operador producto por la izquierda de un Sistema]{python}
"""Multiplica un Sistema por un número a su izquierda

Parámetros:
    x (int, float o sympy.Basic): Escalar por el que se multiplica
Resultado:
    Sistema resultante de multiplicar cada componente por x
Ejemplo:
>>> 3 * Sistema([10, 20, 30]) 

Sistema([30, 60, 90]) 
"""
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Producto de un Sistema por un escalar a su izquierda]{python}

def __rmul__(self, x):
    <<Texto de ayuda para el operador producto por la izquierda de un Sistema>>
    if es_numero(x):
        multiplo = self.fullcopy()
        multiplo.lista = [ x*(self|i) for i in range(1,len(self)+1) ]
        return factor(multiplo)

\end{minted}

También nos viene viene bien manejar el opuesto de un \texttt{Sistema}:
\begin{math}
 -\SV{A}=-1\cdot\SV{A}.
\end{math}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Opuesto de un Sistema]{python}

def __neg__(self):
    """Devuelve el opuesto de un Sistema"""
    return -1*self

\end{minted}

\subsection{Producto de un \texttt{Sistema} por escalar, \texttt{Vector} o  \texttt{Matrix} a su derecha}
\label{sec:orgcadbc34}

En el curso se acepta que el producto de un \texttt{Sistema} por un escalar
es conmutativo. Por tanto,
\begin{displaymath}
  \fbox{\begin{math} 
           \SV{A}x=x\SV{A}
        \end{math}}
\end{displaymath}
por tanto también debemos implementar el producto
\begin{center}
  \Verb/ self * x /
\end{center}
donde \texttt{self} es el \texttt{Sistema} y \texttt{x} es un número (\texttt{int}, \texttt{float},
\texttt{sympy.Basic}).


El producto de \SV{A}, de \(n\) componentes, por un vector \Vect{x} de
\R[n] a su derecha se define como
\begin{displaymath}  
    \fbox{$\SV{A}\Vect{x}\;=\;\elemRPE{\SV{A}}{1}x_1+\cdots+\elemRPE{\SV{A}}{n}x_n\;=\;\sum_{j=1}^n\elemRPE{\SV{A}}{j}x_j$}
    %\fbox{$\SV{A}\Vect{x}\;=\;\elemRPE{\SV{A}}{1}\elemRPE{\Vect{x}}{1}+\cdots+\elemRPE{\SV{A}}{n}\elemRPE{\Vect{x}}{n}\;=\;\sum_{j=1}^n\elemRPE{\SV{A}}{j}\elemRPE{\Vect{x}}{j}$}
    \qquad\text{para}\; j=1:n.
\end{displaymath}
cuya transcripción será
\begin{center}
  \Verb/ sum([ (self|j)*(x|j) for j in range(1,x.n+1) ]) /
\end{center}
donde \texttt{self} es un \texttt{Sistema} y \texttt{x} es un (\texttt{Vector}).

Fíjese que el \emph{producto punto} (o producto escalar usual en \R[n]) de
dos vectores \Vect{a} y \Vect{x} en \(\R[n]\) es un caso particular en
el que el sistema \(\SV{A}\) es un vector \(\Vect{a}\).

El producto del sistema \SV{A} de \(p\) componentes por una matriz
\Matdim{x}{p}{n} de \R[n] a su derecha se define como el sistema tal
que
\begin{displaymath}
  \fbox{$\elemR{(\SV{A}\Mat{X})}{j}=\SV{A}(\VectC{X}{j})$}
  \qquad\text{para}\; j=1:n.
\end{displaymath}
cuya transcripción será
\begin{center}
  \Verb/ type(self) ( [ self*(x|j) for j in range(1,x.n+1)] ) /
\end{center}
donde \texttt{self} es el \texttt{Sistema} y \texttt{x} es una \texttt{Matrix}.

Fíjese que el \emph{producto de matrices} es un caso particular en el que
el sistema \(\SV{A}\) es una matriz \(\Mat{A}\).

Además, sabemos por las notas de la asignatura que en el caso
particular de que el sistema \(\SV{A}\) sea un vector, el resultado es
una combinación lineal de las filas de la matriz \Mat{X} (es decir, el
resultado es un vector). Para recordar que el vector resultante es una
combinación lineal de las filas, lo representaremos en forma de fila.

Python muestra el siguiente texto de ayuda al teclear
\texttt{help(Sistema.\_\_mul\_\_)}.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para el operador producto por la derecha en la clase Sistema]{python}
"""Multiplica un Sistema por un número, Vector o una Matrix a su derecha

Parámetros:
    x (int, float o sympy.Basic): Escalar por el que se multiplica
      (Vector): con tantos componentes como el Sistema
      (Matrix): con tantas filas como componentes tiene el Sistema

Resultado:
    Sistema del mismo tipo: Si x es int, float o sympy.Basic, devuelve 
       el Sistema que resulta de multiplicar cada componente por x
    Objeto del mismo tipo de los componentes del Sistema: Si x es Vector,
       devuelve una combinación lineal de los componentes del Sistema, 
       donde los componentes de x son los coeficientes de la combinación.
    Sistema del mismo tipo: Si x es Matrix, devuelve un Sistema cuyas 
       componentes son combinación lineal de las componentes originales.
       
Ejemplos:
>>> # Producto por un número
>>> Vector([10, 20, 30]) * 3

Vector([30, 60, 90])
>>> Matrix([[1,2],[3,4]]) * 10

Matrix([[10,20],[30,40]])
>>> # Producto por un Vector
>>> Vector([10, 20, 30]) * Vector([1, 1, 1])

60
>>> Matrix([Vector([1, 3]), Vector([2, 4])]) * Vector([1, 1])

Vector([3, 7])
>>> # Producto por una Matrix
>>> Vector([1,1,1])*Matrix( ( [1,1,1], [2,4,8], [3,-1,0] ) )

Vector([6, 4, 9])
>>> Matrix([Vector([1, 3]), Vector([2, 4])]) * Matrix([Vector([1,1])]))

Matrix([Vector([3, 7])])

"""
\end{minted}

Para implementar la operación \texttt{Sistema} por número se llama a la
operación número por \texttt{Sistema}.

Para implementar \texttt{Sistema} por \texttt{Vector} se usa la función \texttt{sum}; que
tiene dos argumentos: el primero es la lista de objetos a sumar, y el
segundo es un primer objeto al que se suman los de la lista (por
defecto es el \emph{número} ``\(0\)''). Como la suma de \(0\) y un
elemento del \texttt{Sistema} puede no tener sentido, se emplea el siguiente
truco: ese primer objeto es el primer elemento de la lista
multiplicado por \(0\).

Para implementar \texttt{Sistema} por \texttt{Matrix} se usa la operación \texttt{Sistema}
por \texttt{Vector} para generar cada uno de los elementos del sistema
resultante. Cuando el \texttt{Sistema} es un \texttt{Vector}, la operación \texttt{Sistema}
por \texttt{Matrix} calcula el producto de un \texttt{Vector} por una \texttt{Matrix}. Para
recordar que el sistema resultante es una combinación lineal de las
filas de la matriz, la representación del resultado sera en forma
horizontal (\texttt{rpr='h'}) si se emplea la representación \texttt{latex}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Producto de un Sistema por un escalar un Vector o una Matrix a su derecha]{python}

def __mul__(self,x):
    <<Texto de ayuda para el operador producto por la derecha en la clase Sistema>>
    if es_numero(x):
        return x*self

    elif isinstance(x, Vector):
        if len(self) != x.n:
            raise ValueError('Sistema y Vector incompatibles')
        if self.es_arreglo_rectangular():
            if not all([f.es_de_composicion_y_longitud_uniforme() for f in ~BlockM([BlockV([i]) for i in self])]):
                raise ValueError('El sistema de la derecha debe tener elementos de composicion y longitud uniforme')
        elif not self.es_de_composicion_y_longitud_uniforme():
            raise ValueError('El sistema de la derecha debe tener elementos de composicion y longitud uniforme')
            
        return factor(sum([(self|j)*(x|j) for j in range(1,len(self)+1)], 0*self|1))
    
    elif isinstance(x, Matrix):
        if len(self) != x.m:
            raise ValueError('Sistema y Matrix incompatibles')
        if isinstance(self, BlockV):
            return factor(BlockV( [ self*(x|j) for j in range(1,(x.n)+1)], rpr='h' ))
        elif isinstance(self, BlockM):
            return factor(BlockM ( [ self*(x|j) for j in range(1,(x.n)+1)] ))
        else:
            return factor(type(self) ( [ self*(x|j) for j in range(1,(x.n)+1)] ))

\end{minted}

\section{Transformaciones elementales de un \texttt{Sistema}}
\label{sec:orgbc5fcba}

En el \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#section.9.3}{libro} del curso se definen las transformaciones elementales de
\texttt{Sistemas} de vectores como una generalización a las transformaciones
elementales de las columnas de una \texttt{Matrix}. Puesto que cada \texttt{Matrix}
es un \texttt{Sistema} de \texttt{Vectores}, implementamos de manera general las
transformaciones elementales sobre \texttt{Sistemas} genéricos.

Como el método no verifica si las operaciones son licitas, podría
obtener un error si el sistema contiene objetos incompatibles con
dichas operaciones; por ejemplo, si el \texttt{Sistema} contiene una cadena
de caracteres y un número, al intentar sumar un múltiplo de uno de los
elementos al otro obtendremos un error (aunque esto no pasará con los
intercambios).

\subsection{Texto de ayuda transformaciones elementales por la derecha}
\label{sec:org01fa15d}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de las transformaciones elementales de un Sistema]{python}
"""Transforma los elementos de un Sistema 

    T(abreviaturas): transformaciones a aplicar sobre un Sistema S
Ejemplos:
>>>  S & T({1,3})                # Intercambia los elementos 1º y 3º
>>>  S & T((5,1))                # Multiplica por 5 el primer elemento
>>>  S & T((5,2,1))              # Suma 5 veces el 2º elem al 1º
>>>  S & T([{1,3},(5,1),(5,2,1)])# Aplica la secuencia de transformac.
             # sobre los elementos de S y en el orden de la lista
"""
\end{minted}

\subsection{Implementación de las transformaciones elementales por la derecha}
\label{sec:org00043ed}

(\emph{aunque sea una composición de transformaciones elementales, también
se incluye el intercambio.})

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Transformaciones elementales de los elementos de un Sistema]{python}

def __and__(self,operaciones):
    <<Texto de ayuda de las transformaciones elementales de un Sistema>>
    def transformacionDelSistema(abrv):
        if isinstance(abrv,set):
            self.lista = [ (self|max(abrv)) if k==min(abrv) else \
                           (self|min(abrv)) if k==max(abrv) else \
                           (self|k)                 for k in range(1,len(self)+1)].copy()
            
        elif isinstance(abrv,tuple) and (len(abrv) == 2):
            self.lista = [ (abrv[0])*(self|k) if k==abrv[1] else (self|k) \
                                                    for k in range(1,len(self)+1)].copy()

        elif isinstance(abrv,tuple) and (len(abrv) == 3):
            colPivote = abrv[1]-1
            self.lista = [ (abrv[0])*(self.lista[colPivote]) + (self|k) if k==abrv[2] else (self|k)
                                                    for k in range(1,len(self)+1)].copy()

    for abrv in operaciones.abreviaturas:
        transformacionDelSistema(abrv)

    return factor(self)
        
\end{minted}

\textbf{Nótese que al actuar sobre \texttt{self.lista}, las transformaciones elementales no crean nuevos 
\texttt{Sistemas} sino que modifican el \texttt{Sistema} sobre el que actúan.}

\subsection{Implementación de las transformaciones elementales por la izquierda}
\label{sec:orgc5fee02}

Hacen lo mismo que por la derecha (como ocurre con el operador selector)

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Transformaciones elementales por la izquierda de un Sistema]{python}
        
def __rand__(self, operaciones):
    """Hace exactamente lo mismo que el método __and__ por la derecha."""
    return self & operaciones
    
\end{minted}

\section{Eliminación}
\label{sec:orgba22747}
\subsection{Reducción por eliminación mediante transformaciones elementales}
\label{sec:org6b062a8}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Análisis de las opciones de eliminación elegidas]{python}

def analisis_opcion_elegida(tipo):
    'Análisis de las opciones de eliminación elegidas'
    lista = [100,20,10,4,2,1]
    opcion = set()
    for t in lista:
        if (tipo - (tipo % t)) in lista:
            opcion.add(tipo - (tipo % t))
            tipo = tipo % t
    return opcion
    
\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Variantes de eliminación]{python}
def metodos_auxiliares_de_la(variante):
    """Define los métodos auxilares y el módo de actuació sobre el sistema
    en función de la variante de elimiación elegida.

    'variante' es la suma de los siguientes números:
        
       +1 reduccion rápida (solo transformaciones tipo I)
       +2 doble reducción
       +4 por filas
      +10 normalización de los pivotes
      +20 escalonamiento
     +100 de atrás hacia delante
    
    Por defecto arg = 0 (reducción simple hacia delante, por
    columnas y evitando fraciones)

    """
    if 100 in analisis_opcion_elegida(variante): # reducción hacia delante
        componentesAmodificar     = lambda    sistema:  filter(lambda x:  x < indiceXP, range(1,len(sistema)+1))
        recorrido                 = lambda    sistema:  reversed(list(enumerate(CreaSistema(sistema),1)))
        XPivote                   = lambda componente:  elementoAntiPivote(componente)
        posicionXPivote           = lambda componente:  ultimo_no_nulo(componente)
                
    else:                                    # reducción hacia atrás
        componentesAmodificar     = lambda    sistema:  filter(lambda x:  x > indiceXP, range(1,len(sistema)+1))
        recorrido                 = lambda    sistema:  enumerate(CreaSistema(sistema),1)
        XPivote                   = lambda componente:  elementoPivote(componente)
        posicionXPivote           = lambda componente:  primer_no_nulo(componente)
        
    if 4 in analisis_opcion_elegida(variante):   # reducción de los componentes en arreglos rectangulares
        if (not self.es_arreglo_rectangular()) or (not all([item.es_de_composicion_uniforme() for item in self])):
            raise ValueError('El sistema debe ser un arreglo rectangular con componentes de composición uniforme')
        sistema = ~self.fullcopy().subs(sust);
    else:
        sistema = self.fullcopy().subs(sust);

    if 2 in analisis_opcion_elegida(variante):   # doble reducción (reducción posiciones anteriores y posteriores al pivote)
        componentesAmodificar = lambda    sistema:  filter(lambda x: x != indiceXP, range(1,len(sistema)+1))

    return sistema, recorrido, XPivote, posicionXPivote, componentesAmodificar

    
def Reduccion(sistema):
    if 1 in analisis_opcion_elegida(variante):   # reducción rápida (solo trasformaciones tipo I)
        operaciones = [ (-fracc(ValorAEliminar(indiceVAE), pivote), indiceXP, indiceVAE)  \
                                                    for indiceVAE in componentesAmodificar(sistema)]
    else:                                        # reducción lenta (evitando fracciones)
        operaciones = [[( denom(ValorAEliminar(indiceVAE), pivote),           indiceVAE), \
                        (-numer(ValorAEliminar(indiceVAE), pivote), indiceXP, indiceVAE)] \
                                                    for indiceVAE in componentesAmodificar(sistema)]
    return filtradopasos(T(operaciones))

def Normalizacion(sistema):
    return filtradopasos(T([ (fracc(1, XPivote(sistema|indiceXP)), indiceXP)
                             for indiceXP,_ in recorrido(sistema) if XPivote(sistema|indiceXP)]))

def Escalonamiento(sistema):
    M = sistema.copy()
    if 100 in analisis_opcion_elegida(variante): # con reducción hacia atrás
        destino       = lambda     : (M.n)-r+1
        resto         = lambda    r: slice(None, max(M.n-r,1))
        columnaAMover = lambda i, r: posicionXPivote(i|M|resto(r))[0]   if posicionXPivote(i|M|resto(r)) and i==posicionXPivote(M|posicionXPivote(i|M|resto(r))[0]  )[0] else 0
    else:                                        # con reducción hacia delante
        destino       = lambda     : r
        resto         = lambda    r: slice(r+1, None)
        columnaAMover = lambda i, r: posicionXPivote(i|M|resto(r))[0]+r if posicionXPivote(i|M|resto(r)) and i==posicionXPivote(M|posicionXPivote(i|M|resto(r))[0]+r)[0] else 0

    r = 0
    intercambios = []
    for i,_ in recorrido(M|1):
        indiceColumnaPivote = columnaAMover(i,r)
        if indiceColumnaPivote:
            r += 1
            intercambio  = T( {destino(), indiceColumnaPivote} )
            M & intercambio
            intercambios.append(intercambio)
            
    return filtradopasos(T(intercambios))


def transformacionYPasos(sistema, operacion, pasosPrevios):
    pasoDado = operacion(sistema)
    if 4 in analisis_opcion_elegida(variante):    # reducción de los componentes en arreglos rectangulares
        pasosAcumulados = [~pasoDado] + pasosPrevios if pasoDado else pasosPrevios
    else:
        pasosAcumulados = pasosPrevios  + [pasoDado] if pasoDado else pasosPrevios
    sistema & T(pasoDado)
    return factor(sistema.subs(sust)), pasosAcumulados


def sistemaFinalYPasosDchaIzda(sistema,transformaciones):
    if 4 in analisis_opcion_elegida(variante):    # reducción de los componentes en arreglos rectangulares
        TransformacionesPorLaIzquierda = filtradopasos(transformaciones)
        TransformacionesPorLaDerecha   = []
        if self.es_arreglo_rectangular():
            sistema = ~sistema
    else: 
        TransformacionesPorLaDerecha   = filtradopasos(transformaciones)
        TransformacionesPorLaIzquierda = []

    SistemaFinal =  sistema.subs(sust)
    pasos        = [TransformacionesPorLaIzquierda, TransformacionesPorLaDerecha]
    SistemaFinal.tex, SistemaFinal.pasos = texYpasos(self, pasos, rep, sust, repsust)
    SistemaFinal.TrF = T(SistemaFinal.pasos[0])
    SistemaFinal.TrC = T(SistemaFinal.pasos[1])
    return factor(SistemaFinal)

\end{minted}



\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Eliminación]{python}

def elim(self, variante=0, rep=False, sust=[], repsust=False):
    """Versión pre-escalonada de un sistema por eliminacion Derecha-Izquierda"""
    <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
    <<Variantes de eliminación>>
    <<Análisis de las opciones de eliminación elegidas>>
    
    if not self:
        return sistemaFinalYPasosDchaIzda(Sistema([]), [T([])] )
    
    if not self.es_de_composicion_y_longitud_uniforme():
        raise ValueError('Los elementos del sistema deben ser del mismo tipo y longitud')
    
    ValorAEliminar = lambda indiceVAE: sistema.extractor([indiceVAE]+posicionXPivote(sistema|indiceXP))
    sistema, recorrido, XPivote, posicionXPivote, componentesAmodificar = metodos_auxiliares_de_la(variante)
    
    pasosAcumulados = []
    for indiceXP,_ in recorrido(sistema):
        pivote = XPivote(sistema|indiceXP)        
        if pivote:                               # reducción
            sistema, pasosAcumulados = transformacionYPasos(sistema,  Reduccion,  pasosAcumulados)
            
    if 10 in analisis_opcion_elegida(variante):  # normalización de pivotes
        sistema, pasosAcumulados = transformacionYPasos(sistema,  Normalizacion,  pasosAcumulados)

    if 20 in analisis_opcion_elegida(variante):  # escalonamiento
        sistema, pasosAcumulados = transformacionYPasos(sistema, Escalonamiento,  pasosAcumulados)

    return sistemaFinalYPasosDchaIzda(sistema, pasosAcumulados)
        
\end{minted}



\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=formas escalonadas]{python}

def K(self,rep=0, sust=[], repsust=0):
    """Una forma pre-escalonada por columnas (K) de una Matrix"""
    return self.elim(0, rep, sust, repsust)
    
def L(self,rep=0, sust=[], repsust=0): 
    """Una forma escalonada por columnas (L) de una Matrix"""
    return self.elim(20, rep, sust, repsust)
    
def R(self,rep=0, sust=[], repsust=0):
    """Forma escalonada reducida por columnas (R) de una Matrix"""
    return self.elim(32, rep, sust, repsust)

def U(self,rep=0, sust=[], repsust=0): 
    """Una forma escalonada por filas (U) de una Matrix"""
    return self.elim(24, rep, sust, repsust)

def UR(self,rep=0, sust=[], repsust=0): 
    """Una forma escalonada reducida por filas (U) de una Matrix"""
    return self.elim(36, rep, sust, repsust)

\end{minted}

\subsection{Representación de los procesos de eliminación Gaussiana}
\label{sec:orgda90feb}

Cuando hemos encadenado varios procedimientos de eliminación,
deberíamos poder ver los pasos desde el principio hasta el final. Para
ello comprobamos si \texttt{data} fue obtenido mediante un proceso previo de
eliminación. El modo de saberlo es comprobar si \texttt{data} posee el
atributo \texttt{pasos}.  El atributo \texttt{tex} guarda el código \LaTeX{} que
muestra el proceso completo, y se construye aplicando el método
\texttt{PasosYEscritura}.  El atributo \texttt{pasos} guarda las listas de
abreviaturas de las transformaciones elementales empleadas. Por
comodidad añadimos dos atributos más: \texttt{TrF} es la
\texttt{T}transformación aplicada a las filas y \texttt{TrC} es la
\texttt{T}ransformación aplicada a las columnas.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método que define los atributos .tex y .pasos y representa los pasos si se pide]{python}

def texYpasos(data, pasos, rep=0, sust=[], repsust=0):
    pasosPrevios = data.pasos if hasattr(data, 'pasos') and data.pasos else [[],[]]
    TexPasosPrev = data.tex   if hasattr(data, 'tex')   and data.tex   else []
    if repsust:
        tex = rprElim(data, pasos, TexPasosPrev, sust)
    else:
        tex = rprElim(data, pasos, TexPasosPrev)
    pasos[0] = pasos[0] + pasosPrevios[0] 
    pasos[1] = pasosPrevios[1] + pasos[1]
    
    if rep:
        display(Math(tex))
    
    return tex, pasos

\end{minted}

Cuando mostramos los pasos, es más legible mostrar únicamente los
que modifican la matriz (omitiendo sustituciones de una columna por
ella misma, productos de una columna por 1, o sumas de un vector nulo
a una columna). 

El atributo \texttt{tex} guardará el código \LaTeX{} que muestra el proceso
completo. Si ha habido transformaciones previas, la cadena de \LaTeX{}
que permite su representación en el entorno Jupyter estará guardada en
la variable (\texttt{TexPasosPrev}), y a dicha cadena hay que añadir la
correspondiente cadena de \LaTeX{} que permita representar los nuevos \texttt{pasos} dados como argumento de este método. Si \texttt{TexPasosPrev} es
vacío, la escritura comienza con la representación de \texttt{data}. A la
hora de representar los pasos hay que tener en cuenta si se dan sobre
las filas (\texttt{l==0}) o sobre las columnas (\texttt{l==1}). 

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Representación de un proceso de eliminación rprElim]{python}

def rprElim(data, pasos, TexPasosPrev=[], sust=[], metodo=factor):
    """Escribe en LaTeX los pasos efectivos y los sucesivos sistemas"""
    A     = data.fullcopy().subs(sust)
    tex   = latex(A) if not TexPasosPrev else TexPasosPrev

    simplifica = lambda metodo,expresion: metodo(expresion) 
    
    # transformaciones por la izquierda
    for  _,pasoDeEliminacion in enumerate(pasos[0][::-1]):
        if data.es_arreglo_rectangular(): # entonces transforman las filas
            tex += '\\xrightarrow[' + latex( pasoDeEliminacion.subs(sust) ) + ']{}' 
            tex += latex( simplifica(metodo, ((pasoDeEliminacion & A).subs(sust)) ) )
        else:  # hacen lo mismo que por la derecha
            tex += '\\xrightarrow{' + latex( pasoDeEliminacion.subs(sust) ) + '}'
            tex += latex( simplifica(metodo, ((A & pasoDeEliminacion).subs(sust)) ) )
        
    # transformaciones por la derecha
    for  _,pasoDeEliminacion in enumerate(pasos[1]):
        tex += '\\xrightarrow{' + latex( pasoDeEliminacion.subs(sust) ) + '}'
        tex += latex( simplifica(metodo, ((A & pasoDeEliminacion).subs(sust)) ) )
                
    return tex

\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Representación de un proceso de eliminación rprElimCF]{python}

def rprElimCF(data, pasos, TexPasosPrev=[], sust=[], metodo=factor):
    """Escribe en LaTeX los pasos efectivos y los sucesivos arreglos rectangulares"""
    if not data.es_arreglo_rectangular():
        raise ValueError('El sistema tiene que ser un arreglo rectangular')
    if len(pasos[0])!=len(pasos[1]):
        raise ValueError('Esta representación requiere el mismo número de pasos por la izquierda y la derecha')
    
    A = data.fullcopy().subs(sust)                                                               
    tex = latex(data) if not TexPasosPrev else TexPasosPrev

    simplifica = lambda metodo,expresion: metodo(expresion)
    
    for  i,pasoDeEliminacionFilas in enumerate(pasos[0][::-1]):
        tex += '\\xrightarrow{' + latex( (pasos[1][i]).subs(sust) ) + '}'
        tex += latex( simplifica(metodo, ((A & pasos[1][i]).subs(sust))) )
        tex += '\\xrightarrow[' + latex( (pasoDeEliminacionFilas).subs(sust) ) + ']{}' 
        tex += latex( simplifica(metodo, ((pasoDeEliminacionFilas & A).subs(sust))) )
                                                               
    return tex

\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Representación de un proceso de eliminación rprElimFyC]{python}

def rprElimFyC(data, pasos, TexPasosPrev=[], sust=[], metodo=factor):
    """Escribe en LaTeX los pasos efectivos y los sucesivos arreglos rectangulares"""
    if not data.es_arreglo_rectangular():
        raise ValueError('El sistema tiene que ser un arreglo rectangular.')
    if len(pasos[0])!=len(pasos[1]):
        raise ValueError('Esta representación requiere el mismo número de pasos por la izquierda y la derecha')
    
    A = data.fullcopy().subs(sust)
    tex = latex(data) if not TexPasosPrev else TexPasosPrev

    simplifica = lambda metodo,expresion: metodo(expresion) 
    
    for  i,pasoDeEliminacionFilas in enumerate(pasos[0][::-1]):
        tex += '\\xrightarrow' \
                + '[' + latex( (filtradopasos(pasoDeEliminacionFilas)).subs(sust) ) + ']' \
                + '{' + latex( (pasos[1][i]).subs(sust)                           ) + '}'
        tex += latex( simplifica(metodo, (( pasoDeEliminacionFilas & A & pasos[1][i] )).subs(sust)) )
                                                               
    return tex

\end{minted}

Estos procedimientos son para ``mostrar'' en los Jupyter notebooks los pasos de eliminación.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Representación de un proceso de eliminación dispElim, dispElimFyC y dispElimCF]{python}

def dispElim(self, pasos, TexPasosPrev=[], sust=[], metodo=factor):
    display(Math(rprElim(self, pasos, TexPasosPrev, sust, metodo)))

def dispElimFyC(self, pasos, TexPasosPrev=[], sust=[], metodo=factor):
    display(Math(rprElimFyC(self, pasos, TexPasosPrev, sust, metodo)))

def dispElimCF(self, pasos, TexPasosPrev=[], sust=[], metodo=factor):
    display(Math(rprElimCF(self, pasos, TexPasosPrev, sust, metodo)))

\end{minted}

\section{Representación de la clase \texttt{Sistema}}
\label{sec:orgd4628dd}
Necesitamos indicar a Python cómo representar los objetos de tipo
\texttt{Sistema}. Los sistemas, son secuencias finitas de objetos que
representaremos con corchetes, separando los elementos por ``;''
\begin{displaymath}
  \Vect{v}=[v_1;\ \ldots;\ v_n;]
\end{displaymath}
Si la lista es vacía, entonces se pintan unos corchetes \texttt{[ ]} sin
 ``;'' (por no haber elementos). 

Definimos varios tipos de representación.

\begin{itemize}
\item La primera se muestra con la función \texttt{print()} o la función \texttt{str()}
y está formada por caracteres ASCII. Es la que se ve en la línea de
comandos. Entre corchetes muestra todos los elementos de
\texttt{self.lista} separados por ``puntos y comas'' (\texttt{;}):

Si, por ejemplo, el atributo \texttt{.corteSistema} (\emph{``corta Sistema''}) indica que
se separen las dos primeras componentes del sistema respecto de la
última, esta representación pinta una barra vertical detrás de la
segunda componente (véase la Sección \ref{sec:org2bf76b8}).
\end{itemize}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __str__(self):
    """ Muestra un Sistema en su representación python """
    pc = ';' if len(self.lista) else ''
    ln = [len(n) for n in particion(self.corteSistema,self.n)]
    return '[' + \
             ';|'.join(['; '.join([str(c) for c in s]) \
                       for s in [ self|i for i in particion(self.corteSistema, self.n)] ]) + pc + ']'

\end{minted}

\begin{itemize}
\item La segunda forma de representación se muestra con la función
\texttt{repr()} y también está formada por caracteres ASCII. Se parece a la
anterior, pero indica explícitamente que el objeto es un \texttt{Sistema} y
no muestra ninguna barra vertical que separe el sistema en
sublistas.
\end{itemize}



\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __repr__(self):
    """ Muestra un Sistema en su representación python """
    pc = ';' if len(self.lista) else ''
    return 'Sistema([' + '; '.join( repr (e) for e in self ) + pc + '])'

\end{minted}


\begin{itemize}
\item La representación \texttt{latex} (\LaTeX{}) es similar a la primera
representación (\texttt{str}), pues también muestra barras
verticales que separan la lista de elementos en sub-listas si el
atributo \texttt{.corteSistema} así lo indica. La única diferencia es que los
elementos aparecen con su representación \texttt{latex} (cuando la
tienen).

Es la representación que los Notebooks de Jupyter emplean por
defecto (y también es usada por Emacs (Scimax) mediante los dos
últimos métodos que aparecen más abajo).

Llamamos a la representación \texttt{latex} con los métodos \texttt{display()} y
\texttt{pinta()}.
\end{itemize}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def latex(self):
    """ Construye el comando LaTeX para representar un Sistema """
    if not self:
        return r'\left[\ \right]'
    else:
        pc = ';' if len(self) else r'\ '
        ln = [len(i) for i in particion(self.corteSistema, len(self))]
        return \
            r'\left[ \begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
            r';& '.join([latex(e) for e in self]) + pc + \
            r'\end{array} \right]'

\end{minted}


\begin{itemize}
\item Jupyter llama al método \texttt{\_\_repr\_html\_\_} (que a su vez llama al
método general \texttt{html} (véase \ref{sec:orgf634e5f}) para mostrar la representación \texttt{latex} de los
objetos en el navegador.
\end{itemize}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
def _repr_html_(self):
    """ Construye la representación para el entorno jupyter notebook """
    return html(self.latex())

\end{minted}

\begin{itemize}
\item Es posible trabajar con los Jupyter Notebooks dentro de \href{https://www.gnu.org/software/emacs/}{Emacs} con la
configuración \href{https://github.com/jkitchin/scimax}{Scimax}. Para poder visualizar la representación
\LaTeX{} dentro del editor, es necesario generar las imágenes en
ficheros auxiliares \texttt{png}. Para ello, definimos un par de
representaciones adicionales usadas en los Notebooks con Emacs.
\end{itemize}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
def _repr_latex_(self):
    """ Representación para el entorno jupyter en Emacs """
    return '$'+self.latex()+'$'

def _repr_png_(self):
    """ Representación png para el entorno jupyter en Emacs """
    try:
        expr = '$'+self.latex()+'$'
        workdir = tempfile.mkdtemp()
        with open(join(workdir, 'borrame.png'), 'wb') as outputfile:
            sympy.preview(expr, viewer='BytesIO', outputbuffer=outputfile)
        return open(join(workdir, 'borrame.png'),'rb').read()
    except:
        return '$'+self.latex()+'$'
                                                               
\end{minted}

\subsubsection{Método para establecer los índices donde poner marcas de corte de un Sistema}
\label{sec:org204f3e9}

Para separar visualmente distintas partes de un sistema es necesario
indicar los índices de los componentes tras lo que se mostrará una
barra vertical. Para especificar dichos índices se llama al método
\texttt{csis()} (que usaremos para visualmente \emph{cortar un sistema}, por
ejemplo para separar visualmente las columnas de una matriz).

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def csis(self, conjuntoIndices={}):
    """Modifica el atributo corteSistema para insertar lineas entre
    determinados elementos del sistema

    """
    self.corteSistema = set(conjuntoIndices) if conjuntoIndices else {0}
    return self

\end{minted}

\subsection{Ejemplo de representación de un \texttt{Sistema}}
\label{sec:org2bf76b8}
Veamos la representación \texttt{str} de un sistema \texttt{A} con tres elementos:

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
A = Sistema([ 2, fracc(a,b), sympy.sqrt(5), ])
print( A )
\end{minted}

\texttt{[2; a/b; sqrt(5);]}

Si incluimos una separación visual detrás de la segunda componente de
\texttt{A} su representación \texttt{str} es:

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
A.csis({2})
print( A )
\end{minted}

\texttt{[2; a/b;|sqrt(5);]}

Sin embargo, la representación \texttt{repr} no muestra la barra vertical de
separación:

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
repr( A )
\end{minted}

\texttt{Sistema([2; a/b; sqrt(5);])}

La barra vertical de separación visual sí se muestra en la
representación \texttt{latex} (es la representación empleada por defecto en
los Notebooks de Jupyter y en el material del curso de Álgebra
Lineal):

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
pinta(A)
\end{minted}

\(\displaystyle \left[ \begin{array}{cc|c}2;& \frac{a}{b};& \sqrt{5};\end{array} \right]\)

\subsection{Ejemplo de representación con un \texttt{Sistema} más complejo}
\label{sec:orgc59e4c7}
Únicamente cuando un \texttt{Sistema} tiene una estructura muy sencilla las
tres formas de representación de \texttt{Sistemas} son prácticas. Por
ejemplo, la representación \texttt{str} se ve mal cuando el sistema contiene
objetos que son complicados de representar (por ejemplo matrices
dentro de otros sistemas). Por otra parte, aunque la representación
\texttt{repr} indica claramente cuál es el tipo de cada objeto, es difícil
ver qué contiene cada uno de los objetos. La representación \texttt{latex}
es, con diferencia, la más fácil de interpretar de un simple vistazo.

En el siguiente ejemplo, con \texttt{.csis(\{1\})} indicamos que el primer
elemento del sistema debe estar visualmente separado del resto.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
a,b,c = sympy.symbols('a b c')
vv = Vector([1,2,3])
Z = Sistema( [ Vector([6,8,10],rpr='h').csis({2}), vv , 1492] ) 
ZZ = Sistema([ Z, 'Hola', Matrix([Vector([0,sympy.pi,fracc(a,2)]),Vector([0,0,0])])  ]).csis({1})
print(ZZ)
repr(ZZ)
ZZ
\end{minted}

\texttt{[[(6, 8,|10,); (1, 2, 3,); 1492;];|Hola; |  0   0|\textbackslash{}n| pi   0|\textbackslash{}n|a/2   0|;]}

\texttt{Sistema([Sistema([Vector([6, 8, 10]); Vector([1, 2, 3]); 1492;]); 'Hola'; Matrix([Vector([0, pi, a/2]), Vector([0, 0, 0])]);])}

\(\displaystyle \left[ \begin{array}{c|cc}\left[ \begin{array}{ccc}\left( \begin{array}{c}6\\8\\ \hline 10\\ \end{array} \right);& \left( \begin{array}{c}1\\2\\3\\ \end{array} \right);& 1492;\end{array} \right];& \mathtt{\text{Hola}};& \left[ \begin{array}{cc}0&0\\\pi&0\\\frac{a}{2}&0\\ \end{array} \right];\end{array} \right]\)


\clearpage

\section{La clase \texttt{Sistema} completa}
\label{sec:orgfcf061f}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la clase Sistema]{python}
class Sistema:
    <<Texto de ayuda de la clase Sistema>>
    <<Inicialización de la clase Sistema>>
    <<Métodos de la clase Sistema para que actúe como si fuera una list de Python>>
    <<Método de la clase Sistema para concatenar dos sistemas>>
    <<Método que junta una lista de Sistemas en un único Sistema>>
    <<Método que amplía la lista de un Sistema con nuevos elementos>>
    <<Sustitución de variables simbólicas>>
    <<Simplificación de expresiones simbólicas en la lista de un Sistema>>
    <<Sustitución de un símbolo por otro símbolo o valor en un Sistema>>
    <<Otros métodos de la clase Sistema>>
    <<Métodos que devuelven SubEspacios>>
    <<Método de resolución de sistema de Ecuaciones lineales>>
    <<Operador selector por la derecha para la clase Sistema>>
    <<Operador selector por la izquierda para la clase Sistema>>
    <<Suma y diferencia de Sistemas>>
    <<Producto de un Sistema por un escalar a su izquierda>>
    <<Opuesto de un Sistema>>
    <<Producto de un Sistema por un escalar un Vector o una Matrix a su derecha>>
    <<Transformaciones elementales de los elementos de un Sistema>>
    <<Transformaciones elementales por la izquierda de un Sistema>>
    <<Reducción por eliminacion>>
    <<Eliminación>>
    <<formas escalonadas>>
    <<Métodos de representación de la clase Sistema>>
    
\end{minted}


\chapter{La subclase \texttt{BlockV}}
\label{sec:orgd1ab61b}

En el curso de Álgebra Lineal empleamos arreglos rectangulares de
objetos (principalmente las matrices). En NAcAL, la clase de los
arreglos rectangulares de objetos son los \texttt{BlockM} (``Block
Matrix''). Son \texttt{Sistemas} formados por una lista de \texttt{Sistemas} de la
misma longitud y que representamos verticalmente para formar las
columnas del arreglo rectangular.

En consecuencia, los elementos de un \texttt{BlockM} son \emph{sistemas con una
representación vertical}. Así pues, en este capítulo se define una
primera subclase de la clase \texttt{Sistema} cuya representación difiere de
la de los \texttt{Sistemas} genéricos. A estos subsistemas los denominamos
\texttt{BlockV}.

Por defecto, los \texttt{BlockV} tienen representación \texttt{latex} vertical
(opcionalmente podremos representarlos horizontalmente). Para
distinguirlos de los \texttt{Sistemas} genéricos, su lista de componentes
está encerrada entre paréntesis (en lugar de corchetes); y si se
representan horizontalmente, tras de cada elemento aparece una \emph{coma}
(\texttt{,}) en lugar de un \emph{punto y coma} (\texttt{;}). Así que para instanciar un
\texttt{BlockV}, además del argumento con la lista de elementos del sistema,
disponemos de un segundo argumento opcional (\texttt{rpr}) que indica si
queremos una representación vertical (por defecto es la que se usará
si no se indica nada) u horizontal. En todo lo demás, un \texttt{BlockV} es
como un \texttt{Sistema} genérico.

\section{Implementación}
\label{sec:org5dfac46}

\subsection{Texto de ayuda}
\label{sec:org8eec7c7}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la subclase BlockV]{python}
"""BlockV es un Sistema que se puede representar verticalmente.

Se puede instanciar con una lista, tupla o otro Sistema. Si al
instanciar un BlockV la lista, tupla o sistema solo contiene números
el objeto obtenido es un Vector (subclase de BlockV).

El atributo 'rpr' indica si la representación latex debe mostrar el
sistema en disposición vertical (por defecto) u horizontal.

Parámetros:
    sis   (list, tuple, Sistema): Lista, tupla o Sistema de objetos.
    rpr   (str): Para su representación latex (en vertical por defecto).
                  Si rpr='h' se representa en forma horizontal. 

Atributos de la subclase:
    rpr   (str): modo de representación en Jupyter.

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    corteSistema (set) : Conjunto de índices donde pintar
                                separaciones visuales

Ejemplos:
>>> # Instanciación a partir de una lista, tupla o Sistema de números
>>> BlockV( [1,'abc',(2,)] )            # con una lista
>>> BlockV( (1,'abc',(2,)) )            # con una tupla
>>> BlockV( Sistema( [1,'abc',(2,)] ) ) # con un Sistema
>>> BlockV( BlockV ( [1,'abc',(2,)] ) ) # a partir de otro BlockV

BlockV( [1,'abc',(2,)] )

>>> BlockV( [1,2,3)] )                  # con una lista de números

Vector( [1,2,3] )
"""
\end{minted}

\subsection{Método de inicialización:}
\label{sec:org0623b77}

\texttt{BlockV} es una subclase \texttt{Sistema}. Se inicia con el método: \texttt{def
\_\_init\_\_(self, arg, rpr='columna')}.

\begin{itemize}
\item La clase \texttt{BlockV} se instancia con dos argumentos. 

\begin{enumerate}
\item \texttt{arg} es obligatorio y debe ser una lista, tupla o \texttt{Sistema}.

\item \texttt{rpr} es opcional e indica si queremos que la representación
\texttt{latex} sea en forma horizontal o en vertical. Por defecto la
representación es vertical. Para una disposición horizontal \texttt{rpr}
de ser la cadena de caracteres \texttt{h}, es decir, \texttt{rpr='h'}.
\end{enumerate}

\item Con \texttt{super().\_\_init\_\_(arg)} la subclase \texttt{BlockV} hereda los métodos
y atributos de la clase \texttt{Sistema}. En consecuencia \texttt{BlockV} tendrá
los atributos \texttt{lista}, \texttt{n} y \texttt{corteSistema} así como todos los
métodos definidos para la clase \texttt{Sistema}.

\item El atributo \texttt{rpr} tomará el valor indicado al instanciar la clase
(\texttt{'columna'} por defecto). Y el atributo \texttt{n} será igual al número de
elementos del sistema (su longitud).

\item Por último, un \texttt{BlockV} cuya lista tan solo contiene números es un
vector de \R[n].

Consecuentemente, cuando todos los elementos de \texttt{arg} son \hyperref[sec:org32459c1]{números}
(Véase la Sección \ref{sec:org32459c1}) el objeto que se crea es un \texttt{Vector} (una
subclase de \texttt{BlockV} que solo contiene números).
\end{itemize}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la subclase BlockV]{python}

def __init__(self, arg, rpr='columna'):
    """Inicializa un BlockV con una lista, tupla o Sistema"""
    super().__init__(arg)
    self.rpr  =  rpr
    self.n  = len(self)
    
    if all( [es_numero(e) for e in arg] ): self.__class__ = Vector

\end{minted}

\section{Representación de la clase \texttt{BlockV}}
\label{sec:org24783cb}
Un \texttt{BlockV} es una secuencia finita de objetos; es decir, un
\texttt{Sistema}.  La única diferencia respecto de un \texttt{Sistema} genérico es
su representación. Por tanto solo necesitamos redefinir las
representaciones \texttt{str}, \texttt{repr} y \texttt{latex} de esta subclase particular
de \texttt{Sistema}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __repr__(self):
    """ Muestra el BlockV en su representación Python """
    return 'BlockV(' + repr(self.lista) + ')'
                           
def __str__(self):
    """ Muestra el BlockV en su representación Python """
    pc = ',' if len(self.lista) else ''
    ln = [len(n) for n in particion(self.corteSistema,self.n)]
    return '(' + \
        ',|'.join([', '.join([str(c) for c in s]) \
                   for s in [ self|i for i in particion(self.corteSistema, self.n)]]) + \
        pc + ')'

def latex(self):
    """ Construye el comando LaTeX para representar un BlockV """
    if bool(self.corteSistema):
        pc = ',' if len(self) else r'\ '
        ln = [len(n) for n in particion(self.corteSistema,self.n)]
        if self.rpr == 'h' or self.n==1:    
            return \
                r'\left( \begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
                r',& '.join([latex(e) for e in self]) + pc + \
                r'\\ \end{array} \right)'
        else:
            return \
                r'\left( \begin{array}{c}' + \
                r'\\ \hline '.join([r'\\'.join([latex(c) for c in e]) \
                    for e in [ self|i for i in particion(self.corteSistema, self.n)]]) + \
                r'\\ \end{array} \right)'
    else:
        if not self:
            return r'\left(\ \right)'

        if self.rpr == 'h' or self.n==1:
            return r'\begin{pmatrix}' + \
                ',& '.join([latex(e) for e in self]) + \
                r',\end{pmatrix}'
        else:
            return r'\begin{pmatrix}' + \
                r'\\ '.join([latex(e) for e in self]) + \
                r'\end{pmatrix}'

\end{minted}

\subsection{Ejemplo de representación de un \texttt{BlockV}}
\label{sec:org7a2fe9f}
Veamos la representación de un \texttt{BlockM} cuya lista contiene una matriz
dos por tres y tres números.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
BV = BlockV([Matrix([[1,2,3],[4,5,6]]), 1,0,0])
\end{minted}

La representación \texttt{str} es no es práctica en este caso, pues su
elemento \texttt{Matrix} necesita de un salto de línea, por lo que la
visualización algo deficiente:
\texttt{(|1 2 3|\textbackslash{}n|4 5 6|, 1, 0, 0,)}

La representación \texttt{repr} es mejor, pero resulta difícil leer 
qué objetos son elementos de otros:
\texttt{BlockV([Matrix([Vector([1, 4]), Vector([2, 5]), Vector([3, 6])]), 1, 0, 0])}

La representación \texttt{latex} es la mejor:
\(\displaystyle \left( \begin{array}{c}\left[ \begin{array}{ccc}1&2&3\\4&5&6\\ \end{array} \right]\\1\\0\\0\\ \end{array} \right)\)

y también la podemos usar en horizontal:
\(\displaystyle \left( \begin{array}{cccc}\left[ \begin{array}{ccc}1&2&3\\4&5&6\\ \end{array} \right],& 1,& 0,& 0,\\ \end{array} \right)\)

\section{La clase \texttt{BlockV} completa}
\label{sec:org9aecd84}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la subclase BlockV]{python}
class BlockV(Sistema):
    <<Texto de ayuda de la subclase BlockV>>
    <<Inicialización de la subclase BlockV>>
    <<Métodos de representación de la subclase BlockV>>
\end{minted}


\chapter{La subclase \texttt{Vector}}
\label{sec:org9550999}

El \href{https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf\#section.1.1}{curso} de Álgebra Lineal define un vector de \R[n] del siguiente
modo
\begin{center}
  Un \emph{vector} de \R[n] es un \emph{sistema} de $n$ números reales;
\end{center}
y se indica que los vectores se representan entre paréntesis tanto
horizontal como verticalmente. Por tanto hay que redefinir la
representación de la clase \texttt{Vector} para que los \texttt{Vectores} no sean
representados como \texttt{Sistemas} genéricos, sino a la manera de los
vectores.

Pero esto ya se hace en el capítulo anterior con los \texttt{BlockV}. Como un
\texttt{Vector} es un \texttt{BlockV} que solo contiene números, lo más sencillo es
definir la clase \texttt{Vector} como una subclase \texttt{BlockV} que solo contiene
números. Así solo necesitamos redefinir la representación \texttt{repr} para
que indique específicamente que se trata de un \texttt{Vector}, ya que la
subclase \texttt{Vector} hereda el resto de métodos y atributos de la clase
\texttt{Sistema} y la subclase \texttt{BlockV}.

\section{Implementación de los vectores de \R[n] en la subclase \texttt{Vector}}
\label{sec:org032fc96}

\subsection{Texto de ayuda}
\label{sec:org79523ca}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la subclase Vector]{python}
"""Clase para los Sistemas de números.

Sólo se puede instanciar con una lista, tupla o Sistema de objetos
int, float o sympy.Basic. Si se instancia con un Vector se crea una
copia del mismo.

El atributo 'rpr' indica si, en la representación latex, el vector
debe ser escrito en vertical (por defecto) o en horizontal.

Parámetros:
    sis (list, tuple, Sistema): Lista, tupla o Sistema de objetos
        de tipo int, float o sympy.Basic.
    rpr (str): Para su representación latex (en vertical por defecto).
        Si rpr='h' el vector se representa en horizontal. 

Atributos heredados de la subclase BlockV::
    rpr   (str)    : modo de representación en Jupyter.

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    corteSistema (set) : Conjunto de índices donde pintar
                                separaciones visuales

Ejemplos:
>>> # Instanciación a partir de una lista, tupla o Sistema de números
>>> Vector( [1,2,3] )           # con lista
>>> Vector( (1,2,3) )           # con tupla
>>> Vector( Sistema( [1,2,3] ) )# con Sistema
>>> Vector( Vector ( [1,2,3] ) )# a partir de otro Vector

Vector([1,2,3])
"""
\end{minted}

\subsection{Método de inicialización:}
\label{sec:org4f1524f}

La clase se inicia con el método: \texttt{def \_\_init\_\_(self, arg, rpr='columna')}.

\begin{itemize}
\item La clase \texttt{Vector} emplea dos argumentos. El primero (\texttt{arg}) es una
lista, tupla o \texttt{Sistema} de objetos tipo \texttt{int}, \texttt{float} o
\texttt{sympy.Basic}. Cuando \texttt{arg} es un \texttt{Vector} se obtiene una copia. El
segundo argumento (\texttt{rpr}) es opcional e indica si queremos que la
representación \texttt{latex} sea en forma horizontal o en vertical (Véase
la subclase \texttt{BlockV}).

\item Python mostrará el texto de ayuda sobre el método \texttt{\_\_init\_\_} con:
\texttt{help Vector.\_\_init\_\_}

\item Se verifica que \texttt{arg} es una secuencia de números (Sección
\ref{sec:org4573279}). Si no lo es obtenemos un error.

\item Con \texttt{super().\_\_init\_\_(arg)} la subclase \texttt{Vector} hereda los métodos
y atributos de la clase \texttt{BlockV} (por tanto, \texttt{Vector} tendrá un
atributo \texttt{lista}, así como el resto de atributos y todos los métodos
definidos para la clase \texttt{Sistema} y la subclase \texttt{BlockV}).
\end{itemize}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la subclase Vector]{python}

def __init__(self, arg, rpr='columna'):
    """Inicializa Vector con una lista, tupla o Sistema de números"""                       
    if not es_ristra_de_numeros(arg):
        raise ValueError('no todos los elementos son números o parámetros!')

    super().__init__(arg, rpr)

\end{minted}

\section{Métodos específicos de la subclase \texttt{Vector}}
\label{sec:orgde78ee8}

Aquí se definen algunos métodos específicos de la subclase
\texttt{Vector}. El primero calcula la norma euclídea de un \texttt{Vector} de
\R[n], es decir, la raíz cuadrada del producto punto del vector por si
mismo.

El segundo usa dicha norma para devolver un múltiplo con norma uno de
cualquier un vector no nulo.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Normalización de un Vector]{python}

def norma(self):
    """Devuelve la norma de un vector"""
    return sympy.sqrt(self*self)
                                                               
def normalizado(self):
    """Devuelve un múltiplo de norma uno si el vector no es nulo"""
    if self.es_nulo(): raise ValueError('Un vector nulo no se puede normalizar')
    return self * fracc(1,self.norma())

\end{minted}

El tercer método devuelve una \texttt{Matrix} diagonal cuya diagonal
principal es igual a \texttt{Vector}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Creación de una Matrix diagonal a partir de un Vector]{python}

def diag(self):
    """Crea una Matrix diagonal cuya diagonal es self"""
    return Matrix([a*(I(self.n)|j) for j,a in enumerate(self, 1)])

\end{minted}

\section{Representación de la clase \texttt{Vector}}
\label{sec:orgc8e8eda}

Necesitamos indicar a Python cómo representar los objetos de tipo
\texttt{Vector}.

Los vectores, son secuencias finitas de números que escribimos entre
paréntesis en horizontal
\begin{displaymath}
  \Vect{v}=(v_1,\ldots,v_n)
\end{displaymath}
o en vertical
\begin{displaymath}
  \Vect{v}=\begin{pmatrix}v_1\\ \vdots \\ v_n\end{pmatrix}.
\end{displaymath}

Esta forma de representación ya se ha establecido para la subclase
\texttt{BlockV}, por lo que no es necesario volver a programarla. Tan solo
re-especificamos la representación de tipo \texttt{repr} para que
explícitamente indique que el objeto es un \texttt{Vector}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación de la subclase Vector]{python}

def __repr__(self):
    """ Muestra el vector en su representación Python repr """
    return 'Vector(' + repr(self.lista) + ')'

\end{minted}
\section{La clase \texttt{Vector} completa}
\label{sec:org835e0a6}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la subclase Vector]{python}
class Vector(BlockV):
    <<Texto de ayuda de la subclase Vector>>
    <<Inicialización de la subclase Vector>>
    <<Normalización de un Vector>>
    <<Creación de una Matrix diagonal a partir de un Vector>>
    <<Métodos de representación de la subclase Vector>>
\end{minted}


\chapter{Las subclases \texttt{V0} y \texttt{V1}}
\label{sec:org5cc00c5}

La clase \texttt{V0} corresponde a vectores nulos. La clase \texttt{V1} corresponde
a vectores constantes cuyas componentes son todas iguales a 1. En
ambos casos se instancian con un parámetro que indica el número de
componentes y, opcionalmente, el parámetro \texttt{rpr} para indicar si la
representación \texttt{latex} es en forma horizontal (\texttt{'h'}) o vertical.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de las subclases V0 y V1]{python}

class V0(Vector):
    """Clase para los Vectores nulos"""
    def __init__(self, n, rpr = 'columna'):
        """Inicializa un vector nulo de n componentes

        V0 se inicializa con

        1) un entero que indica el  número de componentes nulas
    
        2) la cadena de texto rpr. Si rpr = 'h' la representación
        es horizontal (en otro caso es vertical)

        """
        super().__init__([0]*n, rpr)
        self.__class__ = Vector

class V1(Vector):
    """Clase para los Vectores constantes 1"""
    def __init__(self, n, rpr = 'columna'):
        """Inicializa un vector uno de n componentes

        V1 se inicializa con

        1) un entero que indica el  número de componentes nulas
    
        2) la cadena de texto rpr. Si rpr = 'h' la representación
        es horizontal (en otro caso es vertical)

        """
        super().__init__([1]*n, rpr)
        self.__class__ = Vector

\end{minted}


\chapter{La subclase \texttt{BlockM}}
\label{sec:org8c9a9e4}

Un \texttt{BlockM} es un sistema de \texttt{BlockVs} de la misma longitud, es decir,
es un arreglo rectangular de objetos. A sus elementos los llamaremos
\emph{columnas} del \texttt{BlockM}.

\section{Implementación}
\label{sec:org3073033}
\subsection{Texto de ayuda}
\label{sec:orge8c33ce}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la clase BlockM]{python}
"""Clase para arreglos rectangulares de objetos.

Sistema formado por BlockVs con el mismo número de componentes. Se
instancia con: 1) una lista, tupla o Sistema de BlockVs (serán sus
columnas); 2) una lista, tupla o Sistema de listas, tuplas o Sistemas
con la misma longitud (serán sus filas); 3) otro BlockM (se obtendrá
una copia).

Parámetros:
    arg (list, tuple, Sistema): Lista, tupla o Sistema de BlockVs
        (con identica longitud); o de listas, tuplas o Sistemas (con
        identica longitud).

Atributos:
    m              (int) : número de filas
    corteElementos (set) : Conjunto de índices donde pintar
                            separaciones visuales entre filas

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    corteSistema (set) : Conjunto de índices donde pintar
                                separaciones visuales

Ejemplos:
>>> # Crear un BlockM a partir de una lista de Vectores o BlockVs:
>>> a = BlockV( ['Hola',2,3] ); b = Vector( [1,2,5] ); c = Vector( [1,2,7] )
>>> BlockM( [a,b,c] )

BlockM([BlockV(['Hola', 2, 3]), Vector([1, 2, 5]), Vector([1, 2, 7])])
>>> # Crear una BlockM a partir de una lista de listas, tuplas o Sistemas
>>> A = BlockM([('Hola',1,1),[2,2,2],Vector([3,5,7])])

BlockM([BlockV(['Hola', 2, 3]), Vector([1, 2, 5]), Vector([1, 2, 7])])

"""
\end{minted}

\subsection{Método de inicialización:}
\label{sec:org5eb7216}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la subclase BlockM]{python}

def __init__(self, arg):
    """Inicializa un BlockM con una

    1) lista, tupla o Sistema de BlockVs con el mismo número de
    elementos,
    
    2) tupla, lista o Sistema de tuplas, listas o Sistemas con el
    mismo número de elementos,
    
    3) con otra BlockM.

    """    
    listaInicial = Sistema(arg).lista.copy()

    if isinstance(arg, BlockM):
        lista = arg.lista.copy()
        
    elif all([(isinstance(elemento, BlockV) and len(elemento)==len(listaInicial[0])) for elemento in listaInicial]):
        lista = listaInicial.copy()

    elif listaInicial and not listaInicial[0]:
        lista = [BlockV([])]

    elif all([(es_ristra(elemento) and len(elemento)==len(listaInicial[0])) for elemento in listaInicial]):
        lista = BlockM([ BlockV([ elemento[i] for elemento in listaInicial ]) for i in range(len(listaInicial[0])) ]).lista

    else: 
        raise ValueError("""El argumento debe ser una lista de
        BlockVs o una lista, tupla o Sistema de listas, tuplas o
        sistemas con el mismo número de elementos!""")

    listaFinal = [BlockV( elemento, rpr = 'columna' )  for elemento in lista]

    super().__init__(listaFinal)

    try: 
        self.m  = (self|1).n
    except:
        self.m  = 0
            
    self.corteElementos = set()
           
    if all( [isinstance(e, Vector) for e in self] ): self.__class__ = Matrix
    
\end{minted}

\section{Métodos de la clase \texttt{BlockM}}
\label{sec:orgbbdaa52}
\subsection{Transposición de un BlockM}
\label{sec:org5c00629}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Operador transposición]{python}

def __invert__(self):
    """
    Devuelve la traspuesta de un BlockM.
    
    Ejemplo:
    >>> ~BlockM([ [1,2,3], [2,4,6] ])
    
    Matrix([ Vector([1, 2, 3]), Vector([2, 4, 6]) ])
    """
    M = BlockM([ Sistema(columna) for columna in self ])
    M.corteElementos, M.corteSistema = self.corteSistema, self.corteElementos
    return M

\end{minted}

\subsection{Comprobación de que las filas o columnas son de composición homogenea}
\label{sec:org94ac88f}

Si queremos aplicar transformaciones elementales a las columnas o a
las filas de un \texttt{BlockM} es necesario que las operaciones entre
componentes tengan sentido. Los siguientes dos métodos nos indican si
es posible realizar dichas operaciones por columnas (si éstas son
homogéneas) o por filas.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Comprobación de que las filas o columnas son de composición homogenea]{python}

def columnas_homogeneas(self):
    """Indica si las columnas contienen objetos del mismo tipo y longitud"""
    return self.es_de_composicion_y_longitud_uniforme()

def filas_homogeneas(self):
    """Indica si las filas contienen objetos del mismo tipo y longitud"""
    return (~self).es_de_composicion_y_longitud_uniforme()

\end{minted}

\subsection{Apilado de \texttt{BlockMs}}
\label{sec:org18a40b2}

Creamos un \texttt{BlockM} apilando \texttt{BlockMs} uno encima de otro si tienen el
mismo número de elementos.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Apila una lista de Sistemas con el mismo número de elementos un BlockM]{python}

def apila(self, lista, marcasVisuales = False):
    """Apila una lista o tupla de BlockMs con el mismo número de elementos
    (columnas) en un BlockM concatenando los respectivos elementos

    """
    apila_dos = lambda x, other, marcasVisuales=False: ~((~x).concatena(~other, marcasVisuales))
    apila = lambda x: x[0] if len(x)==1 else apila_dos( apila(x[0:-1]), x[-1], marcasVisuales)
    return apila([self] + [s for s in CreaLista(lista)])

\end{minted}

\subsection{Operador selector por la izquierda}
\label{sec:orga8bb8c3}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para el operador selector por la izquierda para la clase BlockM]{python}
"""Extrae la j-ésima fila de un BlockM en forma de BlockV; o crea un
BlockM cuyas filas corresponden a las filas indicadas en una tupla o
lista de índices (los índices comienzan por el número 1)

Parámetros:
    j (int, list, tuple, slice): Índice (o lista de índices) del 
          elementos (o elementos) a seleccionar

Resultado:
          ?: Si j es int, devuelve la j-ésima fila del BlockM.
    Sistema: Si j es list, tuple o slice devuelve el BlockM cuyas
          filas son las filas indicadas en la lista, tupla o slice de
          índices.

Ejemplos:
>>> # Extrae la j-ésima fila del BlockM 
>>> 1 | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]])

BlockV(['Hola', 2, 3])
>>> # Sistema formado por los elementos indicados en la lista (o tupla)
>>> [2,1] | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]])
>>> (2,1) | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]])

BlockM([BlockV([1, 'Hola']), Vector([2, 2]), Vector([5, 3])])

>>> # Sistema formado por los elementos indicados en el slice
>>> slice(1,3,2) | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]]

BlockM([BlockV(['Hola', 1]), Vector([2, 2]), Vector([3, 7])])

"""
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Operador selector por la izquierda para la clase BlockM]{python}

def __ror__(self,i):
    <<Texto de ayuda para el operador selector por la izquierda para la clase BlockM>>
    if isinstance(i,int):
        return  BlockV( (~self)|i , rpr='h' )

    elif isinstance(i, (list,tuple,slice)):        
        return ~BlockM( (~self)|i ) 
        
\end{minted}

\section{Otros métodos de la clase \texttt{BlockM}}
\label{sec:org53bcc2d}
\subsection{Extiende una \texttt{BlockM} a lo largo de la diagonal con una lista de \texttt{BlockMs}}
\label{sec:org73953a0}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Extiende una BlockM a lo largo de la diagonal con una lista de BlockMs]{python}
   
def extDiag(self, lista, c=False):
    "Extiende una BlockM a lo largo de la diagonal con una lista de BlockMs"
    lista = CreaLista(lista)
    if not all(isinstance(elemento, BlockM) for elemento in lista): 
        return ValueError('No es una lista de BlockMs')
    Ext_dos = lambda x, y: x.apila(M0(y.m,x.n),c).concatena(M0(x.m,y.n).apila(y,c),c)
    ExtDiag = lambda x: x[0] if len(x)==1 else Ext_dos( ExtDiag(x[0:-1]), x[-1] )
    return ExtDiag([self]+lista)

\end{minted}

\subsection{Vectoriza un \texttt{BlockM} apilando sus elementos para formar un \texttt{BlockV}}
\label{sec:org806ddc4}
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Vectoriza un BlockM apilando sus elementos para formar un BlockV]{python}
   
def vec(self):
    "Vectoriza un BlockM apilando sus elementos para formar un BlockV"
    return BlockV(Sistema([]).junta(self))

\end{minted}

\section{Transformaciones elementales de las filas de un \texttt{BlockM}}
\label{sec:orgb56aebe}

\subsection{Texto de ayuda}
\label{sec:org5a31f2b}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de las transformaciones elementales de un BlockM]{python}
"""Transforma las filas de un BlockM

Atributos:
    operaciones (T): transformaciones a aplicar sobre las filas
                     de un BlockM A
Ejemplos:
>>>  T({1,3})   & A               # Intercambia las filas 1 y 3
>>>  T((5,1))   & A               # Multiplica por 5 la fila 1
>>>  T((5,2,1)) & A               # Suma 5 veces la fila 2 a la fila 1
>>>  T([(5,2,1),(5,1),{1,3}]) & A # Aplica la secuencia de transformac.
            # sobre las filas de A y en el orden inverso al de la lista

"""
\end{minted}

\subsection{Implementación de las transformaciones elementales de las filas}
\label{sec:org23ddc74}

Para implementar las transformaciones elementales de las filas usamos
el truco de aplicar las operaciones sobre las columnas de la
transpuesta y de nuevo transponer el resultado: \texttt{\textasciitilde{}(\textasciitilde{}self \& t)}.  Pero
hay que recordar que las transformaciones más próximas a la matriz se
ejecutan antes y que
\begin{math}
  \;\SITEF{1}{k}{\Mat{A}}=
  \TransP*{\Transp*{\SITEF{1}{k}{\Mat{A}}}}=
  \TransP*{\TrC[\Transp*{\SOEg[1][k]}]{\MatTpE*{A}}}=
  \TransP*{\TrC[\SOEg[k][1]]{\MatTpE*{A}}}.
\end{math}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Transformaciones elementales de las filas de un BlockM]{python}

def __rand__(self, operaciones):
    <<Texto de ayuda de las transformaciones elementales de un BlockM>>
    for item in reversed(operaciones.abreviaturas):
        if isinstance(item, (set, tuple) ):
            self.lista = (~(~self & T(item))).lista.copy()
    
        elif isinstance(item, list):
            for k in item:          
                ~T(k) & self
    
    return self 

\end{minted}

\section{Representación de la clase BlockM}
\label{sec:orgdf6709f}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método de representación repr de la subclase BlockM]{python}

def __repr__(self):
    """ Muestra un BlockM en su representación Python repr """
    return 'BlockM(' + repr(self.lista) + ')'
                           
\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación str y LaTeX de las subclases Matrix y BlockM]{python}

def __str__(self):
    """ Muestra un BlockM en su representación Python str """
    ln  = [len(n) for n in particion(self.corteSistema,self.n)]
    car = max([len(str(e)) for c in self for e in c])

    def escribeFila(f,d=0):
        parte = lambda f,d=0: str(' '.join([str(e).rjust(d) for e in f])) 
        s = '|'+'|'.join([parte([e for e in c],d) for c in [p|f for p in particion(self.corteSistema, self.n)] ])+'|'
        return s
    
    num_guiones = len(escribeFila(1|self, car))
    s = ('\n'+ '-'*(num_guiones) + '\n').join(['\n'.join([escribeFila(f,car) for f in ~s]) \
                                               for s in [i|self for i in particion(self.corteElementos, self.m)]])
    return s

def latex(self):
    """ Construye el comando LaTeX para representar una BlockM """
    if not self.m:
            return self.sis().latex()

    ln = [len(n) for n in particion(self.corteSistema, self.n)]                                                           
    return \
        '\\left[ \\begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
        '\\\\ \\hline '.join(['\\\\'.join(['&'.join([latex(e) for e in f.lista]) \
                                           for f in (~M).lista]) \
           for M in [ i|self for i in particion(self.corteElementos,self.m)]]) + \
         '\\\\ \\end{array} \\right]'
        
\end{minted}

\subsubsection{Método para definir por puntos de corte en los elementos un BlockM (sus ``filas'')}
\label{sec:org252ee5a}

Para separar visualmente los elementos de los componentes (de los
\texttt{BlockV} o columnas) de un \texttt{BlockM} es necesario indicar los índices
de los puntos de corte de sus elementos (tras los que se mostrará una
línea horizontal). Para especificar dichos índices se llama al método
\texttt{cele()} (pues lo usaremos para visualmente separar algunos elementos
en todos los componentes (es decir, en todos los \texttt{BlockV} o columnas)
del \texttt{BlockM} (por ejemplo para \emph{cortar por filas} una matriz).

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método para definir por puntos de corte en los elementos un BlockM]{python}

def cele(self, conjuntoIndices={}):
    """Modifica el atributo .corteElementos para insertar lineas
    horizontales entre las filas del BlockM

    """
    self.corteElementos = set(conjuntoIndices) if conjuntoIndices else {0}
    return self

\end{minted}


\clearpage

\section{La clase \texttt{BlockM} completa}
\label{sec:org98afd46}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la subclase BlockM]{python}
class BlockM(Sistema):
    <<Texto de ayuda de la clase BlockM>>
    <<Inicialización de la subclase BlockM>>
    <<Operador transposición>>
    <<Comprobación de que las filas o columnas son de composición homogenea>>
    <<Apila una lista de Sistemas con el mismo número de elementos un BlockM>>
    <<Operador selector por la izquierda para la clase BlockM>>
    <<Vectoriza un BlockM apilando sus elementos para formar un BlockV>>
    <<Transformaciones elementales de las filas de un BlockM>>
    <<Método para definir por puntos de corte en los elementos un BlockM>>
    <<Extiende una BlockM a lo largo de la diagonal con una lista de BlockMs>>
    <<Método de representación repr de la subclase BlockM>>
    <<Métodos de representación str y LaTeX de las subclases Matrix y BlockM>>
\end{minted}


\chapter{La subclase \texttt{Matrix}}
\label{sec:org1d53da2}

\section{Implementación de las matrices en la subclase \texttt{Matrix}}
\label{sec:org11c136b}

\subsection{Texto de ayuda}
\label{sec:orgfe9b858}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la clase Matrix]{python}
"""Matrix un Sistema de Vectores con el mismo número de componentes.

Una Matrix se puede instanciar con:

 1. una lista, tupla o Sistema de Vectores con el mismo número de
    componentes o longitud (serán las columnas).
 2. una lista, tupla o Sistema de listas, tuplas o Sistemas de núemros
    con la misma longitud (serán las filas de la matriz).

Parámetros:
    arg (list, tuple, Sistema): Lista, tupla o Sistema de Vectores con
        mismo núm. de componentes (sus columnas); o de listas, tuplas
        o Sistemas de números de misma longitud (sus filas).

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    corteSistema (set) : Conjunto de índices donde pintar
                                separaciones visuales

Atributos heredados de la subclase BlockM:
    m              (int) : número de filas
    corteElementos (set) : Conjunto de índices donde pintar
                            separaciones visuales entre filas

Ejemplos:
>>> # Crear una Matrix a partir de una lista de Vectores:
>>> a = Vector( [1,2] ); b = Vector( [1,0] ); c = Vector( [9,2] )
>>> Matrix( [a,b,c] )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crear una Matrix a partir de una lista de listas de números
>>> A = Matrix( [ [1,1,9], [2,0,2] ] )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crea una Matrix a partir de otra Matrix
>>> Matrix( A )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])

"""
\end{minted}

\subsection{Método de inicialización:}
\label{sec:org82663d0}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la subclase Matrix]{python}

def __init__(self, data):
    """Inicializa una Matrix con una

    1) lista, tupla o Sistema de Vectores con el mismo número de
    elementos,
    
    2) tupla, lista o Sistema de tuplas, listas o Sistemas de números
    con el mismo número de elementos,
    
    3) con otra Matrix.

    """

    super().__init__(data)
    
    lista = Sistema(data).lista

    if all([(isinstance(elemento, Vector) and len(elemento)==len(lista[0])) for elemento in lista]):
        self.lista   = lista.copy()

    elif lista and not lista[0]:
        lista = [Vector([])]
        
    elif Sistema(lista).es_de_composicion_y_longitud_uniforme() and es_ristra(lista[0]) and es_numero(lista[0][0]):
        self.lista = Matrix([ Vector([elemento[i] for elemento in lista]) for i in range(len(lista[0])) ]).lista

    elif isinstance(data,Matrix):
        self.lista   = data.lista.copy()

    else: 
        raise ValueError("""El argumento debe ser una lista de Vectores o una lista de listas o
        tuplas con el mismo número de elementos!""")
    
    super().__init__(data)

    for v in self.lista:
        v.rpr='columna'
        
\end{minted}

\section{Métodos específicos de la subclase \texttt{Matrix}}
\label{sec:org77d577f}
\subsection{Disposición de los elementos de una \texttt{Matrix}}
\label{sec:orgd4ae643}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Información sobre la disposición de los elementos de una Matrix]{python}

def es_cuadrada(self):
    """Indica si es cierto que la Matrix es cuadrada"""
    return self.m==self.n
    
def es_simetrica(self):
    """Indica si es cierto que la Matrix es simétrica"""
    return self == ~self
    
def es_triangularSup(self):
    """Indica si es cierto que la Matrix es triangular superior"""
    return not any(sum([[i|self|j for i in range(j+1,self.m+1)]      \
                                  for j in range(1  ,self.n+1)], []))
    
def es_triangularInf(self):
    """Indica si es cierto que la Matrix es triangular inferior"""
    return (~self).es_triangularSup()
    
def es_triangular(self):
    """Indica si es cierto que la Matrix es triangular inferior"""
    return self.es_triangularSup() | self.es_triangularInf()
    
def es_diagonal(self):
    """Indica si es cierto que la Matrix es diagonal"""
    return self.es_triangularSup() & self.es_triangularInf()

\end{minted}

\subsection{Creación de un \texttt{Vector} a partir de la diagonal de una \texttt{Matrix}}
\label{sec:org67b3bcb}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Creación de un Vector a partir de la diagonal de una Matrix]{python}

def diag(self):
    """Crea un Vector a partir de la diagonal de la Matriz"""
    return Vector([ (j|self|j) for j in range(1,min(self.m,self.n)+1)])

\end{minted}

\subsection{Normalizado de las columnas (o filas) de una matriz}
\label{sec:org3862061}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Normalizado de las columnas o filas de una matriz]{python}

def normalizada(self, opcion='Columnas'):
    if opcion == 'Columnas':
        if any( vector.es_nulo() for vector in self):
            raise ValueError('algún vector es nulo')
        return Matrix([ vector.normalizado() for vector in self])
    else:
        return ~(~self.normalizada())
        
\end{minted}

\subsection{Potencias de una \texttt{Matrix} cuadrada}
\label{sec:orgf210065}
Ahora podemos calcular la \texttt{n}-ésima potencia de una \texttt{Matrix}.
Cuando \texttt{n} es un entero positivo; basta multiplicar la \texttt{Matrix}
por si misma \texttt{n} veces.

Si \texttt{n} es un entero negativo, entonces necesitamos calcular la inversa
de la \texttt{n}-ésima potencia; para ello usará el método de
eliminación Gaussiano que se describirá en el
Capítulo\textasciitilde{}\ref{part:Algoritmos}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Potencia de una Matrix]{python}

def __pow__(self,n):
    """Calcula la n-ésima potencia de una Matrix"""
    if not isinstance(n,int): raise ValueError('La potencia no es un entero')
    if not self.es_cuadrada:  raise ValueError('Matrix no es cuadrada')

    M = self if n else I(self.n)
    for i in range(1,abs(n)):
    	M = M * self

    return M.inversa() if n < 0 else M

\end{minted}

\subsection{Determinante mediante la expansión de Laplace}
\label{sec:org83bfb88}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Determinante mediante la expansión de Laplace]{python}

def det(self, sust=[]):
    """Calculo del determinate mediante la expansión de Laplace"""
    if not self.es_cuadrada(): raise ValueError('Matrix no cuadrada')
                                                               
    def cof(self,f,c):
        """Cofactor de la fila f y columna c"""
        excl = lambda k: tuple(i for i in range(1,self.m+1) if i!=k)
        return (-1)**(f+c)*(excl(f)|self|excl(c)).det()
                                                               
    if self.m == 1:
        return 1|self|1

    A = Matrix(self.subs(sust))
    # expansión por la 1ª columna 
    return sympy.simplify(sum([((f|A|1)*cof(A,f,1)).subs(sust) for f in range(1,A.m+1)])) 
                                                                                                                              
\end{minted}

\subsection{Método de Gram-Schmidt}
\label{sec:orgd6f75f0}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método Gram-Schmidt para ortogonalizar un sistema de Vectores de Rn]{python}

def GS(self):
    """Devuelve una Matrix equivalente cuyas columnas son ortogonales

    Emplea el método de Gram-Schmidt"""
    A = Matrix(self)
    for n in range(2,A.n+1):
        A & T([ (-fracc((A|n)*(A|j),(A|j)*(A|j)), j, n) \
                for j in range(1,n) if (A|j).no_es_nulo() ])
    return A

\end{minted}

\subsection{Otros métodos específicos de las matrices cuadradas que usan eliminación}
\label{sec:org574f686}
\subsubsection{Rango de una Matrix}
\label{sec:org4f7e239}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Rango de una Matrix]{python}

def rango(self):
    """Rango de una Matrix"""
    return [v.no_es_nulo() for v in self.K()].count(True)

\end{minted}

\subsubsection{Comprobación de que una Matrix es singular o de que es invertible}
\label{sec:orgde81948}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Comprobación de que una Matrix es singular o de que es invertible]{python}

def es_singular(self):
    if not self.es_cuadrada():
        raise ValueError('La matriz no es cuadrada')
    return self.rango()<self.n
  
def es_invertible(self):
    if not self.es_cuadrada():
        raise ValueError('La matriz no es cuadrada')
    return self.rango()==self.n
  
\end{minted}

\subsubsection{Cálculo de la matriz inversa}
\label{sec:org83f2c30}

En la representación se muestra primero la reducción adelante y atrás,
luego se escalona y finalmente se normaliza.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Cálculo de la matriz inversa]{python}

def inversa(self, rep=0):                                                               
    """Inversa de Matrix"""
    if not self.es_cuadrada():
        raise ValueError('Matrix no cuadrada')
    
    pasos = self.elim(2).elim(20).elim(10).pasos
    TrF = pasos[0]
    TrC = pasos[1]
    tex   = rprElim(self.apila(I(self.n),1),pasos)
    
    if rep:
        display(Math(tex))

    if self.es_singular():
        raise ValueError('Matrix es singular')

    InvMat = I(self.n) & T(TrC)
    InvMat.pasos = pasos
    InvMat.TrF   = TrF
    InvMat.TrC   = TrC
    InvMat.tex   = tex
    return InvMat

\end{minted}

\subsubsection{Cálculo del determinante}
\label{sec:org5142b20}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Cálculo del determinante por eliminación]{python}

def determinante(self, rep = False, sust = []):
    """Calculo del determinate mediante eliminación"""
    if not self.es_cuadrada(): raise ValueError('Matrix no cuadrada')
    
    return Determinante(self.subs(sust),rep).valor
                       
\end{minted}

\subsubsection{Diagonalización por Semejanza}
\label{sec:org401bd32}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Diagonalizando por Semejanza en una matriz por bloques triangulares]{python}
def diagonalizaS(self, espectro, rep=False, sust=[]):
    <<Texto de ayuda para la clase DiagonalizaS>>
    D            = Matrix(self).copy().subs(sust)
    <<Comprobaciones previas a la diagonalización>>
    espectro     = [sympy.S(l).subs(sust) for l in espectro]    
    S            = I(D.n)
    Tex          = latex( D.apila(S,1) )
    pasosPrevios = [[],[]]
    selecc       = list(range(1, D.n+1))

    for landa in espectro:
        m = selecc.pop()
        <<Restamos lambda*I>>
        # eliminamos elementos superiores de la columna con elim de izda a dcha
        TrCol = filtradopasos((slice(None,m)|D|slice(None,m)).elim(20).pasos[1])
        <<Aplicación de las transformaciones y sus inversas espejo>>
        
        if m < D.n: # eliminamos elementos inferiores de la columna con los pivotes de la diagonal
            for i,_ in enumerate(slice(m+1,None)|D|m, m+1):
                TrCol = filtradopasos([ T([(-fracc(i|D|m, i|D|i), i, m)]) ]) if i|D|i else [T([])]
                <<Aplicación de las transformaciones y sus inversas espejo>>     
        <<Sumamos lambda*I>>
                    
    if rep: display(Math(Tex))
    D.espectro = espectro[::-1]
    D.tex = Tex
    D.S   = S
    D.TrC = pasosPrevios[1]
    D.TrF = [op.Tinversa().espejo() for op in D.TrC[::-1]]
    D.pasos = [D.TrF, D.TrC]
    return D
    
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para la clase DiagonalizaS]{python}
"""Diagonaliza por bloques triangulares una Matrix cuadrada

Encuentra una matriz diagonal semejante mediante trasformaciones de
sus columnas y las correspondientes transformaciones inversas espejo
de las filas. Requiere una lista de autovalores (espectro), que deben
aparecer en dicha lista tantas veces como sus respectivas
multiplicidades algebraicas. Los autovalores aparecen en la diagonal
principal de la matriz diagonal. El atributo S de dicha matriz
diagonal es una matriz cuyas columnas son autovectores de los
correspondientes autovalores.  """
\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Comprobaciones previas a la diagonalización]{python}

def no_son_autovalores(A, L):
    no_son=[l for i,l in enumerate(L) if (D-l*I(D.n)).es_invertible()]
    if no_son:
        print('los valores de la siguiente lista no son autovalores de la matriz:', no_son)
        return True
    else:
        False

def espectro_correcto(A, L):
    x = sympy.symbols('x')    
    monomio = lambda l,x: l-x
    p = (A-x*I(A.n)).det()
    for l in L:
        p, r = sympy.div(p, monomio(l,x), domain ='QQ')    
    return False if p!=1 or r!=0 else True

if not D.es_cuadrada:
    raise ValueError('Matrix no es cuadrada')

if not isinstance(espectro, list):
    raise ValueError('espectro no es una lista')

if no_son_autovalores(D, espectro):
    raise ValueError('quite de la lista los valores que no son autovalores')
    
if not len(espectro)==D.n:
    raise ValueError('el espectro propocionado tiene un número inadecuado de autovalores')

if not espectro_correcto(D, espectro):
    raise ValueError('introduzca una lista correcta de autovalores')

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Restamos lambda*I]{python}

D = (D-(landa*I(D.n))).subs(sust)
Tex += r'\xrightarrow[\boxed{' + latex(landa) + r'\mathbf{I}}]{(-)}' + latex((D.apila(S,1)).subs(sust))

\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Sumamos lambda*I]{python}

D = (D+(landa*I(D.n))).subs(sust)
Tex += r'\xrightarrow[\boxed{' + latex(landa) + r'\mathbf{I}}]{(+)}' + latex((D.apila(S,1)).subs(sust))

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Aplicación de las transformaciones y sus inversas espejo]{python}

if T(TrCol):
    Tex             = rprElim( D.apila(S,1),  [[], TrCol], Tex, sust) if TrCol else Tex
    D               = (D & T(TrCol)).subs(sust)
    S               = (S & T(TrCol)).subs(sust)
    pasosPrevios[1] = pasosPrevios[1] + TrCol
    
    TrFilas         = [ T( [op.Tinversa().espejo() for op in TrCol[::-1]] ) ]
    
    Tex             = rprElim( D.apila(S,1), [TrFilas, []], Tex, sust) if TrCol else Tex
    D               = (T(TrFilas) & D).subs(sust)
    pasosPrevios[0] = TrFilas + pasosPrevios[0]

\end{minted}

\subsubsection{Diagonalización por Congruencia}
\label{sec:org1da3f14}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para la clase DiagonalizaC]{python}
"""Diagonaliza por congruencia una Matrix simétrica (evitando dividir)

Encuentra una matriz diagonal por conruencia empleando una matriz B
invertible (evitando fracciones por defecto, si variante=1 entonces no
evita las fracciones) por la derecha y su transpuesta por la
izquierda. No emplea los autovalores. En general los elementos en la
diagonal principal no son autovalores, pero hay tantos elementos
positivos en la diagonal como autovalores positivos, tantos negativos
como autovalores negativos, y tantos ceros como auntovalores nulos.

"""
\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Diagonalizando por Congruencia una matriz simétrica]{python}
def diagonalizaC(self, rep=False, sust=[], variante=0):
    <<Texto de ayuda para la clase DiagonalizaC>>
    <<Definición del método auxiliar BuscaPrimerNoNuloEnLaDiagonal>>
    if not variante in {0,1}:
        raise ValueError('La variante debe ser 0 ó 1')
    
    D            = Matrix(self).copy().subs(sust)
    
    if not D.es_simetrica():
        raise ValueError('La matriz no es simétrica')
     
    pasosPrevios = [ [], [] ]
    
    for i in range(1, D.n):
        p = BuscaPrimerNoNuloEnLaDiagonal(D, i)
        j = [k for k,col in enumerate(D|slice(i,None),i) if (i|col and not k|col)]
        
        if not (i|D|i):
            if p:
                Tr = T( {i, p} )
                p = i
                <<Aplicación de las transformaciones a las columnas y a las filas>>
            elif j:
                Tr = T( (1, j[0], i) )
                p = i
                <<Aplicación de las transformaciones a las columnas y a las filas>>
        if p:
            Tr = T(((i,)|D).elim(variante).pasos[1]) 
            <<Aplicación de las transformaciones a las columnas y a las filas>>
           
    D.pasos     = pasosPrevios
    D.tex       = rprElimCF(Matrix(self).subs(sust), D.pasos, [], sust) 
    D.TrF       = filtradopasos(T(D.pasos[0]))
    D.TrC       = filtradopasos(T(D.pasos[1]))
    D.B         = I(self.n) & D.TrC
    
    if rep: 
        display(Math(D.tex))

    return D   
    
\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición del método auxiliar BuscaPrimerNoNuloEnLaDiagonal]{python}

def BuscaPrimerNoNuloEnLaDiagonal(self, i=1):
    """Indica el índice de la primera componente no nula de a diagonal
    desde de la posición i en adelante. Si son todas nulas devuelve 0

    """
    
    d = (slice(i,None)|self|slice(i,None)).diag().sis()
    return next((pos for pos, x in enumerate(d) if x), -i) + i

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Aplicación de las transformaciones a las columnas y a las filas]{python}

pasos = [ filtradopasos([~Tr]), filtradopasos([Tr]) ]
pasosPrevios[0] = pasos[0] + pasosPrevios[0]
pasosPrevios[1] = pasosPrevios[1] + pasos[1]
D = (T(pasos[0]) & D & T(pasos[1])).subs(sust)

\end{minted}

\subsection{Diagonalización ortogonal de una matriz simétrica}
\label{sec:org3758872}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Diagonalizando Ortogonalmente una matriz simétrica]{python}

def diagonalizaO(self, espectro, sust=[]):
    <<Texto de ayuda para la clase DiagonalizaO>>
    D            = Matrix(self).copy().subs(sust)
    
    if not D.es_simetrica():
        raise ValueError('La matriz no es simétrica')
    
    <<Comprobaciones previas a la diagonalización>>
    <<Método auxiliar para creación de una base ortonormal donde \Vect{q} es el último vector>>
    
    espectro     = [sympy.S(l).subs(sust) for l in espectro]    
    S            = I(D.n)
    Tex          = latex( D.apila(S,1) )
    pasosPrevios = [[],[]]
    selecc       = list(range(1,D.n+1))

    for l in espectro:
        D       = (D - l*I(D.n)).subs(sust)
        k       = len(selecc)
        nmenosk = (D.n)-k
        m       = selecc.pop()
        TrCol   = filtradopasos((slice(None,m)|D|slice(None,m)).elim(20, False, sust).pasos[1])
        D       = (D + l*I(D.n)).subs(sust)
        
        
        q = ( (I(k) & T(TrCol)).subs(sust) )|0
        q = (sympy.sqrt(q*q)) * q
        
        Q = BaseOrtNor(q).concatena(M0(k,nmenosk)).apila( \
                M0(nmenosk,k).concatena(I(nmenosk)))  if nmenosk else BaseOrtNor(q)
            
        S = (S*Q).subs(sust)
        D = (~Q*D*Q).subs(sust)

    D.Q = S
    D.espectro = espectro[::-1]
    return D

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para la clase DiagonalizaO]{python}
"""Diagonaliza ortogonalmente una Matrix simétrica

Encuentra una matriz diagonal por semejanza empleando una matriz
ortogonal Q a la derecha y su inversa (transpuesta) por la izquierda.
Requiere una lista de autovalores (espectro), que deben aparecer
tantas veces como sus respectivas multiplicidades algebraicas. Los
autovalores aparecen en la diagonal principal de la matriz
diagonal. El atributo Q de la matriz diagonal es la matriz ortogonal
cuyas columnas son autovectores de los correspondientes autovalores.

"""
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método auxiliar para creación de una base ortonormal donde \Vect{q} es el último vector]{python}

def BaseOrtNor(q):
    "Crea una base ortonormal cuyo último vector es 'q'"
    if not isinstance(q,Vector): raise ValueError('El argumento debe ser un Vector')
    M = Matrix([q]).concatena(I(q.n)).GS()
    l = [ j for j, v in enumerate(M, 1) if v.no_es_nulo() ]
    l = l[1:len(l)]+[l[0]]
    return (M|l).normalizada()

\end{minted}

\section{Representación de la clase \texttt{Matrix}}
\label{sec:org3cdb28d}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método de representación repr de la subclase Matrix]{python}

def __repr__(self):
    """ Muestra una Matrix en su representación Python repr """
    return 'Matrix(' + repr(self.lista) + ')'
                           
\end{minted}

\section{La clase \texttt{Matrix} completa}
\label{sec:orgd2e0264}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la subclase Matrix]{python}
class Matrix(BlockM):
    <<Texto de ayuda de la clase Matrix>>
    <<Inicialización de la subclase Matrix>>
    <<Información sobre la disposición de los elementos de una Matrix>>
    <<Creación de un Vector a partir de la diagonal de una Matrix>>
    <<Normalizado de las columnas o filas de una matriz>>
    <<Potencia de una Matrix>>
    <<Determinante mediante la expansión de Laplace>>
    <<Método Gram-Schmidt para ortogonalizar un sistema de Vectores de Rn>>
    <<Rango de una Matrix>>
    <<Comprobación de que una Matrix es singular o de que es invertible>>
    <<Cálculo de la matriz inversa>>
    <<Cálculo del determinante por eliminación>>
    <<Diagonalizando por Semejanza en una matriz por bloques triangulares>>
    <<Diagonalizando por Congruencia una matriz simétrica>>
    <<Diagonalizando Ortogonalmente una matriz simétrica>>
    <<Método de representación repr de la subclase Matrix>>
\end{minted}


\chapter{Las subclases \texttt{M0}, \texttt{M1} e \texttt{I}}
\label{sec:org36bad8b}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de las subclases M0, M1 e I]{python}

class M0(Matrix):
    def __init__(self, m, n=None):
        """ Inicializa una matriz nula de orden m por n """
        n = m if n is None else n

        super().__init__( [V0(m)]*n )
        self.__class__ = Matrix

class M1(Matrix):
    def __init__(self, m, n=None):
        """ Inicializa una matriz nula de orden m por n """
        n = m if n is None else n

        super().__init__( [V1(m)]*n )
        self.__class__ = Matrix

class I(Matrix):
    def __init__(self, n):
        """ Inicializa la matriz identidad de tamaño n """
        super().__init__([[(i==j)*1 for i in range(n)] for j in range(n)])
        self.__class__ = Matrix

\end{minted}


\chapter{\texttt{Sistemas} obtenidos tras algunos procedimientos específicos de eliminación}
\label{sec:orgab385ed}

Por comodidad y compatibilidad con la versión anterior de NAcAL
creamos las siguientes subclases de Sistema que resultan tras aplicar
ciertos pasos de eliminación.

\section{Subclases de \texttt{Sistema}: \texttt{Elim}, \texttt{ElimG}, \texttt{ElimGJ},  \texttt{ElimGF} y  \texttt{ElimGJF}}
\label{sec:orge18b6a9}
Son una forma alternativa de llamar a los métodos \texttt{.K()}, \texttt{.L()},
\texttt{.R()}, \texttt{.U()} y \texttt{.UR()}. Los dos últimos, \texttt{.U()} y \texttt{.UR()} (es decir,
\texttt{ElimGF} y \texttt{ElimGJF}) solo tienen sentido si el Sistema es un arreglo
rectangular y cada uno de sus componentes es de composición uniforme,
es decir, es necesario que las operaciones de eliminación estén
definidas entre los elementos de cada componente del sistema. Es el
método correspondiente a la eliminación por filas en matrices.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class Elim(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve una forma pre-escalonada de un sistema

           operando con sus elementos (y evitando operar con
           fracciones).  Si rep es no nulo, se muestran en Jupyter los
           pasos dados

        """
        self.__dict__.update(sistema.K(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class ElimG(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve una forma escalonada de un sistema

           operando con sus elementos (y evitando operar con
           fracciones).  Si rep es no nulo, se muestran en Jupyter los
           pasos dados

        """
        self.__dict__.update(sistema.L(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class ElimGJ(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada reducida de un sistema

           operando con sus elementos (y evitando operar con
           fracciones).  Si rep es no nulo, se muestran en Jupyter los
           pasos dados

        """
        self.__dict__.update(sistema.R(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class ElimF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada por filas (si es posible)

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """        
        self.__dict__.update(sistema.elim(4, rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class ElimGF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada por filas (si es posible)

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """        
        self.__dict__.update(sistema.U(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class ElimGJF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada reducida por filas (si es posible)

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """        
        self.__dict__.update(sistema.UR(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

\end{minted}

\section{Subclases de \texttt{Matrix}: \texttt{InvMat}, \texttt{InvMatF} e \texttt{InvMatFC}}
\label{sec:orgf8140da}
Son una forma alternativa de llamar al método \texttt{.inversa()},

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class InvMat(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la matriz inversa y los pasos dados sobre las columnas

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
        A = sistema.subs(sust).inversa()
        A.tex, A.pasos = texYpasos(sistema.apila(I(sistema.n),1), A.pasos, rep, sust, repsust)
        A.TrF = A.pasos[0]
        A.TrC = A.pasos[1]
        self.__dict__.update(A.__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class InvMatF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la matriz inversa y los pasos dados sobre las filas

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>

        if not sistema.es_cuadrada():
            raise ValueError('Matrix no cuadrada')
    
        pasos = sistema.elim(26).elim(26).elim(14).pasos
        A = T(pasos[0]) & I(sistema.n)
        A.tex, A.pasos = texYpasos(sistema.concatena(I(sistema.n),1), pasos, rep, sust, repsust)
        A.TrF = A.pasos[0]
        A.TrC = A.pasos[1]
        self.__dict__.update(A.__dict__)
        self.__class__ = type(sistema)

\end{minted}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class InvMatFC(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la matriz inversa y los pasos dados sobre las filas y columnas

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>

        if not sistema.es_cuadrada():
            raise ValueError('Matrix no cuadrada')
    
        pasos = sistema.elim(24).elim(10).pasos
        A = sistema.copy()
        nan = sympy.symbols('\ ')
        dummyMatrix = M1(A.n)*nan
        A.tex, A.pasos = texYpasos(A.concatena(I(A.n),1).apila(I(A.n).concatena(dummyMatrix,1),1), pasos, rep, sust, repsust)
        A.TrF = A.pasos[0]
        A.TrC = A.pasos[1]
        A.F   = T(A.TrF) & I(A.n)
        A.C   = I(A.n) & T(A.TrC)
        A.lista = (A.C*A.F).lista
        self.__dict__.update(A.__dict__)
        self.__class__ = type(sistema)

\end{minted}

\section{Subclases de \texttt{Matrix}: \texttt{DiagonalizaS}, \texttt{DiagonalizaO} y  \texttt{DiagonalizaC}}
\label{sec:org3680a8c}
Es una forma alternativa de llamar al método \texttt{.diagonalizaS()},

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class DiagonalizaS(Matrix):
    def __init__(self, sistema, espectro, rep=0, repType=0):
        <<Texto de ayuda para la clase DiagonalizaS>>
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
        A = Matrix(sistema)
        D = A.diagonalizaS(espectro)
        
        if rep:
            nan   = sympy.symbols('\ ')
            dummyMatrix = M1(A.n)*nan
            if repType==1:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimCF(A.apila(I(A.n),1), D.pasos)
            elif repType==2:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimCF(A.apila(I(A.n),1).concatena(I(A.m).apila(dummyMatrix,1),1), D.pasos)
            elif repType==3:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimFyC(A.apila(I(A.n),1), D.pasos)
            elif repType==4:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimFyC(A.apila(I(A.n),1).concatena(I(A.m).apila(dummyMatrix,1),1), D.pasos)
                
            display(Math(D.tex))
            
        self.__dict__.update(D.__dict__)
        self.__class__ = type(sistema)

\end{minted}

Es una forma alternativa de llamar al método \texttt{.diagonalizaO()},

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class DiagonalizaO(Matrix):
    def __init__(self, sistema, espectro):
        <<Texto de ayuda para la clase DiagonalizaO>>
        A = Matrix(sistema)
        D = A.diagonalizaO(espectro)
            
        self.__dict__.update(D.__dict__)
        self.__class__ = type(sistema)

\end{minted}

Es una forma alternativa de llamar al método \texttt{.diagonalizaC()},

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

class DiagonalizaC(Matrix):
    def __init__(self, sistema, rep=False, sust=[], variante=0):
        <<Texto de ayuda para la clase DiagonalizaC>>
        A = Matrix(sistema)
        D = A.diagonalizaC(rep, sust, variante)
            
        self.__dict__.update(D.__dict__)
        self.__class__ = type(sistema)

\end{minted}




\part{La clase \texttt{T} (transformación elemental)}
\label{sec:org669009a}

\chapter{La clase \texttt{T}}
\label{sec:org698da30}

\section{Introducción}
\label{sec:org51618c9}

Vamos a implementar las transformaciones de un sistema \(\SV{A}\)
mediante secuencias de \emph{transformaciones elementales de Tipo I y II} e
\emph{intercambios}. Para que funcionen las \emph{transformaciones elementales}
debe estar definida tanto la suma de los elementos del sistema como el
producto de los elementos por un escalar:

\begin{description}
\item[{Tipo I:}] \(~\TESC{\lambda}{i}{j}{\SV{A}}\) suma \(\lambda\) veces el
elemento \(i\) al elemento \(j\) (\(i\ne j\));
\item[{Tipo II:}] \(~\TEPC{\lambda}{i}{\SV{A}}\) multiplica el elemento \(i\) por
\(\lambda\ne0\).
\item[{Intercambio:}] \(~\TEIC{i}{j}{\SV{A}}\) intercambia los elementos \(i\) y
\(j\).
\end{description}

\subsubsection{Comentario sobre la notación.}
\label{sec:org3e9b678}

Cualquier trasformación elemental de un sistema se puede lograr con el
producto del sistema por una matriz elemental, y \emph{la notación empleada
busca parecerse a la notación del producto matricial} (por ello, para
ilustrar lo que sigue usaremos como ejemplo de sistema una matriz
\Mat{A}):
\begin{quotation}
  Al poner la \emph{abreviatura} ``$\TrEl$'' de la
  transformación elemental a derecha es como si multiplicáramos la
  matriz \Matdim{A}{m}{n} por la derecha por la correspondiente matriz
  elemental
  \begin{displaymath}
    \TEC{\Mat{A}}=\Mat{A}\TECpE{\Mat{I}}\quad \text{donde la matriz \Mat{I} es de orden $n$}.
  \end{displaymath}

  De manera similar, al poner la \emph{abreviatura} ``$\TrEl$''
  de la transformación elemental a izquierda, es como si
  multiplicáramos la matriz \Matdim{A}{m}{n} por la izquierda por la
  correspondiente matriz elemental
  \begin{displaymath}
    \TEF{\Mat{A}}=\TEFpE{\Mat{I}}\Mat{A}\quad \text{ donde la matriz \Mat{I} es de orden $m$}.
  \end{displaymath}
\end{quotation}
Con ello se gana, entre otras cosas, que la notación sea
asociativa. Pero si se puede hacer con matrices elementales\dots{} ¿qué
ventaja tiene introducir en el discurso las transformaciones
elementales en lugar de utilizar simplemente matrices elementales?

Fíjese que una matriz cuadrada es un objeto muy ``pesado''\dots{} una
matriz de orden \(n\) posee \(n^2\) coeficientes. Afortunadamente una
matriz elemental es casi una matriz identidad salvo por el cambio de
uno de sus elementos. Por tanto, para describir completamente una
matriz elemental es necesario indicar su orden \(n\) y qué componente ha
cambiado.\footnote{Fíjese que la notación usada en el libro del curso de
Álgebra Lineal para las matrices elementales no las describe
completamente; se deja al lector la deducción de cuál es el orden de
la matriz elemental necesario para poder realizar el producto
\(\Mat{A}\TECpE{\Mat{I}}\) o el producto \(\TEFpE{\Mat{I}}\Mat{A}\).}  Por
este motivo\ldots{}

\begin{center}
\begin{tabular}{c}
\textbf{La ventaja de las transformaciones elementales es que omiten el orden \(n\).}\\
\\
\end{tabular}
\end{center}
pues solo necesitan indicar el índice de los elementos que intervienen
en la transformación.

\subsubsection{Traducción de las transformaciones elementales a Python}
\label{sec:org33d6d45}

Vamos a definir la siguiente traducción de esta notación a Python:

\begin{center}
\begin{tabular}{rr|ll}
Curso & Python & Curso & Python\\
\hline
\(\TEIF{i}{j}{\Mat{A}}\) & \texttt{T( \{i,j \} ) \& A} & \(\TEIC{i}{j}{\Mat{A}}\) & \texttt{A \& T( \{i,j\} )}\\
 &  &  & \\
\(\TEPF{a}{j}{\Mat{A}}\) & \texttt{T( (a,j) ) \& A} & \(\TEPC{a}{j}{\Mat{A}}\) & \texttt{A \& T( (a,j) )}\\
 &  &  & \\
\(\TESF{a}{i}{j}{\Mat{A}}\) & \texttt{T( (a,i,j) ) \& A} & \(\TESC{a}{i}{j}{\Mat{A}}\) & \texttt{A \& T( (a,i,j) )}\\
\hline
\end{tabular}
\end{center}

El código Python de la columna izquierda, donde la transformación se
aplica por la izquierda, solo será aplicable a los \texttt{BlockM} (solo
ellos tienen ``filas''). El código Python de la columna derecha será
aplicable a los \texttt{Sistemas}, pues opera con son elementos.


Vemos que:
\begin{enumerate}
\item Representar el intercambio con un conjunto, permite admitir la
repetición del índice, pues \(\{i,i\}=\{i\}\), denotando un caso
especial en el que la matriz no cambia (esto simplificará el
método de Gauss).
\item Tanto para los pares \texttt{(a,i)} como para las ternas \texttt{(a,i,j)}:
\begin{itemize}
\item La columna (fila) que cambia es la del índice que aparece en última posición.
\item El escalar de la primera posición multiplica a la columna
(fila) correspondiente al índice que le sigue.
\end{itemize}
\end{enumerate}

Empleando listas de abreviaturas extendemos la notación para expresar
secuencias de transformaciones elementales, es decir,
\begin{math}
  \TrEl_{1}\cdots\TrEl_{k}.
\end{math}
Así logramos la siguiente equivalencia entre expresiones
\begin{displaymath}
  \text{\tt{T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}}
  \quad = \quad
  \text{\tt{T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] )}}
\end{displaymath}
De esta manera
\begin{eqnarray*}
  \TrC{\Mat{A}}:\qquad &
  \Mat{A} \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
  \;=\; \Mat{A} \text{\tt{ \& T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] )}}
  \\\\
  \TrF{\Mat{A}}:\qquad &
  \text{\tt{ T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{) \& }} \Mat{A}
  \;=\; \text{\tt{ T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] ) \& }} \Mat{A}.
\end{eqnarray*}

Así, usando abreviaturas y si \Mat{A} es de orden \(m\times n\), el primer caso es equivalente a escribir el producto de matrices
\begin{displaymath}
  \TrC{\Mat{A}}\;=\;\Mat{A}\TECpE*[1]{\Mat{I}}\TECpE*[2]{\Mat{I}}\cdots\TECpE*[k]{\Mat{I}}
  \qquad
  \text{donde \Mat{I} es de orden $n$};
\end{displaymath}
y el segundo caso es equivalente a escribir el producto de matrices
\begin{displaymath}
  \TrF{\Mat{A}}
  \;=\;
  \TEFpE*[1]{\Mat{I}}\TEFpE*[2]{\Mat{I}}\cdots\TEFpE*[k]{\Mat{I}}\Mat{A}
  \qquad
  \text{donde \Mat{I} es de orden $m$...}
\end{displaymath}
¡Pero gracias a las abreviaturas de las transformaciones elementales
no es necesario indicar el orden (el número de filas y columnas) de
las matrices elementales en ningún momento!

\subsubsection{Necesidad de creación de una nueva clase}
\label{sec:org53fd0e7}

Python ejecuta las órdenes de izquierda a derecha. Fijándonos en la
expresión
\begin{displaymath}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
\end{displaymath}
podríamos pensar que podemos implementar la transformación elemental
como un método de la clase \texttt{Sistema}. Así, al definir el método
\texttt{\_\_and\_\_} por la derecha del \texttt{Sistema} podemos indicar que
\begin{math}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{)}}
\end{math}
es una nueva matriz con las columnas modificadas. Python no tiene
problema en ejecutar
\begin{math}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
\end{math}
pues ejecutar de izquierda a derecha, es lo mismo que ejecutar
\begin{math}
  \Bigg[\Big[\big[\Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{)}}\big] \text{\tt{\& T(}}\ t_2\ \text{\tt{)}} \Big] \text{\tt{\&}} \cdots \Bigg]\text{\tt{\& T(}}\ t_k  \text{\tt{)}}
\end{math}
donde la expresión dentro de cada corchete es una \texttt{Matrix}, por lo que
las operaciones están bien definidas. La dificultad aparece con
\begin{displaymath}
  \text{\tt{ T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{) \& }} \Mat{A}
\end{displaymath}
Lo primero que Python tratara de ejecutar es
\begin{math}
    \text{\tt{T(}}\ t_1\ \text{\tt{) \& T(}} \ t_2 \text{\tt{)}},
\end{math}
pero ni \(\text{\tt{T(}}\ t_1 \text{\tt{)}}\) ni \(\text{\tt{T(}}\ t_2
\text{\tt{)}}\) son matrices, por lo que esto no puede ser programado
como un método de la subclase \texttt{BlockM} (recuerde que al actuar por la
izquierda se opera con las filas, y solo los \texttt{BlockMs} tiene definidas
las filas).

Así pues, definiremos una nueva clase que almacene las \emph{abreviaturas}
\(t_i\) (``\(\OEg[i]\)'') de las operaciones elementales, de manera que
podamos definir
\begin{math}
  \text{\tt{T(}}\ t_i\ \text{\tt{) \& T(}} \ t_j \text{\tt{)}},
\end{math}
como un método que ``compone'' dos transformaciones elementales
(``\(\OEg[i]\OEg[j]\)'') para formar una secuencia de abreviaturas (que
en última instancia será una secuencia de operaciones a ejecutar sobre
un \texttt{Sistema}).

El nuevo objeto, \texttt{T} (``transformación elemental''), nos permitirá
encadenar transformaciones elementales (es decir, almacenar una lista
de abreviaturas). El siguiente código inicializa la clase. El atributo \texttt{t} almacenará la abreviatura (o lista de abreviaturas) dada al
instanciar \texttt{T} o bien creará la lista de abreviaturas a partir de
otra  \texttt{T} (o lista de objetos \texttt{T}) empleada para instanciar.

\section{Implementación de las transformaciones elementales}
\label{sec:org9dd229d}

\subsection{Texto de ayuda}
\label{sec:org798432f}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la clase ~T~]{python}
"""Clase para las transformaciones elementales

T ("Transformación elemental") guarda en su atributo 'abreviaturas'
una abreviatura (o una secuencia de abreviaturas) de transformaciones
elementales. El método __and__ actúa sobre otra T para crear una T que
es composición de transformaciones elementales (una la lista de
abreviaturas), o bien actúa sobre una BlockM (para transformar sus
filas).

Una T (transformación elemental) se puede instanciar indicando las
operaciones mediante un número arbitrario de

 1. abreviaturas(set): {índice, índice}. Abrev. de un intercambio de
                       entre los elementos correspondientes a dichos
                       índices

              (tuple): (escalar, índice). Abrev. transf. Tipo II que
                       multiplica el elemento correspondiente al
                       índice por el escalar

                       (escalar, índice1, índice2). Abrev.
                       transformación Tipo I que suma al elemento
                       correspondiente al índice2 el elemento
                       correspondiente al índice1 multiplicado por
                       el escalar

 2. transf. Elems.(T): Genera otra T cuyo atributo .abreviaturas es
                       una copia del atributo .abreviaturas de la
                       transformación dada

 3.      listas(list): Con cualesquiera de los anteriores objetos o
                       con sublistas formadas con los anteriores
                       objetos. Genera una T cuyo atributo
                       .abreviaturas es una concatenación de todas las
                       abreviaturas


Atributos:

   abreviaturas (set): lista con las abreviaturas de todas las
                       transformaciones

            rpr (str): Si rpr='v' (valor por defecto) se muestra la
                       lista de breviaturas en vertical. Con cualquier
                       otro valor se muestran en horizontal.

Ejemplos:
>>> # Intercambio entre elementoes
>>> T( {1,2} )

>>> # Trasformación Tipo II (multiplica por 5 el segundo elemento)
>>> T( (5,2) )

>>> # Trasformación Tipo I (resta el tercer elemento al primero)
>>> T( (-1,3,1) )

>>> # Secuencia de las tres transformaciones anteriores
>>> T( [{1,2}, (5,2), (-1,3,1)] )

>>> # T de una T
>>> T( T( (5,2) ) )

T( (5,2) )

>>> # T de una lista de T's
>>> T( [T([(-8, 2), (2, 1, 2)]), T([(-8, 3), (3, 1, 3)]) ] )

T( [(-8, 2), (2, 1, 2), (-8, 3), (3, 1, 3)] )

"""
\end{minted}

\subsection{Método de inicialización}
\label{sec:orga5b4b94}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la clase ~T~]{python}

def __init__(self, *args, rpr='v'):
    """Inicializa una transformación elemental"""
    <<Verificación de que las .abreviaturas corresponden a transformaciones elementales o intercambios>>
    <<Simplificacion de expresiones simbólicas en las abreviaturas>>
    def CreaListaAbreviaturas(arg):
        if isinstance(arg, (tuple, set)):
            verificacion(arg)
            arg = simplificacionSimbolica(arg)
            return [arg]
        if isinstance(arg, list):
            return [abrv for item in arg for abrv in CreaListaAbreviaturas(item)]
        if isinstance(arg, T):
            return CreaListaAbreviaturas(arg.abreviaturas) 
    
    def concatenaTodasLasAbreviaturasDeLos(args):
        return [abrv for item in args for abrv in CreaListaAbreviaturas(item)]
    
    self.abreviaturas = concatenaTodasLasAbreviaturasDeLos(args)
    self.rpr          = rpr

\end{minted}

\subsubsection{Verificación de que las abreviaturas corresponden a transformaciones elementales o intercambios}
\label{sec:org1f54c22}

Un transformación elemental no puede multiplicar ningún elemento por
cero, ni sumar a un elemento un múltiplo de si mismo. Además, un
intercambio solo tiene sentido a lo sumo entre dos elementos.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Verificación de que las .abreviaturas corresponden a transformaciones elementales o intercambios]{python}

def verificacion(abrv):
    if isinstance(abrv,tuple) and (len(abrv) == 2) and abrv[0]==0:
        raise ValueError('T( (0, i) ) no es una trasformación elemental')
    if isinstance(abrv,tuple) and (len(abrv) == 3) and (abrv[1] == abrv[2]):
        raise ValueError('T( (a, i, i) ) no es una trasformación elemental')
    if isinstance(abrv,set) and len(abrv)>2:
        raise ValueError ('El conjunto debe tener uno o dos índices para ser un intercambio')
    
\end{minted}

\subsubsection{Simplificacion de expresiones simbólicas en las abreviaturas}
\label{sec:orgfa72b11}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Simplificacion de expresiones simbólicas en las abreviaturas]{python}

def simplificacionSimbolica(arg):
    if isinstance(arg,tuple) and (len(arg) == 2):
        return (sympy.factor(arg[0]), arg[1],)
    elif isinstance(arg,tuple) and (len(arg) == 3):
        return (sympy.factor(arg[0]), arg[1], arg[2],)
    else:
        return arg

\end{minted}

\section{Composición de Transformaciones o transformación de un \texttt{Sistema} por la izquierda}
\label{sec:org267422c}

\subsection{Texto de ayuda}
\label{sec:org17d05e8}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda para la composición de Transformaciones Elementales]{python}
"""Composición de transformaciones elementales (o transformación filas)

Crea una T con una lista de abreviaturas de transformaciones elementales
(o llama al método que modifica las filas de una Matrix)

Parámetros:
    (T): Crea la abreviatura de la composición de transformaciones, es
         decir, una lista de abreviaturas
    (Matrix): Llama al método de la clase Matrix que modifica sus filas

Ejemplos:
>>> # Composición de dos Transformaciones elementales
>>> T( {1, 2} ) & T( (2, 4) )

T( [{1,2}, (2,4)] )

>>> # Composición de dos Transformaciones elementales
>>> T( {1, 2} ) & T( [(2, 4), (2, 1), {3, 1}] )

T( [{1, 2}, (2, 4), (2, 1), {3, 1}] )

>>> # Transformación de las filas de una Matrix
>>> T( [{1,2}, (4,2)] ) & A # multiplica por 4 la segunda fila de A y
                            # luego intercambia las dos primeras filas
"""        

\end{minted}

\subsection{Implementación}
\label{sec:orgf92a4b4}

Describimos la composición de transformaciones
\begin{math}
  \text{\tt{T(}}t_1\text{\tt{) \& T(}}t_{2}\text{\tt{)}}
\end{math}
creando una lista de abreviaturas \([\OEg[1],\OEg[2]]\) (mediante la
concatenación de listas)\footnote{Recuerde que la suma de listas
(\texttt{list + list}) concatena las listas}. Si \texttt{other} es un
\texttt{BlockV} o una \texttt{BlockM}, se llama al método \texttt{\_\_rand\_\_} de la clase
\texttt{other} (que transformará los elementos del vector en el primer caso,
y las filas de la matriz en el segundo; y que veremos más adelante).

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Composición de Transformaciones Elementales o aplicación sobre las filas de una Matrix]{python}

def __and__(self, other):
    <<Texto de ayuda para la composición de Transformaciones Elementales>>
    if isinstance(other, T):
        return T(self.abreviaturas+other.abreviaturas, rpr=self.rpr)

    if isinstance(other, Sistema):
        return other.__rand__(self)

\end{minted}

\section{Transposición de transformaciones elementales}
\label{sec:org83f86b9}



Puesto que
\begin{math}
  \;\SITEC{1}{k}{\Mat{I}}={\TECpE*[1]{\Mat{I}}\dotsm\TECpE*[k]{\Mat{I}}}\;
\end{math}
y puesto que el producto de matrices es asociativo, deducimos que la
transpuesta de \(\TrC[\OEg[1]\OEg[2]\cdots\OEg[k]]{\Mat{I}}\) es
\begin{displaymath}
  \Transp{\TrC[\OEg[1]\OEg[2]\cdots\OEg[k]]{\Mat{I}}}
  \;=\;
  \TransP{\TECpE*[1]{\Mat{I}}\TECpE*[2]{\Mat{I}}\dotsm\TECpE*[k]{\Mat{I}}}
  \;=\;
  \Transp*{\TEC[k]{\Mat{I}}}\dotsm\Transp*{\TEC[2]{\Mat{I}}}\Transp*{\TEC[1]{\Mat{I}}}
  \;=\;
  \TEFpE*[k]{\Mat{I}}\dotsm\TEFpE*[2]{\Mat{I}}\TEFpE*[1]{\Mat{I}}
  \;=\;\TrF[\OEg[k]\cdots\OEg[2]\OEg[1]]{\Mat{I}}
\end{displaymath}
Nótese cómo al transponer no solo cambiamos de lado los subíndices,
sino también invertimos el orden de la secuencia de transformaciones
(de la misma manera que también cambia el orden en el que se
multiplican las matrices elementales).  Esto sugiere denotar a la
operación de invertir el orden de las transformaciones como una
transposición:
\begin{displaymath}
  \Transp*{\SOEg[1][k]} = \SOEg[k][1];
\end{displaymath}
así
\begin{displaymath}
  \Transp{\SITEC{1}{k}{\Mat{A}}}=
  \TrF[\Transp*{\SOEg[1][k]}]{\MatTpE*{A}}=
  \TrF[\SOEg[k][1]]{\MatTpE*{A}}
\end{displaymath}

\textbf{Fíjese que efectivamente hemos logrado que la notación con abreviaturas se comporte como la notación matricial!}

El siguiente procedimiento invierte el orden de la lista cuando \texttt{t} es
una lista de abreviaturas. Cuando \texttt{t} es una única abreviatura, no
hace nada.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Operador transposición para la clase ~T~]{python}

def __invert__(self):
    """Transpone la lista de abreviaturas (invierte su orden)"""
    return T( list(reversed(self.abreviaturas)), rpr=self.rpr) if isinstance(self.abreviaturas, list) else self
    
\end{minted}

\section{Potencias e inversa de transformaciones elementales}
\label{sec:orgb6d4a22}

Toda matriz de la forma \(\TrC{\Mat{I}}\) ó \(\TrF{\Mat{I}}\) es
invertible por ser producto de matrices elementales:
\begin{displaymath}
  \Transp{\TrC{\Mat{I}}}\Transp{\TrC[\InvOEg[k]\cdots\InvOEg[1]]{\Mat{I}}}=
  \TrC[\SOEg\cdot\InvOEg[k]\cdots\InvOEg[1]]{\Mat{I}}=
  \Mat{I};
\end{displaymath}
por lo que podemos denotar por \(\Invp{\SOEg}\) a la sucesión de
\(\InvOEg[k]\cdots\InvOEg[1]\). De este modo
\begin{displaymath}
  \Invp{\TrC{\Mat{I}}}=
  \TrC[\Invp*{\SOEg}]{\Mat{I}}=
  \TrC[\InvOEg[k]\cdots\InvOEg[1]]{\Mat{I}}.
\end{displaymath}
El siguiente método devuelve la potencia \texttt{n}-ésima de una
transformación elemental y cuando \texttt{n} es \(-1\) dicha potencia es la
inversa:

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
T([ (1, 2, 3), (fracc(1,3), 2), {1, 2} ]) **(-1)
\end{minted}
\texttt{T([\{1, 2\}, (3, 2), (-1, 2, 3)])}
que en Jupyter veríamos como
\(\displaystyle \underset{\begin{subarray}{c} \left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]\\\left[\left(3\right)\mathbf{2}\right]\\\left[\left(-1\right)\mathbf{2}+\mathbf{3} \right]\end{subarray}}{\pmb{\tau}}\)

Al implementar el método, definimos la potencia de manera recursiva
(con una función auxiliar \texttt{lambda}). Además, si \texttt{n} es cero,
devolveremos una transformación que no haga nada (identidad); por
ejemplo \(\OEin{1}{1}\).

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Potencia de una ~T~]{python}

def __pow__(self,n):
    """Calcula potencias de una T (incluida la inversa)"""
    <<Método auxiliar que calcula la inversa de una Transformación elemental>>    
    if not isinstance(n,int):
        raise ValueError('La potencia no es un entero')

    potencia = lambda T, n: T if n==1 else T & potencia(T, n-1)
    TransformacionElemental = potencia(self,abs(n)) if n!=0  else  T({1})
    
    return TransformacionElemental if n>0 else Tinversa(TransformacionElemental)
        
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método auxiliar que calcula la inversa de una Transformación elemental]{python}

def Tinversa ( self ):
    """Calculo de la inversa de una transformación elemental"""
    operaciones = [                      abrv     if isinstance(abrv,set) else \
                    ( -abrv[0], abrv[1], abrv[2]) if len(abrv)==3         else \
                    (fracc(1,abrv[0]),   abrv[1])   for abrv in CreaLista(self.abreviaturas) ]

    return ~T( operaciones, rpr=self.rpr)

\end{minted}

\section{Transformaciones elementales ``espejo''}
\label{sec:orgb6b4456}

Al diagonalizar por semejanza, y aplicar transformaciones elementales
por la derecha, que es lo mismo que multiplicar por una matriz
invertible por la derecha, necesitaremos expresar la correspondiente
matriz inversa mediante una secuencia de transformaciones elementales
de la filas de la matriz identidad. Esto se logra con el método
\texttt{espejo}.\footnote{Al no encontrar ningún nombre en los manuales de
Álgebra Lineal para este concepto, he adoptado este descriptivo
nombre.}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Transformación elemental espejo de una ~T~]{python}
def espejo ( self ):
    """Calculo de la transformación elemental espejo de otra"""
    return T([ (abrv[0], abrv[2], abrv[1]) if len(abrv)==3 else abrv for abrv in CreaLista(self.abreviaturas)], rpr=self.rpr)
    
\end{minted}

\section{Sustitución de variables simbólicas}
\label{sec:orgfc9bb22}

Sustituye la variable \texttt{c} por \texttt{v}, donde \texttt{v} puede ser un valor, u otra variable simbólica.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Sustitución de variables simbólicas en una Transformación elemental]{python}

def subs(self, regla_de_sustitucion=[]):
    '''Sustitución simbólica en transformaciones elementales'''
    
    def sustitucion(operacion, regla_de_sustitucion):
        if isinstance(operacion, tuple):
            return tuple(sympy.S(operacion).subs(CreaLista(regla_de_sustitucion)) )
        elif isinstance(operacion, set):
            return set(sympy.S(operacion).subs(CreaLista(regla_de_sustitucion)) )
        elif isinstance(operacion, list):
            return [sustitucion(item, regla_de_sustitucion) for item in operacion] 
        elif isinstance(operacion, T):
            return operacion.subs(CreaLista(regla_de_sustitucion)) 
        
    self = T([sustitucion(operacion, regla_de_sustitucion) for operacion in self.abreviaturas])
    return self

def simplify(arg):
    if isinstance(arg,tuple) and (len(arg) == 2):
        return (simplify(arg[0]), arg[1],)
    elif isinstance(arg,tuple) and (len(arg) == 3):
        return (simplify(arg[0]), arg[1], arg[2],)
    else:
        return arg

def factor(arg):
    if isinstance(arg,tuple) and (len(arg) == 2):
        return (factor(arg[0]), arg[1],)
    elif isinstance(arg,tuple) and (len(arg) == 3):
        return (factor(arg[0]), arg[1], arg[2],)
    else:
        return arg

def expand(arg):
    if isinstance(arg,tuple) and (len(arg) == 2):
        return (expand(arg[0]), arg[1],)
    elif isinstance(arg,tuple) and (len(arg) == 3):
        return (expand(arg[0]), arg[1], arg[2],)
    else:
        return arg

\end{minted}

\section{Métodos similares a los de una \texttt{list}}
\label{sec:org11e15f9}
\subsection{T es iterable}
\label{sec:orgb1b1d9c}

Haremos que \texttt{T} sea iterable con los procedimientos ``mágicos'' \texttt{\_\_getitem\_\_}, que permite seleccionar pasos de \texttt{T}, y 
\texttt{\_\_setitem\_\_}, que permite modificar pasos de \texttt{T}. Con \texttt{\_\_len\_\_}
podremos contar el número de pasos de \texttt{T}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __getitem__(self,i):
    """ Devuelve las transformaciones elementales del i-ésimo paso """
    return T(self.abreviaturas[i])

def __setitem__(self,i,value):
    """ Modifica las transformaciones elementales del i-ésimo paso """
    self.abreviaturas[i]=value
        
def __len__(self):
    """Número de pasos de T """
    return len(self.abreviaturas)

\end{minted}

\subsection{Igualdad entre transformaciones elementales}
\label{sec:orgfb874d4}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Igualdad entre transformaciones elementales]{python}

def __eq__(self, other):
    """Indica si es cierto que dos Transformaciones elementales son iguales"""
    return self.abreviaturas == other.abreviaturas

\end{minted}

\section{Representación de la clase \texttt{T}}
\label{sec:orga1af896}

De nuevo construimos los dos métodos de presentación. Uno para la
consola de comandos que escribe \texttt{T} y entre paréntesis la
abreviatura (una tupla o un conjunto) que representa la
transformación. Así,
\begin{itemize}
\item  \Verb/T( {1, 5} )/ \qquad: intercambio entre los vectores primero y quinto.
\item  \Verb/T( (6, 2) )/ \qquad: multiplica por seis el segundo vector.
\item  \Verb/T( (-1, 2, 3) )/\,: resta el segundo vector al tercero.
\end{itemize}
La otra representación es para el entorno Jupyter y replica la
notación usada en los apuntes de la asignatura:
\begin{displaymath}
  \begin{array}{|l||c|}
    \hline
    \text{Python} & \text{Representación en Jupyter} \\
    \hline\hline
    \text{\tt T( \{1, 5\} )}   & \underset{\left[\pe{1}{5}\right]}{\pmb{\tau}}\\\hline
    \text{\tt T( (6, 2) )}     & \underset{\left[\pr{6}{2}\right]}{\pmb{\tau}}                      \\\hline
    \text{\tt T( (-1, 2, 3) )} & \underset{\left[\su{-1}{2}{3}\right]}{\pmb{\tau}}          \\\hline
    %\text{\tt T( (6, 2) )}     & \underset{\left[(6)\mathbf{2}\right]}{\pmb{\tau}}                      \\\hline
    %\text{\tt T( (-1, 2, 3) )} & \underset{\left[(-1)\mathbf{2}+\mathbf{3}\right]}{\pmb{\tau}}          \\\hline
  \end{array}
\end{displaymath}
Los apuntes de la asignatura usan una notación matricial, y por tanto
es una notación que discrimina entre operaciones sobre las filas o las
columnas, situando los operadores a la izquierda o a la derecha de la
matriz. En este sentido, nuestra notación en Python hace lo
mismo. Así, en la siguiente tabla, la columna de la izquierda
corresponde a operaciones sobre las filas, y la columna de la derecha
a las operaciones sobre las columnas:
\begin{displaymath}
  \begin{array}{|r|r||l|l|}
    \hline
    \text{Mates II}&\text{Python} & \text{Mates II}&\text{Python}\\
    \hline\hline
    \TEIF{i}{j}{\Mat{A}}     & \text{{\tt T( \{i,j\} ) \& A}} &
    \TEIC{i}{j}{\Mat{A}}     & \text{{\tt A \& T( \{i,j\} ) }} \\ \hline
    \TEPF{a}{i}{\Mat{A}}     & \text{{\tt T( (a,i) ) \& A}}    &
    \TEPC{a}{j}{\Mat{A}}     & \text{{\tt A \& T( (a,j) ) }}   \\ \hline
    \TESF{a}{i}{j}{\Mat{A}} & \text{{\tt T( (a,i,j) ) \& A}}  &
    \TESC{a}{i}{j}{\Mat{A}} & \text{{\tt A \& T( (a,i,j) ) }} \\ \hline    
  \end{array}
\end{displaymath}

\subsection{Secuencias de transformaciones}
\label{sec:org70c32e5}

Considere las siguientes transformaciones
\begin{itemize}
\item multiplicar por 2 el primer vector, cuya abreviatura es:\qquad\quad \Verb/ (2, 1) /
\item intercambiar el tercer vector por cuarto, cuya abreviatura es:\quad \Verb/ {3, 4} /
\end{itemize}
Para indicar una secuencia que contiene ambas transformaciones,
usaremos una lista de abreviaturas: \texttt{[(2,1), \{3,4\}]}.
De esta manera, cuando componemos
ambas operaciones: \texttt{T( (2,1) ) \& T( \{3,4\} )},
nuestra librería nos devuelve la trasformación composición de las dos
operaciones \textbf{en el orden en el que han sido escritas}:
\begin{center}
  al escribir \mbox{\Verb/ T( (2, 1) ) & T( {3, 4} )/}
  \quad Python nos devuelve \quad
  \mbox{\Verb/T( [ (1, 2), {3, 4} ] )/}
\end{center}
Por tanto, si queremos realizar dichas operaciones sobre las columnas
de la matriz \Mat{A}, podemos hacerlo de dos formas: 
\begin{itemize}
\item \Verb/ A & T( (2, 1) ) & T( {3, 4} ) / \quad (indicando las transformaciones de una en una)
\item \Verb/ A & T( [(2, 1), {3, 4}] ) /    \quad (usando la transformación composición de ambas)
\end{itemize}
y si queremos operar sobre la filas hacemos exactamente igual, pero a
la izquierda de la matriz
\begin{itemize}
\item \Verb/ T( (2, 1) ) & T( {3, 4} ) & A/
\item \Verb/ T( [(2, 1), {3, 4}] ) & A/
\end{itemize}

\subsubsection{Representación de una secuencia de transformaciones}
\label{sec:org06849fc}

\begin{displaymath}
  \begin{array}{|l||c|}
    \hline
    \text{Representación en la consola de Python} & \text{Representación en Jupyter} \\
    \hline\hline
    \text{ \tt T( [ (2, 1), (1, 3, 2) ] ) } &
    \underset{\delimitershortfall=-1pt
      \begin{subarray}{c}
        \\\left[\pr{2}{1}\right]
        \\\left[\su{1}{3}{2}\right]
      \end{subarray}}{\TrEl}
    \\\hline
  \end{array}
\end{displaymath}

\subsubsection{Representación de transformaciones identidad}
\label{sec:org5c7c4df}

Si las transfomaciones multiplican un vector por 1, y suman un vector
nulo a otro vector, dichas transformaciones no cabian el sistema de
vectores. Lo habitual es que si un paso no modifica nada, que no se
represente, por ello se filtran los pasos con el procedimiento \hyperref[sec:orgce2afb5]{Cribado
de secuencias de transformaciones}; si, a resultas del filtrado, la
lista de abreviaturas es vacía entonces la representación en \LaTeX{}
es una cadena vacía (no se pinta ningún símbolo en Jupyter). Si el
atributo \texttt{rpr} es distinto de \texttt{'v'} la representación en Jupiter se
realiza en horizontal.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Representación de la clase ~T~]{python}

def __repr__(self):
    """ Muestra T en su representación Python """
    return 'T(' + repr(self.abreviaturas) + ')'

def _repr_html_(self):
    """ Construye la representación para el entorno Jupyter Notebook """
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para representar una Trans. Elem. """
    def simbolo(t):
        """Escribe el símbolo que denota una trasformación elemental particular"""
        if isinstance(t,(set,sympy.sets.sets.FiniteSet)):
            return '\\left[\\mathbf{' + latex(list(t)[0]) + \
              '}\\rightleftharpoons\\mathbf{' + latex(list(t)[-1]) + '}\\right]'
        if isinstance(t,(tuple, sympy.core.containers.Tuple)) and len(t) == 2:
            return '\\left[\\left(' + \
              latex(t[0]) + '\\right)\\mathbf{'+ latex(t[1]) + '}\\right]'
        if isinstance(t,(tuple, sympy.core.containers.Tuple)) and len(t) == 3:
            return '\\left[\\left(' + latex(t[0]) + '\\right)\\mathbf{' + \
              latex(t[1]) + '}' + '+\\mathbf{' + latex(t[2]) + '} \\right]'    

    if isinstance(self.abreviaturas, (set, tuple) ):
        return '\\underset{' + simbolo(self.abreviaturas) + '}{\\pmb{\\tau}}'

    elif self.abreviaturas == []:
        return ' '

    elif isinstance(self.abreviaturas, list) and self.rpr=='v':
        return '\\underset{\\begin{subarray}{c} ' + \
              '\\\\'.join([simbolo(i) for i in self.abreviaturas])  + \
              '\\end{subarray}}{\\pmb{\\tau}}'

    elif isinstance(self.abreviaturas, list):
        return '\\underset{' + \
               '}{\\pmb{\\tau}}\\underset{'.join([simbolo(i) for i in self.abreviaturas]) + \
               '}{\\pmb{\\tau}}'
              
\end{minted}

\section{La clase \texttt{T} completa}
\label{sec:orgb4ade53}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la clase T]{python}

class T:
    <<Texto de ayuda de la clase ~T~>>
    <<Inicialización de la clase ~T~>>
    <<Composición de Transformaciones Elementales o aplicación sobre las filas de una Matrix>>
    <<Operador transposición para la clase ~T~>>
    <<Método auxiliar que calcula la inversa de una Transformación elemental>>
    <<Potencia de una ~T~>>
    <<Transformación elemental espejo de una ~T~>>
    <<Sustitución de variables simbólicas en una Transformación elemental>>
    <<Métodos de la clase ~T~ para que actúe como si fuera una list de Python>>
    <<Representación de la clase ~T~>>

\end{minted}


\part{Las clases \texttt{SubEspacio} y  \texttt{EAfin}}
\label{sec:orgca6abb3}

\chapter{La clase \texttt{SubEspacio} (de \R[m])}
\label{sec:org0542e49}

El conjunto de vectores \Vect{x} que resuelven el sistema
\SEL{A}{x}{0} es un subespacio de \R[n]; y el conjunto de vectores
\Vect{x} que resuelven el sistema \SEL{A}{x}{b} con
\(\Vect{b}\ne\Vect{0}\) es un espacio afín de \R[n]. En este capítulo
vamos a definir objetos que representen estos subconjuntos de \R[n].

\section{La clase ~SubEspacio~ (de \R[m])} La clase \texttt{SubEspacio} se
puede instanciar tanto con un \texttt{Sistema} de \texttt{Vectores} como con una
\texttt{Matrix}.

En el primer caso, dado un \texttt{Sistema} de vectores, por ejemplo
\begin{displaymath}
  S=
  \left[
    \begin{pmatrix}0\\1\\0\end{pmatrix};\;
    \begin{pmatrix}2\\1\\3\end{pmatrix};\;
    \begin{pmatrix}2\\10\\3\end{pmatrix}
  \right],
\end{displaymath}
\texttt{SubEspacio( S )} corresponde al conjunto de combinaciones lineales de
los \texttt{Vectores} de dicho \texttt{Sistema}, representado por las siguientes
ecuaciones \emph{paramétricas}:
\begin{displaymath}
  \left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^2,\; \boldsymbol{v}= \begin{bmatrix}0&2\\1&0\\0&3\end{bmatrix}\boldsymbol{p}\right. \right\}\; 
\end{displaymath}
donde el vector \Vect{p} es el vector de parámetros.  En el segundo
caso, dada una \texttt{Matrix}, por ejemplo
\begin{displaymath}
  \;\Mat{M}=\begin{bmatrix}-3&0&2\\6&0&-4\end{bmatrix},\;
\end{displaymath}
\texttt{SubEspacio( M )} corresponde al conjunto de \texttt{Vectores} que son
solución al sistema de ecuaciones
\begin{math}
  \;\MV{M}{v}=\Vect{0};\;
\end{math}
y que se puede representar con el sistema de ecuaciones \emph{cartesianas}:
\begin{displaymath}
  \left\{
    \boldsymbol{v}\in\mathbb{R}^3\
    \left|
      \ \begin{bmatrix}-3&0&2\end{bmatrix}\boldsymbol{v}=\boldsymbol{0}
    \right\}
  \right.
\end{displaymath}
En ambos ejemplos corresponden al mismo subespacio de \R[3]; y, de
hecho, la librería muestra ambos tipos de representación para cada
\texttt{SubEspacio}: las ecuaciones paramétricas a la izquierda y las
cartesianas a la derecha.
\begin{displaymath}
  \left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^2,\; \boldsymbol{v}= \begin{bmatrix}0&2\\1&0\\0&3\end{bmatrix}\boldsymbol{p}\right. \right\}\; = \;\left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \begin{bmatrix}-3&0&2\end{bmatrix}\boldsymbol{v}=\boldsymbol{0}\right.\right\}
\end{displaymath}
\texttt{SubEspacio} tiene varios atributos.
\begin{itemize}
\item \texttt{dim}: dimensión del subespacio. En el ejemplo \texttt{dim=2}.
\item \texttt{Rn}: indica el espacio vectorial \R[n] al que pertenece
\texttt{SubEspacio(S)}. En el ejemplo anterior \texttt{Rn=3} puesto que es un
subespacio de \R[3].
\item \texttt{base}: una base del subespacio (un \texttt{Sistema} de \texttt{Vectores} de
\texttt{Rn}). Cuando \texttt{dim==0} base es un \texttt{Sistema} vacío.
\item \texttt{sgen}: Un \texttt{Sistema} de \texttt{Vectores} generador del subespacio. En
particular será el sistema de vectores correspondiente a la \texttt{Matrix}
de coeficientes empleada en la representación con ecuaciones
paramétricas. En el ejemplo Cuando \texttt{dim==0}, \texttt{sgen} contiene un
vector nulo de \texttt{Rm} componentes.
\begin{displaymath}
  \left[\begin{pmatrix}0\\1\\0\end{pmatrix};\;\begin{pmatrix}2\\0\\3\end{pmatrix};\right]
\end{displaymath}
\item \texttt{cart}: \texttt{Matrix} de coeficientes empleada en la representación con
las ecuaciones cartesianas. En el ejemplo
\begin{displaymath}
  \begin{bmatrix}
    -3 & 0 & 2
  \end{bmatrix}.
\end{displaymath}
\end{itemize}

\section{Implementación de \texttt{SubEspacio}}
\label{sec:orga59fb46}

La implementación requiere encontrar un \texttt{Sistema} base del
\texttt{SubEspacio} columna de una \texttt{Matrix} \texttt{A}. Lo haremos pre-escalonando
una \texttt{Matrix} \texttt{A} con \texttt{elim(0)} (así evitamos las fracciones en la medida
de lo posible). También necesitaremos encontrar un sistema generador
del un espacio nulo de \texttt{A}. Lo haremos con el método auxiliar
\texttt{SGenENulo}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la clase ~SubEspacio~]{python}
def __init__(self, data, sust=[], Rn=[]):
    """Inicializa un SubEspacio de Rn"""
    <<Método auxiliar ~sistema_generador_del_espacio_nulo_de~ una ~Matrix~>>
    if not isinstance(data, Sistema):
        raise ValueError(' Argumento debe ser un Sistema o Matrix ')
    
    if not data:
        if not Rn:
            raise ValueError(' Si el sistema es vacio, es necesario indicar el espacio Rn ')
        else:
            self.Rn = Rn
            self.__dict__ = SubEspacio(Sistema([self.vector_nulo()])).__dict__.copy()
        
    elif isinstance(data, Matrix):
        A         = data
        self.Rn   = Rn if Rn else A.n
        self.sgen = sistema_generador_del_espacio_nulo_de(A, sust, Rn)
        self.dim  = 0 if self.sgen.es_nulo() else len(self.sgen)
        self.base = self.sgen if self.dim else Sistema([])
        self.cart = SubEspacio(self.sgen, sust, self.Rn).cart

    else:
        if isinstance(data|1, BlockM):
            self.Rn = ((data|1).m, (data|1).n)
        elif isinstance(data|1, Sistema):
            self.Rn =  (data|1).n
            
        try:
            A = Matrix(data).subs(sust)
        except:
            A = BlockM([data]).subs(sust)
        self.base = Sistema([data|j for j,v in enumerate(A.elim(0), 1) if v.no_es_nulo()])
        self.dim  = len(self.base)
        self.sgen = self.base if self.base else Sistema([ self.vector_nulo() ])
        
        if isinstance(self.Rn, int):
            self.cart = ~Matrix(sistema_generador_del_espacio_nulo_de(~A, sust))
        elif isinstance(self.Rn, tuple):
            self.cart = SubEspacio(Sistema([m.vec() for m in self.sgen]), Rn=self.Rn).cart
    
\end{minted}

Las columnas de \texttt{E} correspondientes a los elementos nulos de \texttt{K} son
una base del espacio nulo.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método auxiliar ~sistema_generador_del_espacio_nulo_de~ una ~Matrix~]{python}

def sistema_generador_del_espacio_nulo_de(A, sust=[], Rn=[]):
    """Encuentra un sistema generador del Espacio Nulo de A"""
    K = A.K(0, sust);
    E = I(A.n) & T(K.pasos[1])
    lista = [ v.reshape(Rn) for j, v in enumerate(E,1) if (K|j).es_nulo(sust) ]
    return Sistema(lista) if lista else Sistema([self.vector_nulo()])

\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método auxiliar para establecer el vector nulo del subespacio]{python}

def vector_nulo(self):
    return M0(self.Rn[0],self.Rn[1]) if isinstance(self.Rn, tuple) else V0(self.Rn)

\end{minted}

\section{Métodos de la clase \texttt{SubEspacio}}
\label{sec:orgb95c97c}
Definimos un método que nos indique si es cierto que un \texttt{SubEspacio}
está contenido en otro (\texttt{contenido\_en}). Si \texttt{A} y \texttt{B} son
\texttt{SubEspacios}, la siguiente expresión
\begin{center}
  \Verb/A.contenido_en(B)/
\end{center}
nos dirá si es cierto que \texttt{A} es un \texttt{SubEspacio} de \texttt{B}.

Para comprobar si un \texttt{SubEspacio} \texttt{A} está contenido en un
\texttt{SubEspacio} \texttt{B}, basta verificar si todos los vectores del sistema
generador de \texttt{A} son solución de las ecuaciones cartesianas de \texttt{B}. Si
\texttt{B} es un \texttt{EAfin}, entonces \texttt{B.v} debe ser nulo y \texttt{A} debe estar
contenido en \texttt{B.S}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def contenido_en(self, other):
    """Indica si este SubEspacio está contenido en other"""
    self.verificacion(other)
    if isinstance(other, SubEspacio):
        if isinstance(self.sgen|1, Vector):
            return all ([ (other.cart*v).es_nulo() for v in self.sgen ])
        elif isinstance(self.sgen|1, Matrix):
            return all ([ (other.cart*v.vec()).es_nulo() for v in self.sgen ])
        
    elif isinstance(other, EAfin):
        return other.v.es_nulo() and self.contenido_en(other.S)

\end{minted}

También definimos dos métodos (mágicos) que nos indican
\begin{itemize}
\item si dos \texttt{SubEspacios} son iguales (\texttt{\_\_eq\_\_}), es decir, que \texttt{A} esta
contenido en \texttt{B} y viceversa; o
\item si son distintos (\texttt{\_\_ne\_\_}), es decir, que no son iguales.
\end{itemize}

Así podemos usar las siguientes expresiones booleanas
\begin{center}
\Verb/A == B/
\quad y \quad
\Verb/A != B/
\end{center}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __eq__(self, other):
    """Indica si un subespacio de Rn es igual a otro"""
    self.verificacion(other)
    return self.contenido_en(other) and other.contenido_en(self)

def __ne__(self, other):
    """Indica si un subespacio de Rn es distinto de otro"""
    self.verificacion(other)
    return not (self == other)

\end{minted}

Para que estos tres métodos funcionen es necesario un método auxiliar
que realice la \texttt{verificacion} de que los dos argumentos son
\texttt{SubEspacios} o \texttt{EAfines} del mismo espacio vectorial \R[m] (como este
método tampoco es mágico, se invoca con \texttt{self.verificacion()}).


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def verificacion(self,other):
    if not isinstance(other, (SubEspacio, EAfin)) or  not self.Rn == other.Rn: 
        raise \
         ValueError('Ambos argumentos deben ser subconjuntos de en un mismo espacio')

\end{minted}

El método suma \texttt{A + B} arroja la suma de dos \texttt{SubEspacios} de \R[m]
(el es subespacio generado por la concatenación de los respectivos
sistemas generadores).


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __add__(self, other):
    """Devuelve la suma de subespacios de Rn"""
    self.verificacion(other)
    return SubEspacio(self.sgen.concatena(other.sgen))

\end{minted}

y definimos otro método que nos devuelva la intersección: \texttt{A \& B}. 

Si \texttt{other} es un \texttt{EAfin} llamamos al método de la intersección entre
un \texttt{EAfin} y un \texttt{SubEspacio}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __and__(self, other):
    """Devuelve la intersección de subespacios"""
    self.verificacion(other)
    
    if isinstance(other, SubEspacio):
        A  = self.base
        B  = other.base
        AB = A.concatena(B)
        X  = slice(1,self.dim)|Matrix(AB.espacio_nulo().sgen)
        return SubEspacio(A*X)
    
    elif  isinstance(other, EAfin):
        return other & self

\end{minted}

Con \texttt{\textasciitilde{}A} obtenemos el complemento ortogonal (el \texttt{SubEspacio} generado
por las filas de \texttt{self.cart})


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __invert__(self):
    """Devuelve el complemento ortogonal"""
    if isinstance(self.sgen|1, Vector):
        return SubEspacio( Sistema( ~(self.cart) ) )
    
    elif isinstance(self.sgen|1, Matrix):
        return SubEspacio(Sistema([v.reshape(self.Rn) for v in ~(self.cart)]))
    
\end{minted}

\noindent Finalmente definimos un método para saber si un \texttt{Vector x}
pertenece a un \texttt{SubEspacio A} (basta verificar si \texttt{x} es solución del
sistema de ecuaciones cartesianas). Obtenemos la respuesta con
\begin{center}
  \Verb/ x in A /
\end{center}


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __contains__(self, other):
    """Indica si un Vector pertenece a un SubEspacio"""

    if isinstance(self.sgen|1, Vector):
        if not isinstance(other, Vector) or other.n != self.Rn:
            raise ValueError\
                ('El Vector no tiene el número adecuado de componentes')
        return self.cart*other == V0(self.cart.m)
    
    elif isinstance(self.sgen|1, Matrix):
        if not isinstance(other, Matrix) or (other.n,other.m) != self.Rn:
            raise ValueError\
                ('El Vector no tiene el número adecuado de componentes')        
        return self.cart*other.vec() == V0(self.cart.m)
    

\end{minted}

\section{Métodos de representación de la clase \texttt{SubEspacio}}
\label{sec:org455965f}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación de la clase ~SubEspacio~]{python}

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def EcParametricas(self, d=0):
    """Representación paramétrica del SubEspacio"""
    if d: display(Math(self.EcParametricas()))
    return EAfin(self.sgen, self.vector_nulo()).EcParametricas()

def EcCartesianas(self, d=0):
    """Representación cartesiana del SubEspacio"""
    if d: display(Math(self.EcCartesianas()))
    return EAfin(self.sgen, self.vector_nulo()).EcCartesianas()
    
def latex(self):
    """ Construye el comando LaTeX para un SubEspacio de Rn"""
    return EAfin(self.sgen, self.vector_nulo()).latex()       

\end{minted}

\section{La clase \texttt{SubEspacio} completa}
\label{sec:org2a8686b}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la clase ~SubEspacio~]{python}

class SubEspacio:
    <<Inicialización de la clase ~SubEspacio~>>
    <<Método auxiliar para establecer el vector nulo del subespacio>>
    <<Métodos de la clase ~SubEspacio~>>
    <<Métodos de representación de la clase ~SubEspacio~>>

\end{minted}


\chapter{La clase \texttt{EAfin} (de \R[m])}
\label{sec:org2e87a64}

El conjunto de soluciones de un sistema de ecuaciones homogéneo
\SEL{A}{x}{0} forma un subespacio (que llamamos espacio nulo
\nulls{A}), pero el conjunto de soluciones de \SEL{A}{x}{b} cuando
\(\Vect{b}\ne\Vect{0}\) es un \emph{espacio afín}.


\section{Implementación de \texttt{EAfin}}
\label{sec:org9d78d5e}

Vamos a crear la clase \texttt{EAfin}. La definiremos como un par
\((\EV{S},\Vect{v})\) cuyo primer elemento, \EV{S}, sea un \texttt{SubEspacio}
(el conjunto de soluciones a \SEL{A}{x}{0}) y cuyo segundo elemento,
\Vect{v}, sea un vector del espacio afín (una solución particular de
\SEL{A}{x}{b}). En el atributo \texttt{S} guardaremos el \texttt{SubEspacio} y en el
atributo \texttt{v} un \texttt{Vector}. Así, pues, para instanciar un \texttt{EAfin}
usaremos dos argumentos: el primero será un \texttt{Sistema} formado por
\texttt{Vectores} (típicamente una \texttt{Matrix}) con la que formar el
\texttt{SubEspacio}, y el segundo será un \texttt{Vector}.


Cuando \(\Vect{v}\in\EV{S}\), el espacio afín es un subespacio (que por
tanto contiene al vector nulo). Así que si \(\Vect{v}\in\EV{S}\) en el
atributo \texttt{v} guardaremos el vector nulo. Así, si consideramos el
sistema ``ampliado'' que contiene los vectores del sistema generador
de \texttt{S} primero, y \texttt{v} como último vector \texttt{v}, y aplicamos el método de
eliminación de izquierda a derecha; el último vector tras la
eliminación pertenece al espacio afín, y será cero si
\(\Vect{v}\in\EV{S}\). Si \texttt{vi} es cero (su valor por defecto), en
\texttt{self.v} se guardará el vector resultante tras la eliminación, en caso
contrario se guardará el vector indicado (\texttt{vi}) como argumento.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Inicialización de la clase ~EAfin~]{python}

def __init__(self, data, v, vi=0):
    """Inicializa un Espacio Afín de Rn"""
    self.S  = data if isinstance(data, SubEspacio) else SubEspacio(data)
    self.Rn = self.S.Rn
    
    if isinstance(self.Rn, int):
        if not isinstance(v, Vector) or v.n != self.Rn:
            raise ValueError('v y SubEspacio deben estar en el mismo espacio vectorial')
        
    elif isinstance(self.Rn, tuple):
        if not isinstance(v, Matrix) or (v.m,v.n) != self.Rn:
            raise ValueError('v y SubEspacio deben estar en el mismo espacio vectorial')
        
    self.v  = v if vi else (self.S.sgen.concatena(Sistema([v]))).elim(1)|0
    
\end{minted}


\section{Métodos de la clase \texttt{EAfin}}
\label{sec:org18c73be}
Un vector \Vect{x} pertenece al espacio afín \EV{S} si verifica las
ecuaciones cartesianas, cuya matriz de coeficientes es \texttt{self.S.cart},
y cuyo vector del lado derecho es \texttt{(self.S.cart)*self.v}. Así pues


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __contains__(self, other):
    """Indica si un Vector pertenece a un EAfin"""
    if isinstance(self.S.sgen|1, Vector):
        if not isinstance(other, Vector) or other.n != self.Rn:
            raise ValueError\
                ('El Vector no tiene el número adecuado de componentes')
        return self.S.cart*other == (self.S.cart)*self.v
    
    elif isinstance(self.S.sgen|1, Matrix):
        if not isinstance(other, Matrix) or (other.n,other.m) != self.Rn:
            raise ValueError\
                ('La matrix no tiene el orden adecuado')        
        return self.S.cart*other.vec() == self.S.cart*self.v.vec()

\end{minted}



\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def contenido_en(self, other):
    """Indica si este EAfin está contenido en other"""
    self.verificacion(other)
    
    if isinstance(other, SubEspacio):
        return self.v in other and self.S.contenido_en(other)
    
    elif isinstance(other, EAfin):
         return self.v in other and self.S.contenido_en(other.S)

\end{minted}



\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __eq__(self, other):
    """Indica si un EAfin de Rn es igual a other"""
    self.verificacion(other)
    return self.contenido_en(other) and other.contenido_en(self)

def __ne__(self, other):
    """Indica si un subespacio de Rn es distinto de other"""
    return not (self == other)

\end{minted}



\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def verificacion(self,other):
    if not isinstance(other, (SubEspacio, EAfin)) or  not self.Rn == other.Rn: 
        raise ValueError('Ambos argumentos deben ser subconjuntos de en un mismo espacio')

\end{minted}

La intersección es el conjunto de soluciones a ambos sistemas de
ecuaciones cartesianas. El modo más sencillo es unificar ambos
sistemas en uno solo: apilando las matrices de coeficientes por un
lado y concatenando los vectores del lado derecho por el otro.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __and__(self, other):
    """Devuelve la intersección de este EAfin con other"""
    self.verificacion(other)
    if isinstance(other, EAfin):
        M = self.S.cart.apila( other.S.cart )
        if isinstance(self.S.sgen|1, Vector):
            w = (self.S.cart*self.v).concatena( other.S.cart*other.v )
        elif isinstance(self.S.sgen|1, Matrix):
            w = (self.S.cart*self.v.vec()).concatena( other.S.cart*other.v.vec() )
    elif isinstance(other, SubEspacio):
        M = self.S.cart.apila( other.cart )
        if isinstance(self.S.sgen|1, Vector):
            w = (self.S.cart*self.v).concatena( V0(other.cart.m) )                                                      
        elif isinstance(self.S.sgen|1, Matrix):
            w = (self.S.cart*self.v.vec()).concatena( V0(other.cart.m) )
            
    return SEL(M,w).eafin

\end{minted}

Con \texttt{\textasciitilde{}A} obtendremos el mayor \texttt{SubEspacio} perpendicular a \texttt{A}.


\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def __invert__(self):
    """Devuelve el mayor SubEspacio perpendicular a self"""
    return SubEspacio( Sistema([v.reshape(self.Rn) for v in ~(self.S.cart)]))

\end{minted}


\section{Métodos de representación de la clase \texttt{EAfin}}
\label{sec:orga16d909}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación de la clase ~EAfin~]{python}

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def EcParametricas(self, d=0):
    """Representación paramétrica de EAfin"""
    punto = latex(self.v) + '+' if (self.v != 0*self.v) else ''
    if d: display(Math(self.EcParametricas()))
    if isinstance(self.S.Rn,int):
        return r'\left\{ \boldsymbol{v}\in\mathbb{R}^' \
            + latex(self.S.Rn)  \
            + r'\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^' \
            + latex(max(self.S.dim,1)) \
            + r',\; \boldsymbol{v}= ' \
            + punto \
            + latex(Matrix(self.S.sgen)) \
            + r'\boldsymbol{p}\right. \right\}' 
    else:
        return r'\left\{ \pmb{\mathsf{M}}\in\mathbb{R}^{' \
            + latex(self.S.Rn[0]) + r'\times' + latex(self.S.Rn[1]) + '}' \
            + r'\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^' \
            + latex(max(self.S.dim,1)) \
            + r',\; \mathsf{\pmb{M}}= ' \
            + punto \
            + latex(self.S.sgen) \
            + r'\boldsymbol{p}\right. \right\}' 
                    
def EcCartesianas(self, d=0):
    """Representación cartesiana de EAfin"""
    if d: display(Math(self.EcCartesianas()))
    if isinstance(self.S.Rn,int):
        return r'\left\{ \boldsymbol{v}\in\mathbb{R}^' \
            + latex(self.S.Rn) \
            + r'\ \left|\ ' \
            + latex(self.S.cart) \
            + r'\boldsymbol{v}=' \
            + latex(self.S.cart*self.v) \
            + r'\right.\right\}' 
    else:
        return r'\left\{ \mathsf{\pmb{M}}\in\mathbb{R}^{' \
            + latex(self.S.Rn[0]) + r'\times' + latex(self.S.Rn[1]) + '}' \
            + r'\ \left|\ ' \
            + latex(self.S.cart) \
            + r'vec(\mathsf{\pmb{M}})=' \
            + latex(self.S.cart*self.v.vec()) \
            + r'\right.\right\}' 
    
def latex(self):
    """ Construye el comando LaTeX para un EAfin de Rn"""
    return self.EcParametricas() + '\\; = \\;' + self.EcCartesianas()
        
\end{minted}


\section{La clase \texttt{EAfin} completa}
\label{sec:org54b2128}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la clase ~EAfin~]{python}

class EAfin:
    <<Inicialización de la clase ~EAfin~>>
    <<Métodos de la clase ~EAfin~>>
    <<Métodos de representación de la clase ~EAfin~>>
    
\end{minted}


\part{Las clases \texttt{Homogenea} y  \texttt{SEL}}
\label{sec:org4fb2a72}

\chapter{Resolución de sistemas de ecuaciones homogéneos. La clase  \texttt{Homogenea}}
\label{sec:org758cd10}

El siguiente código devuelve el conjunto de soluciones de un sistema homogéneo \SEL{A}{x}{0}. Descripción de los atributos:
\begin{itemize}
\item \texttt{sgen} es un sistema generador del espacio nulo \nulls{A}.
\item \texttt{determinado} indica si es cierto que el sistema es determinado (una única solución)
\item \texttt{tex} es la cadena de texto \LaTeX que representa los pasos dados
para resolver el sistema.
\end{itemize}

\section{Implementación de la clase \texttt{Homogenea}}
\label{sec:org4b7e676}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Resolución de un sistema de ecuaciones homogéneo]{python}

class Homogenea:
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Resuelve un Sistema de Ecuaciones Lineales Homogéneo
        
        y muestra los pasos para encontrarlo"""
        try:
            A = Matrix(sistema).subs(sust)
        except:
            A = BlockM([sistema]).subs(sust)

        MA = A.apila(I(A.n),1)
        MA.corteElementos.update({sistema.n+A.m})

        K    = A.K(0, sust)  
        E    = I(A.n) & T(K.pasos[1])
        
        self.base        = Sistema([ v for j, v in enumerate(E,1) if (K|j).es_nulo(sust) ])
        self.sgen        = self.base if self.base else Sistema([ V0(sistema.n) ])
        self.determinado = (len(self.base) == 0)
        self.pasos       = K.pasos; 
        self.TrF         = K.TrF 
        self.TrC         = K.TrC

        self.enulo       = SubEspacio(self.sgen)
        
        if repsust:
            self.tex         = rprElim( A.apila( I(A.n) ,1 ) , self.pasos, [], sust)
        else:
            self.tex         = rprElim( A.apila( I(A.n) ,1 ) , self.pasos)
            
        if rep:
            display(Math(self.tex))
            
    <<Métodos de representación de la clase ~Homogenea~>>   
    
\end{minted}

La base la constituyen los vectores \texttt{v} de \texttt{E} que corresponden a los
vectores nulos de \texttt{K}:


\section{Métodos de representación de la clase \texttt{Homogenea}}
\label{sec:orgf1c8a6c}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación de la clase ~Homogenea~]{python}

def __repr__(self):
    """Muestra el Espacio Nulo de una matriz en su representación Python"""
    return 'Combinaciones lineales de (' + repr(self.sgen) + ')'

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para la solución de un Sistema Homogéneo"""
    if self.determinado:
        return '\\left\\{\ ' + latex(self.sgen|1) + '\ \\right\\}'
    else:
        return '\\mathcal{L}\\left(\ ' + latex(self.sgen) + '\ \\right)' 

\end{minted}


\chapter{Resolución de sistemas de ecuaciones lineales. La clase  \texttt{SEL}}
\label{sec:orgdfd72d5}

\section{Implementación}
\label{sec:org01a70b8}
\subsection{Texto de ayuda}
\label{sec:org09ee728}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Texto de ayuda de la clase ~SEL~]{python}
"""Resuelve un Sistema de Ecuaciones Lineales

mediante eliminación con el sistema ampliado y muestra los pasos
dados

"""
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Resolución de un Sistema de Ecuaciones Lineales]{python}
class SEL:
    def __init__(self, sistema, b, rep=0, sust=[], repsust=0):
        <<Texto de ayuda de la clase ~SEL~>>
        try:
            A = Matrix(sistema.amplia(-b)).subs(sust).csis({sistema.n})
        except:
            A = BlockM([sistema.amplia(-b)]).subs(sust).csis({sistema.n})
            
        MA = A.apila(I(A.n),1)
        MA.corteElementos.update({sistema.n+A.m})
        operaciones = A.elim(0,False,sust).pasos[1]
        
        <<Aplicamos los ~pasos~ de eliminación sobre la matriz ampliada y obtenemos la solución>>
        
    <<Métodos de representación de la clase ~SEL~>>
    
\end{minted}

Aplicamos los pasos sobre toda la matriz ampliada (más bien ``super
ampliada'', pues tiene una matriz identidad por debajo). Si el último
elemento de la última columna es nulo debajo vemos la solución.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Aplicamos los ~pasos~ de eliminación sobre la matriz ampliada y obtenemos la solución]{python}

E         = I(sistema.n) & T(operaciones)

testigo   = 0| (I(A.n) & T(operaciones)) |0
Normaliza = T([]) if testigo==1 else T([( fracc(1,testigo), A.n )])
pasos     = [[], operaciones+[Normaliza] ] if Normaliza else [[], operaciones]

K         = A & T(operaciones)

self.base        = Sistema([ v for j, v in enumerate(E,1) if (K|j).es_nulo(sust) ])
self.sgen        = self.base if self.base else Sistema([ V0(sistema.n) ])
self.determinado = (len(self.base) == 0)
self.pasos       = pasos 
self.TrF         = T(self.pasos[0]) 
self.TrC         = T(self.pasos[1])

if (K|0).no_es_nulo():
    self.solP  = set()
    self.eafin = set()
else:
    self.solP  = (I(sistema.n).amplia(V0(sistema.n)) & T(pasos[1]))|0 
    self.eafin = EAfin(self.sgen, self.solP, 1)

if repsust:
    self.tex     = rprElim( MA, self.pasos, [], sust )
else:
    self.tex     = rprElim( MA, self.pasos)

if rep:
    display(Math(self.tex))           

\end{minted}

\section{Métodos de representación de la clase \texttt{SEL}}
\label{sec:orgcfa79ab}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación de la clase ~SEL~]{python}

def __repr__(self):
    """Muestra el Espacio Nulo de una matriz en su representación Python"""
    return repr(self.solP) + ' + Combinaciones lineales de (' + repr(self.sgen) + ')'

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para la solución de un Sistema Homogéneo"""
    if self.determinado and self.solP:
        return '\\left\\{\ ' + latex(self.solP) + '\ \\right\\}'
    else:
        return self.eafin.EcParametricas() if self.solP else '\\emptyset' #latex(set())

\end{minted}


\part{La clase \texttt{Determinante}. Cálculo del determinante por eliminación Gaussiana}
\label{sec:org3a2ef92}

\subsection{Método de inicialización}
\label{sec:orge4211a1}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Definición de la clase Determinante]{python}
class Determinante:
   """Determinante de una Matrix mediante eliminación Gaussiana por columnas
   
   La representación muestra los pasos dados
   
   """
   def __init__(self, data, disp=0, sust=[]):
      <<Cálculo del determinante>>
      
      A  = Matrix(data.subs(sust))
      
      if not A.es_cuadrada():  raise ValueError('Matrix no cuadrada')
      
      self.tex, self.valor, self.pasos = calculoDet( A.subs(sust) )
      
      if disp:
         display(Math(self.tex))

   <<Métodos de representación de la clase Determinante>>
         
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Cálculo del determinante]{python}

def calculoDet(A, sust=[]):
    
    producto  = lambda x: 1 if not x else x[0] * producto(x[1:])
    
    def productos_realizados(operaciones):
        P = [ producto([-1 if isinstance(abv,set) else abv[0] \
                        for op in paso for abv in filter( lambda x: len(x)==2, op.abreviaturas)]) for paso in operaciones]
        return P
    
    operacionesEnColumnas = (A.L(0,sust).pasos[1])
    operacionesEnFilas    = [T((fracc(1,d),A.n+1)) for d in productos_realizados(operacionesEnColumnas)]
    pasos                 = [operacionesEnFilas, operacionesEnColumnas]
    
    matrixExtendida       = T(operacionesEnFilas) & A.extDiag(I(1),1) & T(operacionesEnColumnas)
    
    determinante          = sympy.sympify( producto( matrixExtendida.diag() ) ).simplify()
    
    tex                   = rprElimFyC( A.extDiag(I(1),1), pasos)
    
    return [tex, determinante, pasos]
    
\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos de representación de la clase Determinante]{python}

def __repr__(self):
   """Muestra un Sistema en su representación Python"""
   return 'Valor del determinante: ' + repr (self.valor)

def _repr_html_(self):
   """Construye la representación para el entorno Jupyter Notebook"""
   return html(self.latex())

def latex(self):
   """Construye el comando LaTeX para representar un Sistema"""
   return latex(self.valor)

\end{minted}


\part{Librería completa}
\label{sec:org150b880}

Finalmente creamos la librería \texttt{nacal.py} concatenando los trozos de
código que se describen en este fichero de documentación.

Importamos el módulo \href{https://www.sympy.org/en/index.html}{Sympy} con el código:
\begin{center}
~import sympy~
\end{center}
Así podremos usar números racionales e irracionales (incluso el cuerpo
de polinomios). 

Como queremos que la librería emplee números racionales siempre que
sea posible, definimos tres métodos generales: \texttt{fracc(a/b)} es la
fracción \(\frac{a}{b}\); \texttt{numer(a,b)}; y \texttt{denom(a,b)} (véase la página
siguiente). Para usar el número racional \(\frac{1}{3}\) escribiremos
\texttt{fracc(1,3)}, y para usar un número irracional como \(\sqrt{2}\)
escribimos \texttt{sympy.sqrt(2)}. 

El módulo \href{https://www.sympy.org/en/index.html}{Sympy} se ocupa de que Jupyter represente adecuadamente estos
objetos (incluso simplificando expresiones, de manera que si
escribimos el número irracional \texttt{fracc(2,sympy.sqrt(2))}, es decir
\(\frac{2}{\sqrt{2}}\), Jupyter lo simplificara representándolo como
\(\sqrt{2}\)).

Para poder trabajar con los Notebooks en Emacs importamos los métodos
\texttt{display}, \texttt{Math} y \texttt{display\_png} del módulo \texttt{IPython.display}.

Para generar las imágenes \texttt{png} con las expresiones en \LaTeX{} en un
directorio temporal importamos \texttt{tempfile}
También importamos el método \texttt{join} del módulo \texttt{os.path}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
# coding=utf8
import sympy
from IPython.display import display, Math, display_png
import tempfile
from os.path import join           

<<Consideracion de qué es un número>>
<<Métodos para usar coeficientes racionales cuando sea posible>>
<<Método html general>>
<<Método latex general>>
<<Pinta un objeto en Jupyter>>
<<Método auxiliar CreaLista que devuelve listas>>
<<Método auxiliar CreaSistema que devuelve sistemas>>
<<Métodos primer_no_nulo y ultimo_no_nulo de un Sistema>>
<<Otros métodos auxilares>>
<<Cribado de secuencias de transformaciones>>
<<Simplificación de expresiones simbólicas>>
<<Representación de un proceso de eliminación rprElim>>
<<Representación de un proceso de eliminación rprElimFyC>>
<<Representación de un proceso de eliminación rprElimCF>>
<<Representación de un proceso de eliminación dispElim, dispElimFyC y dispElimCF>>

<<Definición de la clase Sistema>>
<<Definición de la subclase BlockV>>
<<Definición de la subclase Vector>>
<<Definición de las subclases V0 y V1>>
<<Definición de la subclase BlockM>>
<<Definición de la subclase Matrix>>
<<Definición de las subclases M0, M1 e I>>

<<Consideracion de qué es una secuencia>>

<<Definición de la clase T>>

<<Definición de la clase ~SubEspacio~>>
<<Definición de la clase ~EAfin~>>

<<Resolución de un sistema de ecuaciones homogéneo>>
<<Resolución de un Sistema de Ecuaciones Lineales>>

<<Definición de la clase Determinante>>

<<Definición de las subclases ElimX>>
<<Definición de las subclases InvMatX>>
<<Definición de las subclases DiagonalizaX>>
\end{minted}


\chapter{Métodos generales}
\label{sec:orga63eed7}

\section{Números}
\label{sec:org32459c1}

Consideraremos como números los enteros, los números de coma flotante,
los números complejos, y toda la familia de objetos de tipo \href{https://docs.sympy.org/latest/modules/core.html\#sympy.core.basic.Basic}{\texttt{Basic}}
del módulo \href{https://docs.sympy.org/latest/index.html}{Sympy}, lo que nos permite trabajar con números racionales,
muchos números reales y con expresiones simbólicas.
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Consideracion de qué es un número]{python}
NumberTypes = (int, float, complex, sympy.Basic)
es_numero   = lambda x: isinstance(x, NumberTypes) and not isinstance(x, bool)
\end{minted}

\section{Números racionales}
\label{sec:org197eada}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos para usar coeficientes racionales cuando sea posible]{python}

def fracc(a,b):
    """Transforma la fracción a/b en un número racional si ello es posible"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return sympy.Rational(a, b)
    else:
        return a/b
    
def numer(a,b):
    """Devuelve el numerador de a/b si la fracción es un número racional,
       si no devuelve a/b"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return fracc(a,b).p
    else:
        return a/b 

def denom(a,b):
    """Devuelve el denominador de a/b si la fracción es un número
       racional, si no devuelve 1"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return fracc(a,b).q
    else:
        return 1

\end{minted}

\section{Ristras}
\label{sec:org4573279}

Según el diccionario de la Real Academia Española una \href{https://dle.rae.es/ristra}{\emph{ristra}} es un
\emph{conjunto de ciertas cosas colocadas unas tras otras}; por ello,
denominamos genéricamente ``ristra'' a cualquier objeto de tipo
\texttt{list}, \texttt{tuple} o \texttt{Sistema}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Consideracion de qué es una secuencia]{python}
RistraTypes = (tuple, list, Sistema)
es_ristra  = lambda x: isinstance(x, RistraTypes) 

def es_ristra_de_numeros(arg):
    return all( [es_numero(elemento) for elemento in arg] ) if es_ristra(arg) else None

\end{minted}
\section{Métodos de representación para el entorno Jupyter}
\label{sec:orgf634e5f}

El método \texttt{html}, escribe el inicio y el final de un párrafo en html y
en medio del párrafo escribirá la cadena \texttt{TeX}; que contendrá el
código \LaTeX{} de las expresiones matemáticas que queremos que se
muestren en pantalla cuando usamos \href{https://jupyter.org/}{Jupyter Notebook}. En el navegador,
la librería \href{https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Typesetting\%20Equations.html}{MathJax} de Javascript se encargará de convertir la
expresión \LaTeX{} en la grafía correspondiente.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método html general]{python}

def html(TeX):
    """ Plantilla HTML para insertar comandos LaTeX """
    return "<p style=\"text-align:center;\">$" + TeX + "$</p>"
    
\end{minted}

El método \texttt{latex} general, intentará llamar al método \texttt{latex}
particular del objeto que se quiere representar (para todos los
objetos de esta librería se define su método de representación). Si el
objeto no tiene definido el método \texttt{latex}, entonces se emplea el
método \texttt{sympy.latex()} del módulo \href{https://www.sympy.org/en/index.html}{Sympy}. Así,

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
Sistema([ sympy.Rational(1.5, 3), fracc(2.4, 1.2), fracc(2, sympy.sqrt(2)) ]) 
\end{minted}
donde las componentes se han escrito explícitamente como 
\begin{displaymath}
\frac{1.5}{3},\quad
\frac{2.4}{1.2},\quad\text{y}\quad
\frac{2}{\sqrt{2}},\quad
\end{displaymath}
será representado como
$$\left[ \begin{array}{ccc}\frac{1}{2};& 2;& \sqrt{2};\end{array} \right]$$

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método latex general]{python}

def latex(a):
    """Método latex general"""
    try:
        return a.latex()
    except:
        return sympy.latex(a)
    
\end{minted}

Para visualizar un objeto en su formato \LaTeX{} definimos el método \texttt{pinta}.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Pinta un objeto en Jupyter]{python}

def pinta(data):
    """Muestra en Jupyter la representación latex de data"""
    display(Math(latex(data)))

\end{minted}

Por ejemplo, compárese lo que devuelve \texttt{pinta}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
pinta( Vector([sympy.sqrt(2), 0, fracc(3, 4) ]) )
\end{minted}

\(\displaystyle \begin{pmatrix}\sqrt{2}\\ 0\\ \frac{3}{4}\end{pmatrix}\)

con lo que devuelve \texttt{print}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}
print( Vector([sympy.sqrt(2), 0, fracc(3, 4) ]) ) 
\end{minted}

Vector([sqrt(2), 0, 3/4])

\section{Métodos \texttt{CreaLista} y \texttt{CreaSistema}}
\label{sec:orga51f2e6}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método auxiliar CreaLista que devuelve listas]{python}

def CreaLista(t):
    """Devuelve t si t es una lista; si no devuelve la lista [t]"""
    return t if isinstance(t, list) else [t]

\end{minted}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Método auxiliar CreaSistema que devuelve sistemas]{python}

def CreaSistema(t):
    """Devuelve t si t es un Sistema; si no devuelve un Sistema que contiene t"""
    return t if isinstance(t, Sistema) else Sistema(CreaLista(t))

\end{minted}

\section{Métodos \texttt{primer\_no\_nulo} y \texttt{ultimo\_no\_nulo} de un Sistema}
\label{sec:org77300e7}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Métodos primer_no_nulo y ultimo_no_nulo de un Sistema]{python}

def primer_no_nulo(s):
    """Primer elemento no nulo en un sistema de sistemas de números"""
    c = [] if es_numero(s) else s.primer_no_nulo()
    return c + primer_no_nulo(CreaSistema(s)|c[0]) if c!=[] else []

def ultimo_no_nulo(s):
    """Primer elemento no nulo en un sistema de sistemas de números"""
    c = [] if es_numero(s) else s.ultimo_no_nulo()
    return c + ultimo_no_nulo(CreaSistema(s)|c[0]) if c!=[] else []

def elementoPivote(s):
    """Primer elemento no nulo"""
    if es_numero(s):
        return s
    elif CreaSistema(s).elementoPivote():
        return elementoPivote(CreaSistema(s).extractor(CreaSistema(s).primer_no_nulo()))
    else:
        None

def elementoAntiPivote(s):
    """Último elemento no nulo"""
    if es_numero(s):
        return s
    elif CreaSistema(s).elementoAntiPivote():
        return elementoAntiPivote(CreaSistema(s).extractor(CreaSistema(s).ultimo_no_nulo()))
    else:
        None

\end{minted}

\section{Otros métodos auxilares}
\label{sec:org092d2f9}
\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=]{python}

def particion(s,n):
    """ genera la lista de particionamiento a partir de un conjunto y un número
    >>> particion({1,3,5},7)

    [[1], [2, 3], [4, 5], [6, 7]]
    """
    s = {e for e in s if e<=n}
    p = sorted(list(s | set([0,n])))
    return [ list(range(p[k]+1,p[k+1]+1)) for k in range(len(p)-1) ]
    
\end{minted}

\section{Cribado de secuencias de transformaciones}
\label{sec:orgce2afb5}

En el proceso de eliminación, muchas trasformaciones elementales
realmente son identidades (sumar 0 veces otro vector y multiplicar un
vector por 1).

A la hora de representar los pasos de eliminación, normalmente es
mejor omitir estos pasos innecesarios. Definimos un procedimiento
general que quita de una lista de abreviaturas aquellas que son
innecesarias en la representación. Si como argumento se le da una
lista de abreviaturas, devuelve una lista filtrada. Si como argumento
se le da una \texttt{T}ransformación, devuelve una
\texttt{T}ransformación cuya lista de abreviaturas está filtrada.

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Cribado de secuencias de transformaciones]{python}

def filtradopasos(pasos):
    abv = pasos.abreviaturas if isinstance(pasos,T) else pasos
           
    p = [T([j for j in T([abv[i]]).abreviaturas if (isinstance(j,set) and len(j)>1)\
               or (isinstance(j,tuple) and len(j)==3 and j[0]!=0)       \
               or (isinstance(j,tuple) and len(j)==2 and j[0]!=1) ])    \
                                             for i in range(0,len(abv)) ]

    abv = [ t for t in p if t.abreviaturas] # quitamos abreviaturas vacías de la lista
    
    return T(abv) if isinstance(pasos,T) else abv

\end{minted}

\section{Simplificación de expresiones simbólicas}
\label{sec:orga2d717b}

\begin{minted}[frame=lines,fontsize=\scriptsize,linenos,label=Simplificación de expresiones simbólicas]{python}

def simplify(self):
    """Devuelve las expresiones simplificadas"""
    if isinstance(self, (list, tuple)):
        return type(self)([ simplify(e) for e in self ])
    elif isinstance(self, Sistema):
        self.lista=[ simplify(e) for e in self ]
        return self
    elif isinstance(self, T):
        self.abreviaturas=[ simplify(op) for op in self.abreviaturas ]
        return self
    else:
        return (sympy.sympify(self)).simplify()
    
def factor(self):
    """Devuelve las expresiones factorizadas"""
    if isinstance(self, (list, tuple)):
        return type(self)([ factor(e) for e in self ])
    elif isinstance(self, Sistema):
        self.lista=[ factor(e) for e in self ]
        return self
    elif isinstance(self, T):
        self.abreviaturas=[ factor(op) for op in self.abreviaturas ]
        return self
    else:
        return sympy.factor(self)

def expand(self):
    """Devuelve las expresiones factorizadas"""
    if isinstance(self, (list, tuple)):
        return type(self)([ expand(e) for e in self ])
    elif isinstance(self, Sistema):
        self.lista=[ expand(e) for e in self ]
        return self
    elif isinstance(self, T):
        self.abreviaturas=[ expand(op) for op in self.abreviaturas ]
        return self
    else:
        return sympy.expand(self)

\end{minted}
\end{document}