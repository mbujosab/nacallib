#+TITLE: Lección 23 - Lanzamiento de monedas
#+AUTHOR: Marcos Bujosa
#+LANGUAGE: es-es
# +STARTUP: show3levels
# +STARTUP: latexpreview

# +LaTeX_HEADER: \input{notacionLinAlg.latex}
#+LaTeX_HEADER: \newcommand{\R}[1][{}]{{\mathbb{R}}^{#1}}
#+LaTeX_HEADER: \newcommand{\Z}[1][{}]{{\mathbb{Z}}^{#1}}
#+LaTeX_HEADER: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#+LaTeX_HEADER: \newcommand{\getItem}{\pmb{\mid}}
#+LaTeX_HEADER: \newcommand{\getitemR}[1]{\getItem{#1}}
#+LaTeX_HEADER: \newcommand{\getitemL}[1]{{#1}\getItem}
#+LaTeX_HEADER: \newcommand{\elemR}[2]{{#1}^{\phantom{\T}}_{\getitemR{#2}}} 
#+LaTeX_HEADER: \newcommand{\elemRP}[2]{{\big(#1\big)}^{\phantom{\T}}_{\getitemR{#2}}} 
#+LaTeX_HEADER: \newcommand{\elemRPE}[2]{\big({#1}^{\phantom{\T}}_{\getitemR{#2}}\big)}
#+LaTeX_HEADER: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#+LaTeX_HEADER: \newcommand{\Vect}[2][{}]{{\boldsymbol{#2}}_{#1}}
#+LaTeX_HEADER: \newcommand{\eleVR}[2]  {\elemR  {\Vect{#1}}{#2}}	 % con subindices
#+LaTeX_HEADER: \newcommand{\eleVRP}[2] {\elemRP {\Vect{#1}}{#2}}      % con subindices y paréntesis interior
#+LaTeX_HEADER: \newcommand{\eleVRPE}[2]{\elemRPE{\Vect{#1}}{#2}}      % con subindices y paréntesis exterior
#+LaTeX_HEADER: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#+LaTeX_HEADER: \newcommand{\VectC}[2][{}]  {\elemR  {\Mat{#2}}{#1}}   % con subindices
#+LaTeX_HEADER: \newcommand{\VectCP}[2][{}] {\elemRP {\Mat{#2}}{#1}}   % con subindices y paréntesis
#+LaTeX_HEADER: \newcommand{\VectCPE}[2][{}]{\elemRPE{\Mat{#2}}{#1}}   % con subindices y paréntesis exterior
#+LaTeX_HEADER: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#+LaTeX_HEADER: \newcommand{\mat}[1]{\mathbf{#1}}
#+LaTeX_HEADER: \newcommand{\Mat} [2][{}]{{\mat{#2}}_{#1}} 
#+LaTeX_HEADER: \newcommand{\T}{\intercal}
#+LaTeX_HEADER: \newcommand{\MatT}[2][{}]{{\mat{#2}}^{\T}_{#1}}
#+LaTeX_HEADER: \newcommand{\VectCC}[2][{}]   {\elemRR {\Mat{#2}}{#1}}   % con ()
#+LaTeX_HEADER: \newcommand{\VectCCC}[2][{}]  {\elemRRR{\Mat{#2}}{#1}}   % con texto "col"
#+LaTeX_HEADER: %SELECCIÓNA de FILAS y COlUMNAS DE UNA MATRIZ TRANSPUESTA PARA GENERAR UN VECTOR DE Rn
#+LaTeX_HEADER: \newcommand{\VectTC}[2][{}]   {\elemR{\MatT{#2}\!}{#1}}  % con subindices
#+LaTeX_HEADER: \newcommand{\VectTCC}[2][{}]  {\elemRR{ \MatT{#2}}{#1}}  % con ()
#+LaTeX_HEADER: \newcommand{\VectTCCC}[2][{}] {\elemRRR{\MatT{#2}}{#1}}  % con texto "col"
#+LaTeX_HEADER: \newcommand{\dotprod}[2][{}] {\Vect{#1}\cdot\Vect{#2}}

# C-c C-v C-n and C-c C-v n  jump to the next source block
# C-c C-v C-b and C-c C-v b  execute all source blocks

# +OPTIONS: toc:nil

#+ox-ipynb-keyword-metadata: key1 key2

*** COMMENT para Jupyter-Notebook                                :noexports:
\(
\newcommand{\R}[1][{}]{{\mathbb{R}}^{#1}}
\newcommand{\Z}[1][{}]{{\mathbb{Z}}^{#1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\getItem}{\pmb{\mid}}
\newcommand{\getitemR}[1]{\getItem{#1}}
\newcommand{\getitemL}[1]{{#1}\getItem}
\newcommand{\elemR}[2]{{#1}^{\phantom{\T}}_{\getitemR{#2}}} 
\newcommand{\elemRP}[2]{{\big(#1\big)}^{\phantom{\T}}_{\getitemR{#2}}} 
\newcommand{\elemRPE}[2]{\big({#1}^{\phantom{\T}}_{\getitemR{#2}}\big)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Vect}[2][{}]{{\boldsymbol{#2}}_{#1}}
\newcommand{\eleVR}[2]  {\elemR  {\Vect{#1}}{#2}}	 % con subindices
\newcommand{\eleVRP}[2] {\elemRP {\Vect{#1}}{#2}}      % con subindices y paréntesis interior
\newcommand{\eleVRPE}[2]{\elemRPE{\Vect{#1}}{#2}}      % con subindices y paréntesis exterior
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\VectC}[2][{}]  {\elemR  {\Mat{#2}}{#1}}   % con subindices
\newcommand{\VectCP}[2][{}] {\elemRP {\Mat{#2}}{#1}}   % con subindices y paréntesis
\newcommand{\VectCPE}[2][{}]{\elemRPE{\Mat{#2}}{#1}}   % con subindices y paréntesis exterior
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\Mat} [2][{}]{{\mat{#2}}_{#1}} 
\newcommand{\T}{\intercal}
\newcommand{\MatT}[2][{}]{{\mat{#2}}^{\T}_{#1}}
\newcommand{\VectCC}[2][{}]   {\elemRR {\Mat{#2}}{#1}}   % con ()
\newcommand{\VectCCC}[2][{}]  {\elemRRR{\Mat{#2}}{#1}}   % con texto "col"
%SELECCIÓNA de FILAS y COlUMNAS DE UNA MATRIZ TRANSPUESTA PARA GENERAR UN VECTOR DE Rn
\newcommand{\VectTC}[2][{}]   {\elemR{\MatT{#2}\!}{#1}}  % con subindices
\newcommand{\VectTCC}[2][{}]  {\elemRR{ \MatT{#2}}{#1}}  % con ()
\newcommand{\VectTCCC}[2][{}] {\elemRRR{\MatT{#2}}{#1}}  % con texto "col"
\newcommand{\dotprod}[2][{}] {\Vect{#1}\cdot\Vect{#2}}
\)


#+BEGIN_EXPORT latex
\maketitle
#+END_EXPORT

# COMMENT +PROPERTY: header-args:jupyter-python :results replace raw :display text/latex 
# COMMENT +PROPERTY: header-args:jupyter-python :results raw :results replace :display text/latex 
# COMMENT +PROPERTY: header-args:jupyter-python :results replace drawer
#+PROPERTY: header-args:jupyter-python :results replace

# C-c C-v b or C-c C-v C-b	org-babel-execute-buffer

*** Primer paso para usar [[https://github.com/mbujosab/nacallib][NAcAL]]
    :PROPERTIES:  
    :UNNUMBERED: t
    :END:  
# Esta sección no está numerada

Para poder usar [[https://github.com/mbujosab/nacallib][NAcAL]] es necesario importar el módulo:

#+BEGIN_SRC jupyter-python :results silent
from nacal import *
#+END_SRC

#+BEGIN_SRC jupyter-python  :results silent :exports none
from IPython.display import display_png
from sympy import preview
#+END_SRC


* Definición de algunas operaciones y objetos 

# Subespacios probabilísticos independientes dentro de un espacio euclídeo de probabilidad

Definamos el productorio /aspa/ ($\times$) introducido en la lección
anterior del libro:

# basado en https://docs.python.org/3/library/itertools.html#itertools.product

#+BEGIN_SRC jupyter-python :results silent
def aspa(lista):
    result = [[]]
    for pool in lista:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)
#+END_SRC

** Variable aleatoria

Vamos a crear un nuevo tipo de vector que posee un atributo adicional:
la probabilidad asociada a cada elemento de su rango (/función de masa
de probabilidad/).

#+BEGIN_SRC jupyter-python :results silent
class VA(Vector):    
    def __init__(self, data, fmp = [], rpr = 'columna'):
        super().__init__(data)
        ss = []; [ss.append(x) for x in self.lista if x not in ss] # sample space        
        if not isinstance(fmp, (list,tuple,dict)):
            raise ValueError('fmp debe ser una lista, tupla o diccionario')
        if fmp and not len(ss)==len(fmp):
            raise ValueError('debe haber una probabilidad por elemento en el rango del vector')
        else:
            if isinstance(data, VA):
                self.fmp = data.fmp
            elif isinstance(fmp, (list,tuple)):
                self.fmp = dict(zip(ss,fmp)) if fmp else dict(zip(ss, [fracc(1,len(ss))]*len(ss) ))
            else:
                self.fmp = fmp
                
        if self.es_indicatriz():
            self.P = self.fmp[1] if 1 in self.fmp else 0
        else:
            self.P = None
            
    def es_indicatriz(self):
        """Indica si es cierto que el Sistema es nulo"""
        return all([int(i==0 or i==1) for i in self])

    def copy(self):
        """ Copia la variable aleatoria"""
        return VA(self.lista.copy(), self.fmp.copy())


#+END_SRC

Si no se introducen probabilidades, prorratea entre los elementos del
rango

#+BEGIN_SRC jupyter-python
aa = VA([5, sympy.pi, sympy.sqrt(2), 5])
display(aa)
print(aa.fmp)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/6c2a3b4c4acc92705cad1340301c62e237fb566f.png]]
{5: 1/3, pi: 1/3, sqrt(2): 1/3}
:END:

Las probabilidades se introducen como una lista

#+BEGIN_SRC jupyter-python
bb = VA([0, sympy.pi, sympy.sqrt(2), 0], [fracc(1,6),fracc(2,6),fracc(3,6)])
display(bb)
print(bb.fmp)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/f2ec4689d729d3bc0942d2a9577616a291f94076.png]]
{0: 1/6, pi: 1/3, sqrt(2): 1/2}
:END:

Se puede copiar una variable aleatoria
#+BEGIN_SRC jupyter-python
bb.copy().fmp
#+END_SRC

#+RESULTS:
:RESULTS:
| 0: | 1/6 | pi: | 1/3 | sqrt | (2) | : | 1/2 |
:END:

Se puede generar una variable aleatoria a partir de otra
#+BEGIN_SRC jupyter-python
cc=VA(bb)
display(cc)
cc.fmp
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/f2ec4689d729d3bc0942d2a9577616a291f94076.png]]
| 0: | 1/6 | pi: | 1/3 | sqrt | (2) | : | 1/2 |
:END:

También dando la lista y probabilidad de otra variable aleatoria
#+BEGIN_SRC jupyter-python
cc = VA(bb.lista,bb.fmp)
cc.fmp
#+END_SRC

#+RESULTS:
:RESULTS:
| 0: | 1/6 | pi: | 1/3 | sqrt | (2) | : | 1/2 |
:END:

Se puede verificar si una VA es indicatriz
#+BEGIN_SRC jupyter-python
cc.es_indicatriz()
#+END_SRC

#+RESULTS:
:RESULTS:
False
:END:

#+BEGIN_SRC jupyter-python
VA([0, 1, 1, 1],[fracc(1,10),fracc(9,10)]).es_indicatriz()
#+END_SRC

#+RESULTS:
:RESULTS:
True
:END:

La VA que son indicatriz tienen el atributo ~P~ que indica la
probabilidad correspondiente al elemento 1, es decir, la probabilidad
del conjunto asociado al vector indicatriz.
#+BEGIN_SRC jupyter-python
VA([0, 1, 1, 1],[fracc(1,10),fracc(9,10)]).P
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \frac{9}{10}$
:END:


#+BEGIN_SRC jupyter-python
VA([0, 1, 1, 1],[fracc(1,10),fracc(9,10)]).fmp
#+END_SRC

#+RESULTS:
:RESULTS:
| 0: | 1/10 | 1: | 9/10 |
:END:


Se puede preguntar si un vector es una VA
#+BEGIN_SRC jupyter-python
isinstance(bb,VA)
#+END_SRC

#+RESULTS:
:RESULTS:
True
:END:

** Subespacio probabilizable

La clase ~SubEspacioProb~ es una subclase de la clase ~SubEspacio~
cuyo atributo ~base~ siempre es la /base canónica/ y con un atributo
adicional que es un ~embrion~ del subespacio compuesto por sucesivos
números naturales.

#+BEGIN_SRC jupyter-python  :results silent
class SubEspacioProb(SubEspacio):
    def __init__(self, data):
        if not isinstance(data, (Sistema, Matrix, Vector)):
            raise ValueError('Argumento debe ser un Sistema, una Matrix o un Vector embrión')
        
        prodH     = lambda u,w: Vector([u[i]*w[i] for i in range(u.n)])
        productoH = lambda x,n: V1(n) if not x else prodH(x[0], productoH(x[1:], n) )

        def BaseCanonica(v):
            #return ElimG(Sistema([Vector([int(i==j) for i in v.lista]) for j in set(v.lista)])).sis()
            return Matrix([Vector([int(i==j) for i in v.lista]) for j in set(v.lista)]).L().sis()

        def es_indicatriz(v):
            """Indica si es cierto que el Sistema es nulo"""
            return all([int(i==0 or i==1) for i in v])

        def es_probabilizable(s):
            """Indica si es cierto que el Sistema es nulo"""
            display(Matrix(s).R())
            return all([es_indicatriz(v) for v in Matrix(s).R()])
        
        if isinstance(data, Vector):
            embrion = data 
            baseC   = BaseCanonica(data)
            
        elif isinstance(Sistema(data)[0], Vector):
            if not es_probabilizable(data):
                raise ValueError('El espacio generado por los vectores no es probabilizable')
                
            n = (data[0]).n
            Q = [x for x in aspa([BaseCanonica(u) for u in data]) ]
            baseC   = Matrix([v for v in [productoH(s,n) for s in Q] if v.no_es_nulo()]).L().sis()
            embrion = Matrix(baseC)*Vector(list(range(1,len(baseC)+1)))
            
        super().__init__(baseC)
        
        self.embrion = embrion
#+END_SRC

#+BEGIN_SRC jupyter-python
a=Vector([5,sympy.pi,sympy.sqrt(2),5]); a
a
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/6c2a3b4c4acc92705cad1340301c62e237fb566f.png]]
:END:

Si empleamos un vector como argumento, usará este como embrión del
subespacio probabilizable.  El atributo ~base~ es la base canónica del
subespacio.

#+BEGIN_SRC jupyter-python
G = SubEspacioProb(a)
G.base
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/189e88886e3104ec45d2b0e4c539914be188360e.png]]
:END:

Si empleamos una matriz como argumento, usará sus columnas como
embriones y el resultado será la envolvente probabilizable de los
subespacios creados con cada uno de los embriones (columnas).


#+BEGIN_SRC jupyter-python
B=Matrix([Vector([1,0,0,1]),Vector([0,1,0,0]),Vector([0,0,1,0]),a]); B
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/17f84d07408e74fcee5e1224c809ee11f9b5fc4a.png]]
:END:

#+BEGIN_SRC jupyter-python
H = SubEspacioProb(B)
H.base
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/189e88886e3104ec45d2b0e4c539914be188360e.png]]
:END:

#+BEGIN_SRC jupyter-python
C=Matrix([Vector([1,0,0,2]),Vector([0,1,0,0]),Vector([0,0,1,0])]); C
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/5722703d25d597f649c4d5d4c347ed443c225954.png]]
:END:


#+BEGIN_SRC jupyter-python  :display raw
SubEspacioProb(C).embrion
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/176418bdd45d4e9c5ed8a6edcaf8dbf7aef164fc.png]]
# [goto error]

ValueErrorTraceback (most recent call last)
<ipython-input-69-60206ff87d2f> in <module>
----> 1 SubEspacioProb(C).embrion

<ipython-input-58-5ef852f88a96> in __init__(self, data)
     26         elif isinstance(Sistema(data)[0], Vector):
     27             if not es_probabilizable(data):
---> 28                 raise ValueError('El espacio generado por los vectores no es probabilizable')
     29 
     30             n = (data[0]).n

ValueError: El espacio generado por los vectores no es probabilizable
:END:


El atributo ~embrión~ es un embrión del subespacio
#+BEGIN_SRC jupyter-python
H.embrion
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/7d6aa8b30f47c0e4840cc4c60cf0b32df5c2dc76.png]]
:END:


#+BEGIN_SRC jupyter-python
C=(I(4)|(1,2,3)).concatena(Matrix([a])); C
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/5b44d8c994928d667a015684b99d15f9a1bc4ce0.png]]
:END:

#+BEGIN_SRC jupyter-python
J = SubEspacioProb(C)
J.embrion
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/33bdc257534a9e40ad7654a236cf6ab4af4eb285.png]]
[[file:./.ob-jupyter/2231e3e8d7173f99eccdc618f96425f348da56ac.png]]
:END:

** Espacio Euclídeo de probabilidad

La clase ~EspacioEuclideoProb~ es una subclase de la clase
~SubEspacioProb~ que incluye las probabilidades asociadas a los
vectores indicatrices de su base canónica (los /pesos de la base
canónica/ ~pbc~); además su embrión es una ~VA~.

#+BEGIN_SRC jupyter-python :results silent
class EspacioEuclideoProb(SubEspacioProb):
    def __init__(self, data, pbc=[]):
        super().__init__(data)
        
        if isinstance(data, VA):            
            ss = []; [ss.append(x) for x in data.lista if x not in ss]
            self.base = Sistema([ VA([int(i==c) for i in data.lista], {1:p,0:1-p}) for j,(c,p) in enumerate(data.fmp.items())])            
                
        elif isinstance(data, Sistema) and isinstance(data[0], VA) and isinstance(data[0], VA):
            self.base = data
            self.embrion = VA(self.embrion, {i+1:v.P for i,v in enumerate(data)})
        else:
            raise ValueError('El argumento debe ser una VA o un sistema de VAs')

        self.pbc = Sistema( [Sistema([v,v.fmp[1]]) for v in self.base])

    def Esperanza(self, vector):
        if not vector in self:
            raise ValueError('El vector no pertenece al espacio euclideo de probabilidad')
        
        return vector*Vector([v.fmp[1] for v in self.base])


#+END_SRC


#+BEGIN_SRC jupyter-python
K = EspacioEuclideoProb(bb)
display(K.embrion)
print(K.embrion.fmp)
display(K.base)
display(K.pbc)
print([v.P for v in K.base])
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/f2ec4689d729d3bc0942d2a9577616a291f94076.png]]
{0: 1/6, pi: 1/3, sqrt(2): 1/2}
[[file:./.ob-jupyter/189e88886e3104ec45d2b0e4c539914be188360e.png]]
[[file:./.ob-jupyter/bf3ecdd545238d79d8038a862130ea3c32f4f910.png]]
[1/6, 1/3, 1/2]
:END:

#+BEGIN_SRC jupyter-python
M = Matrix([Vector(v.lista+[v.P]) for v in K.base])
v = Vector([3,2,1,3,0])
SEL(M,v,1)
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \left[ \begin{array}{ccc|c}1&0&0&-30&1&0&-20&0&1&-11&0&0&-3\frac{1}{6}&\frac{1}{3}&\frac{1}{2}&0 \hline 1&0&0&00&1&0&00&0&1&0 \hline 0&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(3\right)\mathbf{1}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{ccc|c}1&0&0&00&1&0&-20&0&1&-11&0&0&0\frac{1}{6}&\frac{1}{3}&\frac{1}{2}&\frac{1}{2} \hline 1&0&0&30&1&0&00&0&1&0 \hline 0&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(2\right)\mathbf{2}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{ccc|c}1&0&0&00&1&0&00&0&1&-11&0&0&0\frac{1}{6}&\frac{1}{3}&\frac{1}{2}&\frac{7}{6} \hline 1&0&0&30&1&0&20&0&1&0 \hline 0&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(1\right)\mathbf{3}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{ccc|c}1&0&0&00&1&0&00&0&1&01&0&0&0\frac{1}{6}&\frac{1}{3}&\frac{1}{2}&\frac{5}{3} \hline 1&0&0&30&1&0&20&0&1&1 \hline 0&0&0&1 \end{array} \right]$
$\emptyset$
:END:


#+BEGIN_SRC jupyter-python
C=Matrix([Vector([1,0,0,1]),Vector([0,1,0,0]),Vector([0,0,1,0])]); C
CC=EspacioEuclideoProb(Sistema([VA(v) for v in C]))
CC.pbc
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/7a05426b915b85d43ed466fe586a40223306ec15.png]]
[[file:./.ob-jupyter/15b6ae94ea7bf9841d947d28cff2af844087e9a7.png]]
:END:


#+BEGIN_SRC jupyter-python
no = VA([1,0,0,0],[fracc(1,1),0, 0, 0])
no in K
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

ValueErrorTraceback (most recent call last)
<ipython-input-95-c81b12cd34fb> in <module>
----> 1 no = VA([1,0,0,0],[fracc(1,1),0, 0, 0])
      2 no in K

<ipython-input-68-607d227cb39d> in __init__(self, data, fmp, rpr)
      6             raise ValueError('fmp debe ser una lista, tupla o diccionario')
      7         if fmp and not len(ss)==len(fmp):
----> 8             raise ValueError('debe haber una probabilidad por elemento en el rango del vector')
      9         else:
     10             if isinstance(data, VA):

ValueError: debe haber una probabilidad por elemento en el rango del vector
:END:


Los vectores de la base canónica son ~VA~ y por tanto cada uno posee su propia función de pesos
#+BEGIN_SRC jupyter-python
[v.fmp for v in K.base]
#+END_SRC

#+RESULTS:
:RESULTS:
| 1: | 1/6 | 0: | 5/6 |
| 1: | 1/3 | 0: | 2/3 |
| 1: | 1/2 | 0: | 1/2 |
:END:


Podemos generar el subespacio de probabilidad empleando la base
canónica formada por variables aleatorias que sean indicatrices.
#+BEGIN_SRC jupyter-python
KK = EspacioEuclideoProb(K.base)
display(KK.base)
display(KK.embrion)
print(KK.embrion.fmp)
display(KK.pbc)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/189e88886e3104ec45d2b0e4c539914be188360e.png]]
[[file:./.ob-jupyter/7d6aa8b30f47c0e4840cc4c60cf0b32df5c2dc76.png]]
{1: 1/6, 2: 1/3, 3: 1/2}
[[file:./.ob-jupyter/bf3ecdd545238d79d8038a862130ea3c32f4f910.png]]
:END:


* función lineal

#+BEGIN_SRC jupyter-python
class BlockV(Sistema):
    def __init__(self, data, rpr='columna'):
        """Inicializa Vector con una lista, tupla o Sistema"""

        super().__init__(data)

        self.rpr  =  rpr    
        self.n    =  len(self)

    def __invert__(self):
        return self
        
    def __ror__(self,i):
        """Hace exactamente lo mismo que el método __or__ por la derecha."""
        return self | i
        
    def __rand__(self,t):
        """Hace exactamente lo mismo que el método __and__ por la derecha."""
        return self & t
        
    def __repr__(self):
        """ Muestra el vector en su representación Python """
        return 'BlockV(' + repr(self.lista) + ')'

    def _repr_html_(self):
        """ Construye la representación para el entorno Jupyter Notebook """
        return html(self.latex())

    def latex(self):
        """ Construye el comando LaTeX para representar un Vector"""
        if self.rpr == 'fila' or self.n==1:    
            return r'\begin{pmatrix}' + \
                   ',& '.join([latex(e) for e in self]) + \
                   r',\end{pmatrix}' 
        else:
            return r'\begin{pmatrix}' + \
                   r'\\ '.join([latex(e) for e in self]) + \
                   r'\end{pmatrix}'
                           
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
class BlockS(Sistema):
    def __init__(self, data):
        """Inicializa una Matrix por bloques"""
        super().__init__(data)
        
        lista = Sistema(data).lista
        
        self.lista   = lista.copy()
        
        self.m  = len(self|1)
        self.n  = len(self)
        self.cC = {0}
        self.cF = {0}
        
    def __or__(self,j):
        """
        Extrae la i-ésima columna de Matrix; o crea una Matrix con las columnas
        indicadas; o crea una BlockM particionando una Matrix por las
        columnas indicadas (los índices comienzan por la posición 1)

        Parámetros:
            j (int, list, tuple, slice): Índice (o lista de índices) de la 
                  columna (o columnas) a seleccionar
              (set): Conjunto de índices de las columnas por donde particionar

        Resultado:
            Vector: Cuando j es int, devuelve la columna j-ésima de Matrix.
            Matrix: Cuando j es list, tuple o slice, devuelve la Matrix formada 
                por las columnas indicadas en la lista o tupla de índices.
            BlockM: Si j es un set, devuelve la BlockM resultante de particionar
                la matriz a la derecha de las columnas indicadas en el conjunto

        Ejemplos:
        >>> # Extrae la j-ésima columna la matriz 
        >>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | 2

        Vector([0, 2])
        >>> # Matrix formada por Vectores columna indicados en la lista (o tupla)
        >>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | [2,1]
        >>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | (2,1)

        Matrix( [Vector([0, 2]); Vector([1, 0])] )
        >>> # BlockM correspondiente a la partición por la segunda columna
        >>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | {2}

        BlockM([SisMat([Matrix([Vector([1, 0]), Vector([0, 2])])]), 
                SisMat([Matrix([Vector([3, 0])])])])
        """
        if isinstance(j, int):
            return self[j-1]
            
        elif isinstance(j, (list,tuple) ):
            return type(self) ([ self|a for a in j ])

        elif isinstance(j, slice):
            start = None if j.start is None else j.start-1 
            stop  = None if j.stop  is None else (j.stop if j.stop>0 else j.stop-1)
            step  = j.step  or 1
            return type(self) (self[slice(start,stop,step)])
        elif isinstance(j,set):
            return BlockS ([ [self|a for a in particion(j,self.n)] ])
        
    def __invert__(self):
        """
        Devuelve la traspuesta de una matriz.

        Ejemplo:
        >>> ~Matrix([ [1,2,3] ])

        Matrix([ Vector([1, 2, 3]) ])
        """
        lista  =  [ BlockV( [ self.lista[i][j] for i in range(len(self.lista)) ] ) \
                                                   for j in range(len(self.lista[0])) ].copy()

        M = BlockS ([ c for c in lista ])
        M.cF, M.cC = self.cC, self.cF
        return M

    def __ror__(self,i):
        """Operador selector por la izquierda

        Extrae la i-ésima fila de Matrix; o crea una Matrix con las filas 
        indicadas; o crea una BlockM particionando una Matrix por las filas
        indicadas (los índices comienzan por la posición 1)

        Parámetros:
            i (int, list, tuple): Índice (o índices) de las filas a seleccionar
              (set): Conjunto de índices de las filas por donde particionar

        Resultado:
            Vector: Cuando i es int, devuelve la fila i-ésima de Matrix.
            Matrix: Cuando i es list o tuple, devuelve la Matrix cuyas filas son
                las indicadas en la lista de índices.
            BlockM: Cuando i es un set, particiona la matriz por debajo de las 
                filas indicadas en el conjunto.

        Ejemplos:
        >>> # Extrae la j-ésima fila de la matriz 
        >>> 2 | Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])])

        Vector([0, 2, 0])
        >>> # Matrix formada por Vectores fila indicados en la lista (o tupla)
        >>> [1,1] | Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) 
        >>> (1,1) | Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])])

        Matrix([Vector([1, 1]), Vector([0, 0]), Vector([3, 3])])
        >>> # BlockM correspondiente a la partición por la primera fila
        >>> {1} | Matrix([Vector([1,0]), Vector([0,2])])

        BlockM([ SisMat([Matrix([Vector([1]), Vector([0])]), 
                         Matrix([Vector([0]), Vector([2])])]) ])
        """
        if isinstance(i,int):
            return  BlockV( (~self)|i , rpr='fila' )

        elif isinstance(i, (list,tuple,slice)):        
            return ~BlockS( (~self)|i ) 
        
        elif isinstance(i,set):
            return BlockS ([ Sistema([a|self]) for a in particion(i,self.m) ])

    def apila(self, l, c=0):
        """Apila una lista o tupla de Matrix con el mismo número de columnas
        en una única Matrix concatenando las respectivas columnas"""
        l = l if isinstance(l, list) else [l]
        apila_dos = lambda x, other, c=0: ~((~x).concatena(~other,c))
        apila = lambda x: x[0] if len(x)==1 else apila_dos( apila(x[0:-1]), x[-1] , c )
        
        return apila([self] + [s for s in l])
            
    def __repr__(self):
        """ Muestra una matriz en su representación Python """
        return 'Matrix(' + repr(self.lista) + ')'

    def _repr_html_(self):
        """ Construye la representación para el  entorno Jupyter Notebook """
        return html(self.latex())
        
    def cfil(self,conjuntoIndices):
        """ Añade el atributo cfilas para insertar lineas horizontales """
        self.cF = set(conjuntoIndices) if conjuntoIndices else {0}
        return self

    def ccol(self,conjuntoIndices):
        """ Añade el atributo cfilas para insertar lineas horizontales """
        self.cC = set(conjuntoIndices) if conjuntoIndices else {0}
        return self

    def latex(self):
        """ Construye el comando LaTeX para representar una Matrix """
        ln = [len(n) for n in particion(self.cC,self.n)]                                                           
        return \
         '\\left[ \\begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
         '\\\\ \\hline '.join(['\\\\'.join(['&'.join([latex(e) for e in f.lista]) \
           for f in (~M).lista]) \
           for M in [ i|self for i in particion(self.cF,self.m)]]) + \
         '\\\\ \\end{array} \\right]'
        

#+END_SRC

#+RESULTS:



#+BEGIN_SRC jupyter-python
class ElimR(Sistema):
    def __init__(self, data, rep=0, sust=[], repsust=0):
        """Devuelve una forma pre-escalonada de Matrix(data)
           operando con las columnas (y evitando operar con fracciones). 
           Si rep es no nulo, se muestran en Jupyter los pasos dados"""
        
        if not isinstance(data,Sistema):
            raise ValueError ('Es algumento debe ser un sistema')
        
        if not data.de_composicion_uniforme():
            display(data)
            raise ValueError('Los elementos del sistema deben ser del mismo tipo')
        
        def texYpasos(data, rep=0, sust=[], repsust=0):
            pasosPrevios = data.pasos if hasattr(data, 'pasos') and data.pasos else [[],[]]
            TexPasosPrev = data.tex   if hasattr(data, 'tex')   and data.tex   else []
            if repsust:
                tex = rprElim(data, pasos, TexPasosPrev, sust)
            else:
                tex = rprElim(data, pasos, TexPasosPrev)
            pasos[0] = pasos[0] + pasosPrevios[0] 
            pasos[1] = pasosPrevios[1] + pasos[1]
            
            TrF = T(pasos[0])
            TrC = T(pasos[1])
            
            if rep:
                display(Math(tex))
            
            return [tex, pasos, TrF, TrC]
                    
        celim = lambda x: x > p
        
        A = type(data)(data.subs(sust)); A.TrC = A.TrF = []; A.pasos=[A.TrF, A.TrC];
        r = 0;  transformaciones = [];

        for p,kk in enumerate(A,1):
            cc     = primer_no_nulo(A|p);
            pivote = A.estractor([p]+cc)
            if A.estractor([p]+cc):
                r += 1
                op = []
                for j in filter(celim, range(1,len(A)+1)):
                    aEliminar = A.estractor([j]+cc)
                    op = op + [( denom(aEliminar, pivote),    j), \
                               (-numer(aEliminar, pivote), p, j)  ]
                Tr = T(op)    
                transformaciones += [Tr]  if Tr.t else []
                A & Tr
                A = A.subs(sust);
                
        pasos = [[], transformaciones]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        self.tex, self.pasos, self.TrF, self.TrC = texYpasos(data, rep, sust, repsust)
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        #self.__class__ = Matrix
        
        if isinstance (data, Matrix):
           self.cF, self.cC = data.cF, data.cC
    

#+END_SRC

#+RESULTS:

#+RESULTS:
:RESULTS:
6
:END:
#+BEGIN_SRC jupyter-python
(W).estractor([1,1,1,1])

#+END_SRC

#+RESULTS:
:RESULTS:
6
:END:

#+BEGIN_SRC jupyter-python
particion({0},5)
#+END_SRC

#+RESULTS:
:RESULTS:
| 1 | 2 | 3 | 4 | 5 |
:END:


#+BEGIN_SRC jupyter-python
#def sislatex(s):
#    """ Construye el comando LaTeX para representar un Sistema """
#    pc = ';' if len(s.lista) else r'\ '
#    ln = [len(i) for i in particion(self.cC,self.n)]                                                           
#    return r'\begin{bmatrix}' + \
#           r';& '.join([latex(e) for e in s]) + pc + \
#           r'\end{bmatrix}' 

def sislatex(s,cC,):
    """ Construye el comando LaTeX para representar un Sistema """
    pc = ';' if len(s.lista) else r'\ '
    ln = [len(i) for i in particion(cC,len(s)+1)]                                                           
    return \
        r'\left[ \begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
        r';& '.join([latex(e) for e in s]) + pc + \
        r'\end{array} \right]'

#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
display(Math(sislatex(V1(6),{3})))
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \left[ \begin{array}{ccc|cccc}1;& 1;& 1;& 1;& 1;& 1;\end{array} \right]$
:END:



#+BEGIN_SRC jupyter-python
ElimR(((W)))
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}2&0&11&1&1 \end{array} \right]&\left[ \begin{array}{ccc}0&-1&-1-1&0&0 \end{array} \right]1&0&0&00&1&0&00&0&1&00&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(3\right)\mathbf{3}\right]\left[\left(-1\right)\mathbf{1}+\mathbf{3} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&1&-7-1&-8&0 \end{array} \right]&\left[ \begin{array}{ccc}0&-1&-1-1&0&0 \end{array} \right]1&0&-1&00&1&0&00&0&3&00&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(1\right)\mathbf{2}+\mathbf{3} \right]\left[\left(1\right)\mathbf{2}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&1&-30&-4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&-1&30&4&0 \end{array} \right]1&0&-1&00&1&1&10&0&3&00&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(1\right)\mathbf{3}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&1&-30&-4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&0&00&0&0 \end{array} \right]1&0&-1&-10&1&1&20&0&3&30&0&0&1 \end{array} \right]$
[[file:./.ob-jupyter/ca440c31d5a2095596b3559798ce368efe28adfe.png]]
:END:


#+BEGIN_SRC jupyter-python
es_numero = lambda n: isinstance(n, (int, float, sympy.Basic))

def primer_no_nulo(s, r=0):
    """Primer elemento no nulo en un sistema de sistemas de números"""
    c = [] if es_numero(s) else s.primer_no_nulo(p=r)
    return c + primer_no_nulo(CreaSistema(s)|c[0],r) if c!=[] else []

def estractor(s,c):
    x = s
    for i in c:
        x = x|i
    return x

#+END_SRC

#+BEGIN_SRC jupyter-python
a,b = sympy.symbols('a b')

all(es_numero(i) for i in (1,sympy.sqrt(2), fracc(a,b)) )


fracc(1,b/a)
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \frac{a}{b}$
:END:



#+BEGIN_SRC jupyter-python
def ultimo_no_nulo(s, p = 0, sust=[]):
    """Devuelve o una lista con la posición del primer no nulo despues de
    la posición p o vacía si todos son nulos"""
    return next(([i] for i, x in enumerate(self.subs(sust),1) if CreaSistema(x).no_es_nulo() and i>p), [])

#+END_SRC


#+RESULTS:

#+BEGIN_SRC jupyter-python
A = Matrix([ [ 0, 1, 1], [1, 0, 0] ])
B = Matrix([ [ 0, 0, 4], [1, 4, 0] ])
C = Matrix([ [ 2, 0, 1], [1, 1, 1] ])
D = -A+2*B+3*C
#lockS([[A],[B],[C]])*Vector([-1,2,3])
D
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b41e8f56ab1fe47d40f32404d9e711e987f19a8f.png]]
:END:



#+BEGIN_SRC jupyter-python
Z = BlockS([[D],[B],[C],[-A]]).apila(I(4))
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python
W=Z.copy().cfil({1,4}).ccol({3}) #& T((-1,1,2)) & T((-1,1,3))  & T((4,1,4)) & T((-1,2,3)) & T((5,2,4)) & T((3,3,4))
W
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/604037619b6649f171cfb9c6d9947b0c9d527242.png]]
:END:


#+BEGIN_SRC jupyter-python
#W = Z.copy()
#display(W)
ElimR(W,1)
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}2&0&11&1&1 \end{array} \right]&\left[ \begin{array}{ccc}0&-1&-1-1&0&0 \end{array} \right]1&0&0&00&1&0&00&0&1&00&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(3\right)\mathbf{3}\right]\left[\left(-1\right)\mathbf{1}+\mathbf{3} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&1&-7-1&-8&0 \end{array} \right]&\left[ \begin{array}{ccc}0&-1&-1-1&0&0 \end{array} \right]1&0&-1&00&1&0&00&0&3&00&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(1\right)\mathbf{2}+\mathbf{3} \right]\left[\left(1\right)\mathbf{2}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&1&-30&-4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&-1&30&4&0 \end{array} \right]1&0&-1&00&1&1&10&0&3&00&0&0&1 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(1\right)\mathbf{3}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{cccc}\left[ \begin{array}{ccc}6&-1&104&11&3 \end{array} \right]&\left[ \begin{array}{ccc}0&0&41&4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&1&-30&-4&0 \end{array} \right]&\left[ \begin{array}{ccc}0&0&00&0&0 \end{array} \right]1&0&-1&-10&1&1&20&0&3&30&0&0&1 \end{array} \right]$
[[file:./.ob-jupyter/ca440c31d5a2095596b3559798ce368efe28adfe.png]]
:END:


#+BEGIN_SRC jupyter-python
A = Matrix([ [ 0, 1, 1], [1, 0, 0] ])
B = Matrix([ [ 0, 0, 4], [1, 4, 0] ])
C = Matrix([ [ 2, 0, 1], [1, 1, 1] ])
Z = Sistema( [ A, B, C] )           # Sistema de Matrices
a = Vector ( [ 1, 0, 1] )
Z*a     
#+END_SRC



#+BEGIN_SRC jupyter-python
Z = Sistema( [ A, B, C, a, 1492] )  
#ZZ = BlockV( [ A, B, C, a, 1492] )
ZZ = BlockV( Z )
ZZ
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/3447c2ee35e9be3c4cf0005f29917de45398d451.png]]
:END:


#+BEGIN_SRC jupyter-python
#Z = Sistema( [M0(2,4), A, B, C, V1(3), 1492] )  
D = Matrix([ [ 0, 0, 0, 0], [ 0, 0, 0, 0], [ 0, 0, 0, 0], [0, 0, 99, 10] ])
Z = Sistema( [ M0(3,4), D,  a] )  
ZZ = BlockV(Z)
ZZZ = BlockS([ZZ,ZZ])
ZZZ
#ZZZ.apila(ZZZ).ccol({2}).cfil({5}) & T((-3,1,3))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/a8ab47c2c10017e5fb2f6d2eee1c12cb3976bffb.png]]
:END:



#+BEGIN_SRC jupyter-python
a = sympy.symbols('a')
#+END_SRC

#+RESULTS:



#+BEGIN_SRC jupyter-python
Matrix([[0,0,1],[0,0,0],[0,a,7]]).primer_no_nulo(p=1,sust=[(a,0)])
#+END_SRC


#+RESULTS:
:RESULTS:
| 3 |
:END:

#+BEGIN_SRC jupyter-python
A =Matrix([[0,0,1],[0,1,0],[1,0,0]])
display(A)
A.primer_no_nulo()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/00790a30f4c25e3a5a2d31a39fa10fcdca684046.png]]
| 1 |
:END:


#+BEGIN_SRC jupyter-python
colExcluida = {2,4}
def BuscaNuevoPivote(s, sust=[], r=0):
    pp = s.primer_no_nulo(sust, p=r)
    while pp[0] in colExcluida:
        pp = s.primer_no_nulo(sust, p=pp[0])
    return pp

A=Matrix([[0,0,1],[0,0,0],[0,a,7]])
BuscaNuevoPivote(A,sust=(a,1))
#+END_SRC

#+RESULTS:
:RESULTS:
| 3 |
:END:


#+BEGIN_SRC jupyter-python
A = [1,2,3,4]
print(A.pop(0))
print(A.pop(0))
print(A.pop(0))
print(A.pop(0))
print(A)
#+END_SRC

#+RESULTS:
:RESULTS:
1
2
3
4
[]
:END:

#+BEGIN_SRC jupyter-python
A = I(4)
coords=[2]
Sistema(list(map(lambda i,s: s|i, coords,2*A)))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/73fa0631e6ac1cb7aaba883935d0ccdb09078a4b.png]]
:END:



#+BEGIN_SRC jupyter-python
es_numero = lambda n: isinstance(n, (int, float, sympy.Basic))

def primer_no_nulo(s, r=0):
    """Primer elemento no nulo en un sistema de sistemas de números"""
    c = [] if es_numero(s) else s.primer_no_nulo(p=r)
    return c + primer_no_nulo(CreaSistema(s)|c[0],r) if c!=[] else []

def estractor(s,c):
    x = s
    for i in c:
        x = x|i
    return x



M = Matrix([[0,0,0,0],[0,0,99,8]])
estractor(M, primer_no_nulo(M))
print(primer_no_nulo(M))
M.estractor(primer_no_nulo(M))
#+END_SRC

#+RESULTS:
:RESULTS:
[3, 2]
99
:END:

#+BEGIN_SRC jupyter-python
primer_no_nulo(ZZZ)
#+END_SRC

#+RESULTS:
:RESULTS:
| 1 | 2 | 3 | 4 |
:END:


#+BEGIN_SRC jupyter-python
(ZZZ).estractor(primer_no_nulo(ZZZ))
#+END_SRC

#+RESULTS:
:RESULTS:
99
:END:


#+BEGIN_SRC jupyter-python
display(ZZZ)
estractor(ZZZ, primer_no_nulo(ZZZ))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/a8ab47c2c10017e5fb2f6d2eee1c12cb3976bffb.png]]
99
:END:

#+BEGIN_SRC jupyter-python
ZZZ.copy() & T((-1,1,2))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/19529351f5b96e1bce018075009cdc3667909d71.png]]
:END:

#+BEGIN_SRC jupyter-python
ZZZ
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/a8ab47c2c10017e5fb2f6d2eee1c12cb3976bffb.png]]
:END:

#+BEGIN_SRC jupyter-python
primer_no_nulo(ZZZ)
#+END_SRC

#+RESULTS:
:RESULTS:
| 1 | 2 | 3 | 4 |
:END:


#+BEGIN_SRC jupyter-python
ElimR(Z)
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

NameErrorTraceback (most recent call last)
<ipython-input-52-741a88fcee32> in <module>
----> 1 ElimR(Z)

NameError: name 'ElimR' is not defined
:END:



#+BEGIN_SRC jupyter-python
f=BlockV(2|ZZZ)
display(f)
kk(f)
#primer_no_nulo(4|(1|(2|ZZZ)))
#all([es_numero(e) for e in  4|(1|(2|ZZZ))])
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/97946d3b01de58a76ea30d86efb4d99731aef537.png]]
# [goto error]

NameErrorTraceback (most recent call last)
<ipython-input-23-b40ea5f68e91> in <module>
      1 f=BlockV(2|ZZZ)
      2 display(f)
----> 3 kk(f)
      4 #primer_no_nulo(4|(1|(2|ZZZ)))
      5 #all([es_numero(e) for e in  4|(1|(2|ZZZ))])

NameError: name 'kk' is not defined
:END:


#+BEGIN_SRC jupyter-python
            
#print(busca_no_nulo(ZZZ))
for i,c in enumerate(ZZZ,1):
    display(i|ZZZ)
    p = profundidad(i|ZZZ)
    S = i|ZZZ
    for n in range (1,p[0]+1):
        display(n|S)
        print(primer_no_nulo(n|S))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b290f97024be4b78527e570b57b18ace5abd643b.png]]
[[file:./.ob-jupyter/c53dc087368a0a4a1503cffc1e391c3a9a623ab7.png]]
False
[[file:./.ob-jupyter/c53dc087368a0a4a1503cffc1e391c3a9a623ab7.png]]
False
[[file:./.ob-jupyter/b8bc5ea829144b3d4182310c6cce1b33161040d4.png]]
[[file:./.ob-jupyter/39faff3bbf0a59ae4c507ae65dca0771bb62034f.png]]
False
[[file:./.ob-jupyter/39faff3bbf0a59ae4c507ae65dca0771bb62034f.png]]
False
:END:

#+BEGIN_SRC jupyter-python
list(range(1,4+1))
#+END_SRC

#+RESULTS:
:RESULTS:
| 1 | 2 | 3 | 4 |
:END:



#+BEGIN_SRC jupyter-python
def profundidad(s,e=[]):
    def inmersion(l):
        S = l
        while not es_numero(S):
            yield S
            S = 1|S
            
    return [(type(i),len(i)) for i in inmersion(s)] if e else [len(i) for i in inmersion(s)]

display(ZZZ)
profundidad(ZZZ|1,1)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/a8ab47c2c10017e5fb2f6d2eee1c12cb3976bffb.png]]
| __main__.BlockV    | 3 |
| nacal.nacal.Matrix | 4 |
| nacal.nacal.Vector | 4 |
:END:


#+BEGIN_SRC jupyter-python
[profundidad(i,1) for i in ZZZ]
#+END_SRC

#+RESULTS:
:RESULTS:
2
2
| (__main__.BlockV 2) | (nacal.nacal.Matrix 4) | (nacal.nacal.Vector 4) |
| (__main__.BlockV 2) | (nacal.nacal.Matrix 4) | (nacal.nacal.Vector 4) |
:END:


#+BEGIN_SRC jupyter-python
[profundidad(i,1) for i in ZZZ|1]==[profundidad(i,1) for i in ZZZ|2]
#+END_SRC

#+RESULTS:
:RESULTS:
True
:END:


#+BEGIN_SRC jupyter-python
class Localizador:
    def __init__(self, data):
        self.data = data
    def __iter__(self):
        self.p = [1 for x in self.data]
        return self                                
    def __next__(self):
        def Siguiente(x,y):
            if x == [] :
                return []    
            s = Siguiente(x[1:],y[1:])
            if s == []:
                if x[0]+1 > y[0]:
                    return []
                else:
                    return [x[0]+1] + [1 for i in x[1:]]
            else:
                return [x[0]] + s
        if self.p == []:
            raise StopIteration                         
        n = self.p
        self.p = Siguiente(self.p, self.data)
        return n

#+END_SRC

#+RESULTS:



#+BEGIN_SRC jupyter-python
primer_no_nulo(1|(1|(2|ZZZ)))

#+END_SRC

#+RESULTS:
:RESULTS:
2
:END:


#+BEGIN_SRC jupyter-python

def primer_pivote(s):
    p = 0
    c = list(Localizador(profundidad(s)))
    for i in c:
        #print(i)
        S = s        
        for j in i:
            #print(j)
            #display(S)
            if primer_no_nulo(S):
                return list(i)[:-1]+[primer_no_nulo(S)] #primer_no_nulo(S)
            S = j|S
        
ppp = primer_pivote(ZZZ)
ppp
#for c in ppp[:-1]

def estractor(s,c):
    x = s
    for i in c:
        x = i|x
    return x,c 

estractor(ZZZ, primer_pivote(ZZZ))
#+END_SRC

#+RESULTS:
:RESULTS:
| 99 | (1 1 4 3) |
:END:

#+BEGIN_SRC jupyter-python
u = [1,2,3,4]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
e = u.pop(0) if u else None
print(e)
#+END_SRC

#+RESULTS:
:RESULTS:
None
:END:

#+BEGIN_SRC jupyter-python
list(Localizador(profundidad(ZZZ)))
#primer_pivote(ZZZ)
#+END_SRC

#+RESULTS:
:RESULTS:
| 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 2 |
| 1 | 1 | 1 | 3 |
| 1 | 1 | 1 | 4 |
| 1 | 1 | 2 | 1 |
| 1 | 1 | 2 | 2 |
| 1 | 1 | 2 | 3 |
| 1 | 1 | 2 | 4 |
| 1 | 1 | 3 | 1 |
| 1 | 1 | 3 | 2 |
| 1 | 1 | 3 | 3 |
| 1 | 1 | 3 | 4 |
| 1 | 1 | 4 | 1 |
| 1 | 1 | 4 | 2 |
| 1 | 1 | 4 | 3 |
| 1 | 1 | 4 | 4 |
| 1 | 2 | 1 | 1 |
| 1 | 2 | 1 | 2 |
| 1 | 2 | 1 | 3 |
| 1 | 2 | 1 | 4 |
| 1 | 2 | 2 | 1 |
| 1 | 2 | 2 | 2 |
| 1 | 2 | 2 | 3 |
| 1 | 2 | 2 | 4 |
| 1 | 2 | 3 | 1 |
| 1 | 2 | 3 | 2 |
| 1 | 2 | 3 | 3 |
| 1 | 2 | 3 | 4 |
| 1 | 2 | 4 | 1 |
| 1 | 2 | 4 | 2 |
| 1 | 2 | 4 | 3 |
| 1 | 2 | 4 | 4 |
| 2 | 1 | 1 | 1 |
| 2 | 1 | 1 | 2 |
| 2 | 1 | 1 | 3 |
| 2 | 1 | 1 | 4 |
| 2 | 1 | 2 | 1 |
| 2 | 1 | 2 | 2 |
| 2 | 1 | 2 | 3 |
| 2 | 1 | 2 | 4 |
| 2 | 1 | 3 | 1 |
| 2 | 1 | 3 | 2 |
| 2 | 1 | 3 | 3 |
| 2 | 1 | 3 | 4 |
| 2 | 1 | 4 | 1 |
| 2 | 1 | 4 | 2 |
| 2 | 1 | 4 | 3 |
| 2 | 1 | 4 | 4 |
| 2 | 2 | 1 | 1 |
| 2 | 2 | 1 | 2 |
| 2 | 2 | 1 | 3 |
| 2 | 2 | 1 | 4 |
| 2 | 2 | 2 | 1 |
| 2 | 2 | 2 | 2 |
| 2 | 2 | 2 | 3 |
| 2 | 2 | 2 | 4 |
| 2 | 2 | 3 | 1 |
| 2 | 2 | 3 | 2 |
| 2 | 2 | 3 | 3 |
| 2 | 2 | 3 | 4 |
| 2 | 2 | 4 | 1 |
| 2 | 2 | 4 | 2 |
| 2 | 2 | 4 | 3 |
| 2 | 2 | 4 | 4 |
:END:


#+BEGIN_SRC jupyter-python
def estractor(s,c):
    display(s)
    #e = c.pop(0) if c else False
    if c:
        return estractor( c.pop(0)|s, c )
    else:
        return s

estractor (ZZZ, primer_pivote(ZZZ))

#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

IndexErrorTraceback (most recent call last)
<ipython-input-233-b09a41b590f1> in <module>
      7         return s
      8 
----> 9 estractor (ZZZ, primer_pivote(ZZZ))

<ipython-input-198-f56af4c4fcd2> in primer_pivote(s)
     10             if primer_no_nulo(S):
     11                 return list(i)[:-1]+[primer_no_nulo(S)] #primer_no_nulo(S)
---> 12             S = j|S
     13 
     14 ppp = primer_pivote(ZZZ)

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __ror__(self, i)
    657         """
    658         if isinstance(i,int):
--> 659             return  Vector( (~self)|i , rpr='fila' )
    660 
    661         elif isinstance(i, (list,tuple,slice)):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __or__(self, j)
    596         """
    597         if isinstance(j, int):
--> 598             return self[j-1]
    599 
    600         elif isinstance(j, (list,tuple) ):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __getitem__(self, i)
    107     def __getitem__(self,i):
    108         """ Devuelve el i-ésimo coeficiente del Sistema """
--> 109         return self.lista[i]
    110 
    111     def __setitem__(self,i,value):

IndexError: list index out of range
:END:

#+BEGIN_SRC jupyter-python
estractor = lambda s,c: estractor( c.pop(0)|s, c ) if c else s

estractor (ZZZ, primer_pivote(ZZZ))
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

IndexErrorTraceback (most recent call last)
<ipython-input-232-33d5ef87f462> in <module>
      1 estractor = lambda s,c: estractor( c.pop(0)|s, c ) if c else s
      2 
----> 3 estractor (ZZZ, primer_pivote(ZZZ))

<ipython-input-198-f56af4c4fcd2> in primer_pivote(s)
     10             if primer_no_nulo(S):
     11                 return list(i)[:-1]+[primer_no_nulo(S)] #primer_no_nulo(S)
---> 12             S = j|S
     13 
     14 ppp = primer_pivote(ZZZ)

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __ror__(self, i)
    657         """
    658         if isinstance(i,int):
--> 659             return  Vector( (~self)|i , rpr='fila' )
    660 
    661         elif isinstance(i, (list,tuple,slice)):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __or__(self, j)
    596         """
    597         if isinstance(j, int):
--> 598             return self[j-1]
    599 
    600         elif isinstance(j, (list,tuple) ):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __getitem__(self, i)
    107     def __getitem__(self,i):
    108         """ Devuelve el i-ésimo coeficiente del Sistema """
--> 109         return self.lista[i]
    110 
    111     def __setitem__(self,i,value):

IndexError: list index out of range
:END:


#+BEGIN_SRC jupyter-python
def estractor(s,c):
    return estractor((c[1])|s, c[1:]) if c[1] else s

estractor (ZZZ, primer_pivote(ZZZ))
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

IndexErrorTraceback (most recent call last)
<ipython-input-207-9b9d4413e852> in <module>
      2     return estractor((c[1])|s, c[1:]) if c[1] else s
      3 
----> 4 estractor (ZZZ, primer_pivote(ZZZ))

<ipython-input-207-9b9d4413e852> in estractor(s, c)
      1 def estractor(s,c):
----> 2     return estractor((c[1])|s, c[1:]) if c[1] else s
      3 
      4 estractor (ZZZ, primer_pivote(ZZZ))

<ipython-input-207-9b9d4413e852> in estractor(s, c)
      1 def estractor(s,c):
----> 2     return estractor((c[1])|s, c[1:]) if c[1] else s
      3 
      4 estractor (ZZZ, primer_pivote(ZZZ))

<ipython-input-5-7c6a88b3ab87> in __ror__(self, i)
     13     def __ror__(self,i):
     14         """Hace exactamente lo mismo que el método __or__ por la derecha."""
---> 15         return self | i
     16 
     17     def __rand__(self,t):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __or__(self, j)
    175         [Vector([1, 0]), Vector([3, 0])] """
    176         if isinstance(j, int):
--> 177             return self[j-1]
    178 
    179         elif isinstance(j, (list,tuple) ):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __getitem__(self, i)
    107     def __getitem__(self,i):
    108         """ Devuelve el i-ésimo coeficiente del Sistema """
--> 109         return self.lista[i]
    110 
    111     def __setitem__(self,i,value):

IndexError: list index out of range
:END:


#+BEGIN_SRC jupyter-python
4|(1|(1|ZZZ))
u =[1]
u[1:]
#+END_SRC

#+RESULTS:
:RESULTS:
[]
:END:


#+BEGIN_SRC jupyter-python
list(Localizador(profundidad(ZZZ)))
#+END_SRC

#+RESULTS:
:RESULTS:
| 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 2 |
| 1 | 1 | 1 | 3 |
| 1 | 1 | 1 | 4 |
| 1 | 1 | 2 | 1 |
| 1 | 1 | 2 | 2 |
| 1 | 1 | 2 | 3 |
| 1 | 1 | 2 | 4 |
| 1 | 1 | 3 | 1 |
| 1 | 1 | 3 | 2 |
| 1 | 1 | 3 | 3 |
| 1 | 1 | 3 | 4 |
| 1 | 1 | 4 | 1 |
| 1 | 1 | 4 | 2 |
| 1 | 1 | 4 | 3 |
| 1 | 1 | 4 | 4 |
| 1 | 2 | 1 | 1 |
| 1 | 2 | 1 | 2 |
| 1 | 2 | 1 | 3 |
| 1 | 2 | 1 | 4 |
| 1 | 2 | 2 | 1 |
| 1 | 2 | 2 | 2 |
| 1 | 2 | 2 | 3 |
| 1 | 2 | 2 | 4 |
| 1 | 2 | 3 | 1 |
| 1 | 2 | 3 | 2 |
| 1 | 2 | 3 | 3 |
| 1 | 2 | 3 | 4 |
| 1 | 2 | 4 | 1 |
| 1 | 2 | 4 | 2 |
| 1 | 2 | 4 | 3 |
| 1 | 2 | 4 | 4 |
| 2 | 1 | 1 | 1 |
| 2 | 1 | 1 | 2 |
| 2 | 1 | 1 | 3 |
| 2 | 1 | 1 | 4 |
| 2 | 1 | 2 | 1 |
| 2 | 1 | 2 | 2 |
| 2 | 1 | 2 | 3 |
| 2 | 1 | 2 | 4 |
| 2 | 1 | 3 | 1 |
| 2 | 1 | 3 | 2 |
| 2 | 1 | 3 | 3 |
| 2 | 1 | 3 | 4 |
| 2 | 1 | 4 | 1 |
| 2 | 1 | 4 | 2 |
| 2 | 1 | 4 | 3 |
| 2 | 1 | 4 | 4 |
| 2 | 2 | 1 | 1 |
| 2 | 2 | 1 | 2 |
| 2 | 2 | 1 | 3 |
| 2 | 2 | 1 | 4 |
| 2 | 2 | 2 | 1 |
| 2 | 2 | 2 | 2 |
| 2 | 2 | 2 | 3 |
| 2 | 2 | 2 | 4 |
| 2 | 2 | 3 | 1 |
| 2 | 2 | 3 | 2 |
| 2 | 2 | 3 | 3 |
| 2 | 2 | 3 | 4 |
| 2 | 2 | 4 | 1 |
| 2 | 2 | 4 | 2 |
| 2 | 2 | 4 | 3 |
| 2 | 2 | 4 | 4 |
:END:


#+BEGIN_SRC jupyter-python
k = 0


def bpiv(s, k=0, cc=[]):
    def intento(s,l):
        return cc +  [primer_no_nulo(s,k)] if es_numero(1|s) else bpiv(l|s, k, cc + [[i for i,c in enumerate(s, 1)][0]])
    l = 1
    return intento(s,l) if intento(s,1)[-1] else intento(s,l+1)

def bpivote(s, k=0, cc=[], l=1):
    if es_numero(1|s):
        #print([type(c) for c in s])
        #display(Sistema([c for i,c in enumerate(s, 1) if (c!=0 and i>k)]))
        display(Vector(s,'fila'))
        print(cc + [primer_no_nulo(s,k)])
        return cc + [primer_no_nulo(s,k)]
    else:
        #print([type(c) for c in s])
        print(l)
        display(Sistema([c for c in s]))
        cc = cc + [[i for i,c in enumerate(s, 1)][0]]
        #return  bpivote((~s)[0], k, cc)
        return  bpivote(l|s, k, cc,1) if bpivote(l|s, k, cc, l)[-1] else bpivote((l+1)|s, k, cc, l+1)
        
    
def BuscaNuevoPivote(self, sust=[], r=0):
    pp = bpivote(self, r)
    #pp = bpiv(self, r)
    #while pp in colExcluida:
    #    pp = ppivote(self, pp)
    return pp

sust=[]

cc = BuscaNuevoPivote(ZZZ,sust,0)
print(cc)
#([i for i,c in enumerate(ZZZ[0],1) if (isinstance (c, int) and c!=0 and i>k)] + [0])
#+END_SRC

#+RESULTS:
:RESULTS:
1
[[file:./.ob-jupyter/61b07c8042e477dc3a1320e67a2541cb2f2107bd.png]]
1
[[file:./.ob-jupyter/ebca9d14e2c04f473158553ea5c6fc1013201ed6.png]]
1
[[file:./.ob-jupyter/b8b314546ac405914fd45cecbc57325e6eb38ae9.png]]
[[file:./.ob-jupyter/4712e0d7ac268f428ae1ad2860cbf195f5dc2c8c.png]]
[1, 1, 1, False]
[[file:./.ob-jupyter/4712e0d7ac268f428ae1ad2860cbf195f5dc2c8c.png]]
[1, 1, 1, False]
2
[[file:./.ob-jupyter/b8b314546ac405914fd45cecbc57325e6eb38ae9.png]]
[[file:./.ob-jupyter/4712e0d7ac268f428ae1ad2860cbf195f5dc2c8c.png]]
[1, 1, 1, False]
# [goto error]

IndexErrorTraceback (most recent call last)
<ipython-input-69-70e25644b321> in <module>
     37 sust=[]
     38 
---> 39 cc = BuscaNuevoPivote(ZZZ,sust,0)
     40 print(cc)
     41 #([i for i,c in enumerate(ZZZ[0],1) if (isinstance (c, int) and c!=0 and i>k)] + [0])

<ipython-input-69-70e25644b321> in BuscaNuevoPivote(self, sust, r)
     29 
     30 def BuscaNuevoPivote(self, sust=[], r=0):
---> 31     pp = bpivote(self, r)
     32     #pp = bpiv(self, r)
     33     #while pp in colExcluida:

<ipython-input-69-70e25644b321> in bpivote(s, k, cc, l)
     25         cc = cc + [[i for i,c in enumerate(s, 1)][0]]
     26         #return  bpivote((~s)[0], k, cc)
---> 27         return  bpivote(l|s, k, cc,1) if bpivote(l|s, k, cc, l)[-1] else bpivote((l+1)|s, k, cc, l+1)
     28 
     29 

<ipython-input-69-70e25644b321> in bpivote(s, k, cc, l)
     25         cc = cc + [[i for i,c in enumerate(s, 1)][0]]
     26         #return  bpivote((~s)[0], k, cc)
---> 27         return  bpivote(l|s, k, cc,1) if bpivote(l|s, k, cc, l)[-1] else bpivote((l+1)|s, k, cc, l+1)
     28 
     29 

<ipython-input-69-70e25644b321> in bpivote(s, k, cc, l)
     25         cc = cc + [[i for i,c in enumerate(s, 1)][0]]
     26         #return  bpivote((~s)[0], k, cc)
---> 27         return  bpivote(l|s, k, cc,1) if bpivote(l|s, k, cc, l)[-1] else bpivote((l+1)|s, k, cc, l+1)
     28 
     29 

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __ror__(self, i)
    657         """
    658         if isinstance(i,int):
--> 659             return  Vector( (~self)|i , rpr='fila' )
    660 
    661         elif isinstance(i, (list,tuple,slice)):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __or__(self, j)
    596         """
    597         if isinstance(j, int):
--> 598             return self[j-1]
    599 
    600         elif isinstance(j, (list,tuple) ):

~/.local/lib/python3.9/site-packages/nacal/nacal.py in __getitem__(self, i)
    107     def __getitem__(self,i):
    108         """ Devuelve el i-ésimo coeficiente del Sistema """
--> 109         return self.lista[i]
    110 
    111     def __setitem__(self,i,value):

IndexError: list index out of range
:END:

#+BEGIN_SRC jupyter-python
next(bpivote(ZZZ,i) for i i , False)
#+END_SRC


#+BEGIN_SRC jupyter-python
(~ZZZ)|1
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/083bca2830fc7ff15ed08db1cca8bae5789a3fb5.png]]
:END:


#+BEGIN_SRC jupyter-python
~((~ZZZ)|1)|1
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/485013c08efe64014beadfd5ac11e756231076d4.png]]
:END:

#+BEGIN_SRC jupyter-python
(~(~(~ZZZ|1)|1)|1)|3
#+END_SRC

#+RESULTS:
:RESULTS:
4
:END:


#+BEGIN_SRC jupyter-python
3|(1|(1|(1|ZZZ)))
#+END_SRC

#+RESULTS:
:RESULTS:
4
:END:


#+BEGIN_SRC jupyter-python
def BuscaNuevoPivote(self, sust=[], r=0):
    ppivote = lambda v, k=0:\
        ( [i for i,c in enumerate(v.subs(sust), 1) if (c!=0 and i>k)] + [0] )[0]
    pp = ppivote(self, r)
    while pp in colExcluida:
        pp = ppivote(self, pp)
    return pp

for c,i in enumerate A:
    p = BuscaNuevoPivote(i|A, sust); 
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
  File "<ipython-input-94-fb74572c4f67>", line 10
    for c,i in enumerate A:
                         ^
SyntaxError: invalid syntax
:END:



#+BEGIN_SRC jupyter-python
ElimR(Vector([1,2,3,4]))
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

AttributeErrorTraceback (most recent call last)
<ipython-input-42-a13affc374fb> in <module>
----> 1 ElimR(Vector([1,2,3,4]))

<ipython-input-41-7bbcf7b699f9> in __init__(self, data, rep, sust, repsust)
     33         A = type(data)(data.subs(sust)); A.TrC = A.TrF = []; A.pasos=[A.TrF, A.TrC];
     34         r = 0;  transformaciones = [];  colExcluida = set()
---> 35         for i in range(1,A.m+1):
     36             p = BuscaNuevoPivote(i|A, sust);
     37             if p:

AttributeError: 'Vector' object has no attribute 'm'
:END:


Si 

#+BEGIN_SRC jupyter-python
B=Matrix([Vector([7,0,0,7]),Vector([3,-1,0,3]),Vector([-2,-5,9,-2]),a]); B
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/361efb73ac4341425af8876ecdcbecb3f2b60ce6.png]]
:END:

#+BEGIN_SRC jupyter-python
BB = Matrix([VA(v) for v in B])
list((BB|1).fmp.values())
#+END_SRC

#+RESULTS:
:RESULTS:
| 1/2 | 1/2 |
:END:

Veamos si el espacio generado por las columnas es un subespacio probabilizable
#+BEGIN_SRC jupyter-python
all([v.es_indicatriz() for v in BB.R()])
#+END_SRC

#+RESULTS:
:RESULTS:
True
:END:


** Función lineal

si 
$$\begin{bmatrix}
\Mat{A}\\\hline
\Mat{FA}
\end{bmatrix}
\Mat{E}
=
\begin{bmatrix}
\Mat{I}\\\hline
\Mat{FAE}
\end{bmatrix}$$
entonces $\Mat{E}$ es la inversa de $\Mat{A}$ y por tanto la matriz
de abajo es $\Mat{FI}=\Mat{F}$, es decir, es la matriz de la transformación lineal.

#+BEGIN_SRC jupyter-python
A = Matrix([Vector([1,2,5,0,1]),Vector([0,1,-3,1,0]),Vector([-2,1,0,1,1])])
F = Matrix([[1,2,-3,2,2],[2,-5,-1,3,-4]])
B = F*A
B
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/0d7cb3419da273efead5f7d047b88a3a9e8d291f.png]]
:END:

#+BEGIN_SRC jupyter-python :results raw
Elim(A.apila(B).cfil({5}))
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/12dfa1d172879ff1c29491b55a7748b091b11d22.png]]


#+BEGIN_SRC jupyter-python
A = Matrix([Vector([1,2,5,0,1]),Vector([0,1,-3,1,0]),Vector([-2,1,0,1,1])])
A*Vector([-3,4,7])
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/38a2adad3f819c01f1d31dda0bb218c67149d398.png]]
:END:
#+BEGIN_SRC jupyter-python
B = Matrix([[0,2,3],[1,1,1],[2,-1,-2],[0,1,0]])
B
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/c341d8e89351833239d1cb011b562bd2a4acd59e.png]]
:END:

#+BEGIN_SRC jupyter-python
v = A*Vector([-3,4,7])
#+END_SRC

#+BEGIN_SRC jupyter-python
Elim(A.concatena(Matrix([-v])).apila(B.concatena(Matrix([V0(4)]))).ccol({3}).cfil({5}),1)
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \left[ \begin{array}{ccc|c}1&0&-2&172&1&1&-55&-3&0&270&1&1&-111&0&1&-4 \hline 0&2&3&01&1&1&02&-1&-2&00&1&0&0 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(2\right)\mathbf{1}+\mathbf{3} \right]\left[\left(-17\right)\mathbf{1}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{ccc|c}1&0&0&02&1&5&-395&-3&10&-580&1&1&-111&0&3&-21 \hline 0&2&3&01&1&3&-172&-1&2&-340&1&0&0 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(-5\right)\mathbf{2}+\mathbf{3} \right]\left[\left(39\right)\mathbf{2}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{ccc|c}1&0&0&02&1&0&05&-3&25&-1750&1&-4&281&0&3&-21 \hline 0&2&-7&781&1&-2&222&-1&7&-730&1&-5&39 \end{array} \right]\xrightarrow{\underset{\begin{subarray}{c} \left[\left(7\right)\mathbf{3}+\mathbf{4} \right]\end{subarray}}{\pmb{\tau}}}\left[ \begin{array}{ccc|c}1&0&0&02&1&0&05&-3&25&00&1&-4&01&0&3&0 \hline 0&2&-7&291&1&-2&82&-1&7&-240&1&-5&4 \end{array} \right]$
[[file:./.ob-jupyter/6676f15dffbd63b9277d662cf7f97290c2680c27.png]]
:END:
 

* Ejemplo de la demostración en el libro sobre la /construcción de subespacios independientes e isomorfos/.

En dicho ejemplo
$\mathcal{R}_1=\mathcal{L}(\Vect[1]{u},\Vect[2]{u})$ y $\mathcal{R}_2=\mathcal{L}(\Vect[1]{w},\Vect[2]{w},\Vect[3]{w})$ 

Para usar variables simbólicas correspondientes a los anteriores
vectores cargamos el siguiente módulo
#+BEGIN_SRC jupyter-python :results silent 
from sympy import symbols
#+END_SRC

Generemos la lista con los cinco vectores (aquí los subíndices
comienzan con cero como es costumbre en python).

#+BEGIN_SRC jupyter-python
R1=symbols('u:2')
R2=symbols('w:3')
lista=R1+R2
lista
#+END_SRC

#+RESULTS:
:RESULTS:
| u0 | u1 | w0 | w1 | w2 |
:END:

El productorio aspa entre la lista ~R1~ y ~R2~ nos da el conjunto de
todos pares posibles $(\Vect[i]{u},\Vect[j]{w})$ con $i=0:1$ y $j=0:2$

#+BEGIN_SRC jupyter-python :results verbatim :display text/plain
B = [x for x in aspa((R1,R2)) ]
B
#+END_SRC

#+RESULTS:
:RESULTS:
| u0 | w0 |
| u0 | w1 |
| u0 | w2 |
| u1 | w0 |
| u1 | w1 |
| u1 | w2 |
:END:

Enumerando los pares y indicando si cada uno de los vectores está o no
en el par enumerado, construimos los vectores versión /estrella/ de la
demo (aquí se ha seguido la numeración consecutiva de todos los pares,
y por eso obtenemos unos vectores estrella diferentes de los del
libro). Así la primera columna es $\Vect[0]{u}^*$, la segunda
$\Vect[1]{u}^*$, la tercera $\Vect[0]{w}^*$, la cuarta
$\Vect[1]{w}^*$ y la quinta $\Vect[2]{w}^*$

#+BEGIN_SRC jupyter-python :results raw
M = Matrix([ [ int(i in w) for i in lista ] for w in B]).ccol({len(R1),len(R1+R2)})
M
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/6ad07a9f4090a8abb61ea436098dcf4c51097faf.png]]


Así pues, las dos primeras columnas son la base canónica del
subespacio probabilizable $\mathcal{R}_1^*$ isomorfo a $\mathcal{R}_1$
y las tres últimas columnas son la base canónica del subespacio
probabilizable $\mathcal{R}_2^*$ isomorfo a $\mathcal{R}_2$. 

Obtenemos la envolvente probabilizable de ambos espacios con todos los
productos de Hadamard entre los vectores indicatrices de ambas bases.

#+BEGIN_SRC jupyter-python :results silent
prodH     = lambda u,w: Vector([u[i]*w[i] for i in range(u.n)])
productoH = lambda x,n: V1(n) if not x else prodH(x[0], productoH(x[1:], n) )
#+END_SRC

#+BEGIN_SRC jupyter-python
n = M.m
Q = [x for x in aspa([M[:2],M[2:]]) ]
baseC = Sistema([v for v in [productoH(s,n) for s in Q] if v.no_es_nulo()])
baseC
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/6dbdfdc72f3857afce3ebfc0e0c511108feef2e0.png]]
:END:

En este caso la base canónica de la envolvente son las columnas de la
matriz identidad de orden 6.


* Lanzamiento de $m$ monedas

Para generar variables simbólicas con doble subíndice usaré el siguiente módulo
#+BEGIN_SRC jupyter-python :results silent
from sympy import Symbol
#+END_SRC

En el lanzamiento de una moneda hay dos ~lados~ posibles en cada
lanzamiento (cara o cruz). También especificamos el número de
lanzamientos, ~rep~ (/poner más de 14 lanzamientos empieza a ser
demasiado/)
#+BEGIN_SRC jupyter-python :results silent
lados = 2
rep   = 4 # 14
#+END_SRC

La siguiente función auxiliar genera una tupla con los elementos en
las tuplas de una lista de tuplas
#+BEGIN_SRC jupyter-python :results silent
listaElementos = lambda x: () if not x else x[0] + listaElementos(x[1:])
#+END_SRC

Generamos una lista ~A~ de pares. El primer par corresponde al primer
lanzamiento, el segundo par al segundo, etc. En cada par, la primera
variable corresponde al resultado cara y la segunda al resultado
cruz. Por tanto el primer subíndice de cada variable simbólica indica
el número de lanzamiento, el segundo subíndice indica cara (0) o cruz
(1).
#+BEGIN_SRC jupyter-python :display text/plain
A = [tuple(Symbol(f'u_{i}{j}' ) for j in range(lados)) for i in range(rep) ]
A
#+END_SRC

#+RESULTS:
:RESULTS:
| u_00 | u_01 |
| u_10 | u_11 |
| u_20 | u_21 |
| u_30 | u_31 |
:END:

** Repetición de los pasos del ejemplo de la demostración correspondiente a la sección anterior

~B~ es una lista con el conjunto de las /n/-tuplas (donde /n/ es el
número de lanzamientos) con todos los resultados posibles.

_¡Ojo! Esta lista crece mucho con el número de lanzamientos ~rep~; es
mejor no pedir que se muestre el resultado en pantalla_ (salvo cuando
~rep~ es un número reducido, por ejemplo, 3 o menos)
#+BEGIN_SRC jupyter-python
B = [x for x in aspa(A) ]
if rep<=4: print(B)
#+END_SRC

#+RESULTS:
:RESULTS:
[(u_00, u_10, u_20, u_30), (u_00, u_10, u_20, u_31), (u_00, u_10, u_21, u_30), (u_00, u_10, u_21, u_31), (u_00, u_11, u_20, u_30), (u_00, u_11, u_20, u_31), (u_00, u_11, u_21, u_30), (u_00, u_11, u_21, u_31), (u_01, u_10, u_20, u_30), (u_01, u_10, u_20, u_31), (u_01, u_10, u_21, u_30), (u_01, u_10, u_21, u_31), (u_01, u_11, u_20, u_30), (u_01, u_11, u_20, u_31), (u_01, u_11, u_21, u_30), (u_01, u_11, u_21, u_31)]
:END:

*** Construcción del subespacio probabilizable envolvente $\mathcal{E}$

_¡De nuevo esta matriz crece mucho con el número de lanzamientos
~rep~! Es mejor no pedir que se muestre el resultado en pantalla_ si
~rep~ es mayor que 4.

Las columnas de las submatrices de $\mathcal{E}$ son las bases
canónicas de cada una de las réplicas $\mathcal{R^*_j}$ del espacio
probabilizable $\mathcal{R}$ original correspondiente al lanzamiento
de una moneda.

#+BEGIN_SRC jupyter-python 
E = Matrix([ [ int(i in w) for i in listaElementos(A) ] for w in B]).ccol({2,4,6})
if rep<=4: display(E)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/c0852a676458da50155b23bd26a5c3897774c020.png]]
:END:

El número de filas de esta matriz corresponde al número de posibles
resultados al lanzar ~rep~ veces una moneda:

#+BEGIN_SRC jupyter-python
print('Number of possible outcomes: ', E.m)
#+END_SRC

#+RESULTS:
:RESULTS:
Number of possible outcomes:  16
:END:

*** Construcción del espacio muestral para el lanzamiento de /m/ monedas.

Para construir el espacio muestral para el lanzamiento de /m/ monedas,
en lugar de las bases canónicas estrella, necesitamos /m/ embriones
(variables aleatorias) correspondientes a los espacios probabilizables
$\mathcal{R^*_j}$

Las columnas de la siguiente matriz son embriones de cada una de las
réplicas $\mathcal{R^*_j}$ del espacio probabilizable $\mathcal{R}$
original correspondiente al lanzamiento de una moneda.
#+BEGIN_SRC jupyter-python
SampleSp = Matrix([SubEspacioProb(Matrix(E[i*lados:(i+1)*lados])).embrion for i in range(rep)])
if rep<=4  and lados<=3: display(SampleSp)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/7ab0d676894ece8a07d868915f209574fd1ea491.png]]
:END:

El conjunto de las filas de la matriz anterior es el espacio
muestral. En cada fila, un ~1~ corresponde al caso "/la moneda muestra
cara/" (H) y un ~2~ corresponde al caso "/la moneda muestra cruz/"
(T). Por tanto, las filas de la matriz anterior muestran todos los
resultados posibles al lanzar una moneda ~rep~ veces, donde ~rep~ es
el número de columnas, es decir de variables aleatorias (donde cada
una de ellas corresponde a un lanzamiento).


*** Experimento

Así, "/realizar/" el experimento consiste en evaluar las variables
aleatorias de la matriz anterior (las columnas) en un mismo elemento
$n$ de su dominio $\Omega$ (se suele denominar a dicho elemento
/suceso elemental/); es decir, consiste en mirar la componente
$n$-ésima de los ~rep~ embriones, o lo que es lo mismo, en elegir
"una" fila de la matriz.

El azar consiste en que no sabemos en que punto del dominio se
evaluarán las variables aleatorias. Para simular dicha circunstancia
usaremos el modulo ~random~ para escoger una fila al azar.

#+BEGIN_SRC jupyter-python :results silent
import random
#+END_SRC


#+BEGIN_SRC jupyter-python
trial   = random.choice(range(SampleSp.m))
outcome = trial|SampleSp
print(trial)
outcome
#+END_SRC

#+RESULTS:
:RESULTS:
0
[[file:./.ob-jupyter/86e465bac0c10c5fe3e89160980730a5bb5f1d64.png]]
:END:

#+BEGIN_SRC jupyter-python
print('number of heads: ', sum([int(e==1) for e in outcome]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of heads:  0
:END:

#+BEGIN_SRC jupyter-python
print('number of tails: ', sum([int(e==2) for e in trial|SampleSp]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of tails:  4
:END:

**** Frecuencia de los posibles resultados

Podemos contar el número de caras en cada uno de los posibles
resultados
#+BEGIN_SRC jupyter-python
res = [sum([int(e==1) for e in r]) for r in (~SampleSp).lista]
res
#+END_SRC

#+RESULTS:
:RESULTS:
| 4 | 3 | 3 | 2 | 3 | 2 | 2 | 1 | 3 | 2 | 2 | 1 | 2 | 1 | 1 | 0 |
:END:

Podemos mirar la frecuencia contando el número de veces que aparece
cada lado en cada caso.

#+BEGIN_SRC jupyter-python
def count_elements(seq) -> dict:
    """Tally elements from `seq`."""
    hist = {}
    for i in seq:
        hist[i] = hist.get(i, 0) + 1
    return hist
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
count_elements(res)
#+END_SRC

#+RESULTS:
:RESULTS:
| 4: | 1 | 3: | 4 | 2: | 6 | 1: | 4 | 0: | 1 |
:END:

O con un histograma

#+BEGIN_SRC jupyter-python
import numpy as np
import matplotlib.pyplot as plt

# An "interface" to matplotlib.axes.Axes.hist() method
n, bins, patches = plt.hist(x=res, bins='auto', color='#0504aa',
                            alpha=0.7, rwidth=0.85)
plt.grid(axis='y', alpha=0.75)
plt.xlabel('Number of heads')
plt.ylabel('Frequency')
plt.title('Histogram of possible number of heads')
#plt.text(23, 45, r'$\mu=15, b=3$')
maxfreq = n.max()
# Set a clean upper y-axis limit.
plt.ylim(ymax=np.ceil(maxfreq / 10) * 10 if maxfreq % 10 else maxfreq + 10)

#+END_SRC

#+RESULTS:
:RESULTS:
| 0.0 | 10.0 |
[[file:./.ob-jupyter/0a35173cc0ab0fb451b2f97928cb37257c801972.png]]
:END:

Este histograma de frecuencias nada tiene que ver con la probabilidad
de cada resultado (salvo si la moneda es justa y dividimos cada
frecuencia absoluta del histograma por el número de casos).

Para reflejar la probabilidad es necesario emplear el espacio euclídeo
de probabilidad, es decir, al espacio probabilizable hay que definir
una función esperanza. Lo podemos hacer incorporando una función de
masa de probabilidad, para los distintos valores de la variable
aleatoria embrión, o alternativamente asignando una probabilidad a
cada vector de la base canónica. 

Por cuestiones didácticas implementaremos ambas vías.


* Lanzamiento de $m$ dados con $k$ lados

Indicamos el numero de ~lados~ y el número de lanzamientos, ~rep~
(/ambos números deben ser pequeños o tendremos problemas con la
memoria del ordenador/)
#+BEGIN_SRC jupyter-python :results silent
lados = 3
rep   = 4 # ó 5 (con 3 lados y 6 repeticiones ya tarda mucho)
#+END_SRC

Generamos una lista ~A~ de $k$-tuplas. La primera corresponde al
primer lanzamiento, la segunda par al segundo, etc. En cada $k$-tupla,
la primera variable corresponde al resultado primera cara y la segunda
al resultado segunda cara, etc. Por tanto el primer subíndice de cada
variable simbólica indica el número de lanzamiento, el segundo
subíndice indica el lado mostrado por el dado.
#+BEGIN_SRC jupyter-python :display text/plain
A = [tuple(Symbol(f'u_{i}{j}' ) for j in range(lados)) for i in range(rep) ]
A
#+END_SRC

#+RESULTS:
:RESULTS:
| u_00 | u_01 | u_02 |
| u_10 | u_11 | u_12 |
| u_20 | u_21 | u_22 |
| u_30 | u_31 | u_32 |
:END:

** Repetición de los pasos del ejemplo de la demostración correspondiente a la sección anterior

~B~ es una lista con el conjunto de las /n/-tuplas (donde /n/ es el
número de lanzamientos) con todos los resultados posibles.

_¡Ojo! Esta lista crece mucho con el número de lanzamientos ~rep~; es
mejor no pedir que se muestre el resultado en pantalla_ (salvo cuando
~rep~ es un número reducido, por ejemplo, 3 o menos)
#+BEGIN_SRC jupyter-python
B = [x for x in aspa(A) ]
if rep<=4 and lados<=3: print(B)
#+END_SRC

#+RESULTS:
:RESULTS:
[(u_00, u_10, u_20, u_30), (u_00, u_10, u_20, u_31), (u_00, u_10, u_20, u_32), (u_00, u_10, u_21, u_30), (u_00, u_10, u_21, u_31), (u_00, u_10, u_21, u_32), (u_00, u_10, u_22, u_30), (u_00, u_10, u_22, u_31), (u_00, u_10, u_22, u_32), (u_00, u_11, u_20, u_30), (u_00, u_11, u_20, u_31), (u_00, u_11, u_20, u_32), (u_00, u_11, u_21, u_30), (u_00, u_11, u_21, u_31), (u_00, u_11, u_21, u_32), (u_00, u_11, u_22, u_30), (u_00, u_11, u_22, u_31), (u_00, u_11, u_22, u_32), (u_00, u_12, u_20, u_30), (u_00, u_12, u_20, u_31), (u_00, u_12, u_20, u_32), (u_00, u_12, u_21, u_30), (u_00, u_12, u_21, u_31), (u_00, u_12, u_21, u_32), (u_00, u_12, u_22, u_30), (u_00, u_12, u_22, u_31), (u_00, u_12, u_22, u_32), (u_01, u_10, u_20, u_30), (u_01, u_10, u_20, u_31), (u_01, u_10, u_20, u_32), (u_01, u_10, u_21, u_30), (u_01, u_10, u_21, u_31), (u_01, u_10, u_21, u_32), (u_01, u_10, u_22, u_30), (u_01, u_10, u_22, u_31), (u_01, u_10, u_22, u_32), (u_01, u_11, u_20, u_30), (u_01, u_11, u_20, u_31), (u_01, u_11, u_20, u_32), (u_01, u_11, u_21, u_30), (u_01, u_11, u_21, u_31), (u_01, u_11, u_21, u_32), (u_01, u_11, u_22, u_30), (u_01, u_11, u_22, u_31), (u_01, u_11, u_22, u_32), (u_01, u_12, u_20, u_30), (u_01, u_12, u_20, u_31), (u_01, u_12, u_20, u_32), (u_01, u_12, u_21, u_30), (u_01, u_12, u_21, u_31), (u_01, u_12, u_21, u_32), (u_01, u_12, u_22, u_30), (u_01, u_12, u_22, u_31), (u_01, u_12, u_22, u_32), (u_02, u_10, u_20, u_30), (u_02, u_10, u_20, u_31), (u_02, u_10, u_20, u_32), (u_02, u_10, u_21, u_30), (u_02, u_10, u_21, u_31), (u_02, u_10, u_21, u_32), (u_02, u_10, u_22, u_30), (u_02, u_10, u_22, u_31), (u_02, u_10, u_22, u_32), (u_02, u_11, u_20, u_30), (u_02, u_11, u_20, u_31), (u_02, u_11, u_20, u_32), (u_02, u_11, u_21, u_30), (u_02, u_11, u_21, u_31), (u_02, u_11, u_21, u_32), (u_02, u_11, u_22, u_30), (u_02, u_11, u_22, u_31), (u_02, u_11, u_22, u_32), (u_02, u_12, u_20, u_30), (u_02, u_12, u_20, u_31), (u_02, u_12, u_20, u_32), (u_02, u_12, u_21, u_30), (u_02, u_12, u_21, u_31), (u_02, u_12, u_21, u_32), (u_02, u_12, u_22, u_30), (u_02, u_12, u_22, u_31), (u_02, u_12, u_22, u_32)]
:END:

*** Construcción del subespacio probabilizable envolvente $\mathcal{E}$

_¡De nuevo esta matriz crece mucho con el número de lanzamientos ~rep~
y el número de lados (~lados~)! Es mejor no pedir que se muestre el
resultado en pantalla_ si ~rep~ es mayor que 4.

Las columnas de las submatrices de $\mathcal{E}$ son las bases
canónicas de cada una de las réplicas $\mathcal{R^*_j}$ del espacio
probabilizable $\mathcal{R}$ original correspondiente al lanzamiento
de una moneda.

#+BEGIN_SRC jupyter-python 
E = Matrix([ [ int(i in w) for i in listaElementos(A) ] for w in B]).ccol({3,6,9},)
if rep<=4  and lados<=3: display(E)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b863f2c76742881c3f64cc55e313886e13d585f0.png]]
:END:

El número de filas de esta matriz corresponde al número de posibles
resultados al lanzar ~rep~ veces una moneda:

#+BEGIN_SRC jupyter-python
print('Number of possible outcomes: ', E.m)
#+END_SRC

#+RESULTS:
:RESULTS:
Number of possible outcomes:  81
:END:

*** Construcción del espacio muestral para el lanzamiento de /m/ monedas.

Para construir el espacio muestral para el lanzamiento de /m/ monedas,
en lugar de las bases canónicas estrella, necesitamos /m/ embriones
(variables aleatorias) correspondientes a los espacios probabilizables
$\mathcal{R^*_j}$

Las columnas de la siguiente matriz son embriones de cada una de las
réplicas $\mathcal{R^*_j}$ del espacio probabilizable $\mathcal{R}$
original correspondiente al lanzamiento de una moneda.
#+BEGIN_SRC jupyter-python :results silent
SampleSp = Matrix([SubEspacioProb(Matrix(E[i*lados:(i+1)*lados])).embrion for i in range(rep)])
if rep<=4  and lados<=3: display(SampleSp)
#+END_SRC

El conjunto de las filas de la matriz anterior es el espacio
muestral. En cada fila, un ~1~ corresponde al caso "/la moneda muestra
cara/" (H) y un ~2~ corresponde al caso "/la moneda muestra cruz/"
(T). Por tanto, las filas de la matriz anterior muestran todos los
resultados posibles al lanzar una moneda ~rep~ veces, donde ~rep~ es
el número de columnas, es decir de variables aleatorias (donde cada
una de ellas corresponde a un lanzamiento).


*** Experimento

Así, "/realizar/" el experimento consiste en evaluar las variables
aleatorias de la matriz anterior (las columnas) en un mismo elemento
$n$ de su dominio $\Omega$ (se suele denominar a dicho elemento
/suceso elemental/); es decir, consiste en mirar la componente
$n$-ésima de los ~rep~ embriones, o lo que es lo mismo, en elegir
"una" fila de la matriz.

El azar consiste en que no sabemos en que punto del dominio se
evaluarán las variables aleatorias. Para simular dicha circunstancia
usaremos el modulo ~random~ para escoger una fila al azar.

#+BEGIN_SRC jupyter-python :results silent
import random
#+END_SRC

#+BEGIN_SRC jupyter-python
trial   = random.choice(range(SampleSp.m))
outcome = trial|SampleSp
print(trial)
outcome
#+END_SRC

#+RESULTS:
:RESULTS:
25
[[file:./.ob-jupyter/738ac1d2dca82d57f0722c5bb1a51d5c5606a173.png]]
:END:

#+BEGIN_SRC jupyter-python
print('number of heads: ', sum([int(e==1) for e in outcome]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of heads:  2
:END:

#+BEGIN_SRC jupyter-python
print('number of tails: ', sum([int(e==2) for e in trial|SampleSp]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of tails:  0
:END:

#+BEGIN_SRC jupyter-python
print('number of tails: ', sum([int(e==3) for e in trial|SampleSp]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of tails:  2
:END:

**** Frecuencia de los posibles resultados

Podemos contar el número de veces que se nuestra la primera cara en
cada uno de los posibles resultados
#+BEGIN_SRC jupyter-python :results silent
res = [sum([int(e==1) for e in r]) for r in (~SampleSp).lista]
#+END_SRC

Podemos mirar la frecuencia contando el número de veces que aparece
cada lado en cada caso.

#+BEGIN_SRC jupyter-python :results silent
def count_elements(seq) -> dict:
    """Tally elements from `seq`."""
    hist = {}
    for i in seq:
        hist[i] = hist.get(i, 0) + 1
    return hist
#+END_SRC


#+BEGIN_SRC jupyter-python
count_elements(res)
#+END_SRC

#+RESULTS:
:RESULTS:
| 4: | 1 | 3: | 8 | 2: | 24 | 1: | 32 | 0: | 16 |
:END:

O con un histograma

#+BEGIN_SRC jupyter-python
import numpy as np
import matplotlib.pyplot as plt

# An "interface" to matplotlib.axes.Axes.hist() method
n, bins, patches = plt.hist(x=res, bins='auto', color='#0504aa',
                            alpha=0.7, rwidth=0.85)
plt.grid(axis='y', alpha=0.75)
plt.xlabel('Number of heads')
plt.ylabel('Frequency')
plt.title('Histogram of possible number of heads')
#plt.text(23, 45, r'$\mu=15, b=3$')
maxfreq = n.max()
# Set a clean upper y-axis limit.
plt.ylim(ymax=np.ceil(maxfreq / 10) * 10 if maxfreq % 10 else maxfreq + 10)

#+END_SRC

#+RESULTS:
:RESULTS:
| 0.0 | 40.0 |
[[file:./.ob-jupyter/1ae661447ef3c680e32246f99bea04e6186d6c30.png]]
:END:

Este histograma de frecuencias nada tiene que ver con la probabilidad
de cada resultado (salvo si la moneda es justa y dividimos cada
frecuencia absoluta del histograma por el número de casos).

Para reflejar la probabilidad es necesario emplear el espacio euclídeo
de probabilidad, es decir, al espacio probabilizable hay que definir
una función esperanza. Lo podemos hacer incorporando una función de
masa de probabilidad, para los distintos valores de la variable
aleatoria embrión, o alternativamente asignando una probabilidad a
cada vector de la base canónica. 

Por cuestiones didácticas implementaremos ambas vías.


* Repetición de un experimento con con $o$ posibles resultados $n$ veces

Imaginemos que los posibles resultados son 
#+BEGIN_SRC jupyter-python
ss = {0, sympy.pi, sympy.sqrt(2)} # sample space
Vector(list(ss))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/5688cf5af7a96197ac16974097c575cd47dfe6a5.png]]
:END:

Definamos una función de masa de probabilidad para dichos resultados
#+BEGIN_SRC jupyter-python
P = dict(zip(ss,[fracc(1,6),fracc(2,6),fracc(3,6)]))
P
#+END_SRC

#+RESULTS:
:RESULTS:
| 0: | 1/6 | sqrt | (2) | : | 1/3 | pi: | 1/2 |
:END:


Sea ~a~ una variable aleatoria cuyo rango (espacio muestral) es igual ~ss~
#+BEGIN_SRC jupyter-python
a = Vector([0, sympy.pi, 0, sympy.sqrt(2), 0, sympy.pi]); a
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/db9bbc9ab3ffec7ed2ea9edad8dd1bf5c1ad2e82.png]]
:END:

#+BEGIN_SRC jupyter-python
f = [v for k, v in sorted(P.items(), key=lambda pair: pair[0])]
f
#+END_SRC

#+RESULTS:
:RESULTS:
| 1/6 | 1/3 | 1/2 |
:END:


El espacio euclídeo de probabilidad engendrado por ~a~ con la función de masa de probabilidad es 
#+BEGIN_SRC jupyter-python
E = EspacioEuclideoProb(a,f)
E
#+END_SRC

#+RESULTS:
:RESULTS:
$\left\{ \boldsymbol{v}\in\mathbb{R}^6\ \left|\
\exists\boldsymbol{p}\in\mathbb{R}^3,\; \boldsymbol{v}= \left[
\begin{array}{ccc}1&0&00&1&01&0&00&0&11&0&00&1&0 \end{array}
\right]\boldsymbol{p}\right. \right\}\; = \;\left\{
\boldsymbol{v}\in\mathbb{R}^6\ \left|\ \left[
\begin{array}{cccccc}-1&0&1&0&0&0-1&0&0&0&1&00&-1&0&0&0&1
\end{array} \right]\boldsymbol{v}=\begin{pmatrix}0 0
0\end{pmatrix}\right.\right\}$
:END:



Indicamos el numero de ~lados~ y el número de lanzamientos, ~rep~
(/ambos números deben ser pequeños o tendremos problemas con la
memoria del ordenador/)
#+BEGIN_SRC jupyter-python :results silent
lados = 3
rep   = 4 # ó 5 (con 3 lados y 6 repeticiones ya tarda mucho)
#+END_SRC

Generamos una lista ~A~ de $k$-tuplas. La primera corresponde al
primer lanzamiento, la segunda par al segundo, etc. En cada $k$-tupla,
la primera variable corresponde al resultado primera cara y la segunda
al resultado segunda cara, etc. Por tanto el primer subíndice de cada
variable simbólica indica el número de lanzamiento, el segundo
subíndice indica el lado mostrado por el dado.
#+BEGIN_SRC jupyter-python :display text/plain
A = [tuple(Symbol(f'u_{i}{j}' ) for j in range(lados)) for i in range(rep) ]
A
#+END_SRC

#+RESULTS:
:RESULTS:
| u_00 | u_01 | u_02 |
| u_10 | u_11 | u_12 |
| u_20 | u_21 | u_22 |
| u_30 | u_31 | u_32 |
:END:

** Repetición de los pasos del ejemplo de la demostración correspondiente a la sección anterior

~B~ es una lista con el conjunto de las /n/-tuplas (donde /n/ es el
número de lanzamientos) con todos los resultados posibles.

_¡Ojo! Esta lista crece mucho con el número de lanzamientos ~rep~; es
mejor no pedir que se muestre el resultado en pantalla_ (salvo cuando
~rep~ es un número reducido, por ejemplo, 3 o menos)
#+BEGIN_SRC jupyter-python
B = [x for x in aspa(A) ]
if rep<=4 and lados<=3: print(B)
#+END_SRC

#+RESULTS:
:RESULTS:
[(u_00, u_10, u_20, u_30), (u_00, u_10, u_20, u_31), (u_00, u_10, u_20, u_32), (u_00, u_10, u_21, u_30), (u_00, u_10, u_21, u_31), (u_00, u_10, u_21, u_32), (u_00, u_10, u_22, u_30), (u_00, u_10, u_22, u_31), (u_00, u_10, u_22, u_32), (u_00, u_11, u_20, u_30), (u_00, u_11, u_20, u_31), (u_00, u_11, u_20, u_32), (u_00, u_11, u_21, u_30), (u_00, u_11, u_21, u_31), (u_00, u_11, u_21, u_32), (u_00, u_11, u_22, u_30), (u_00, u_11, u_22, u_31), (u_00, u_11, u_22, u_32), (u_00, u_12, u_20, u_30), (u_00, u_12, u_20, u_31), (u_00, u_12, u_20, u_32), (u_00, u_12, u_21, u_30), (u_00, u_12, u_21, u_31), (u_00, u_12, u_21, u_32), (u_00, u_12, u_22, u_30), (u_00, u_12, u_22, u_31), (u_00, u_12, u_22, u_32), (u_01, u_10, u_20, u_30), (u_01, u_10, u_20, u_31), (u_01, u_10, u_20, u_32), (u_01, u_10, u_21, u_30), (u_01, u_10, u_21, u_31), (u_01, u_10, u_21, u_32), (u_01, u_10, u_22, u_30), (u_01, u_10, u_22, u_31), (u_01, u_10, u_22, u_32), (u_01, u_11, u_20, u_30), (u_01, u_11, u_20, u_31), (u_01, u_11, u_20, u_32), (u_01, u_11, u_21, u_30), (u_01, u_11, u_21, u_31), (u_01, u_11, u_21, u_32), (u_01, u_11, u_22, u_30), (u_01, u_11, u_22, u_31), (u_01, u_11, u_22, u_32), (u_01, u_12, u_20, u_30), (u_01, u_12, u_20, u_31), (u_01, u_12, u_20, u_32), (u_01, u_12, u_21, u_30), (u_01, u_12, u_21, u_31), (u_01, u_12, u_21, u_32), (u_01, u_12, u_22, u_30), (u_01, u_12, u_22, u_31), (u_01, u_12, u_22, u_32), (u_02, u_10, u_20, u_30), (u_02, u_10, u_20, u_31), (u_02, u_10, u_20, u_32), (u_02, u_10, u_21, u_30), (u_02, u_10, u_21, u_31), (u_02, u_10, u_21, u_32), (u_02, u_10, u_22, u_30), (u_02, u_10, u_22, u_31), (u_02, u_10, u_22, u_32), (u_02, u_11, u_20, u_30), (u_02, u_11, u_20, u_31), (u_02, u_11, u_20, u_32), (u_02, u_11, u_21, u_30), (u_02, u_11, u_21, u_31), (u_02, u_11, u_21, u_32), (u_02, u_11, u_22, u_30), (u_02, u_11, u_22, u_31), (u_02, u_11, u_22, u_32), (u_02, u_12, u_20, u_30), (u_02, u_12, u_20, u_31), (u_02, u_12, u_20, u_32), (u_02, u_12, u_21, u_30), (u_02, u_12, u_21, u_31), (u_02, u_12, u_21, u_32), (u_02, u_12, u_22, u_30), (u_02, u_12, u_22, u_31), (u_02, u_12, u_22, u_32)]
:END:

*** Construcción del subespacio probabilizable envolvente $\mathcal{E}$

_¡De nuevo esta matriz crece mucho con el número de lanzamientos ~rep~
y el número de lados (~lados~)! Es mejor no pedir que se muestre el
resultado en pantalla_ si ~rep~ es mayor que 4.

Las columnas de las submatrices de $\mathcal{E}$ son las bases
canónicas de cada una de las réplicas $\mathcal{R^*_j}$ del espacio
probabilizable $\mathcal{R}$ original correspondiente al lanzamiento
de una moneda.

#+BEGIN_SRC jupyter-python 
E = Matrix([ [ int(i in w) for i in listaElementos(A) ] for w in B]).ccol({3,6,9},)
if rep<=4  and lados<=3: display(E)
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/b863f2c76742881c3f64cc55e313886e13d585f0.png]]
:END:

El número de filas de esta matriz corresponde al número de posibles
resultados al lanzar ~rep~ veces una moneda:

#+BEGIN_SRC jupyter-python
print('Number of possible outcomes: ', E.m)
#+END_SRC

#+RESULTS:
:RESULTS:
Number of possible outcomes:  81
:END:

*** Construcción del espacio muestral para el lanzamiento de /m/ monedas.

Para construir el espacio muestral para el lanzamiento de /m/ monedas,
en lugar de las bases canónicas estrella, necesitamos /m/ embriones
(variables aleatorias) correspondientes a los espacios probabilizables
$\mathcal{R^*_j}$

Las columnas de la siguiente matriz son embriones de cada una de las
réplicas $\mathcal{R^*_j}$ del espacio probabilizable $\mathcal{R}$
original correspondiente al lanzamiento de una moneda.
#+BEGIN_SRC jupyter-python :results silent
SampleSp = Matrix([SubEspacioProb(Matrix(E[i*lados:(i+1)*lados])).embrion for i in range(rep)])
if rep<=4  and lados<=3: display(SampleSp)
#+END_SRC

El conjunto de las filas de la matriz anterior es el espacio
muestral. En cada fila, un ~1~ corresponde al caso "/la moneda muestra
cara/" (H) y un ~2~ corresponde al caso "/la moneda muestra cruz/"
(T). Por tanto, las filas de la matriz anterior muestran todos los
resultados posibles al lanzar una moneda ~rep~ veces, donde ~rep~ es
el número de columnas, es decir de variables aleatorias (donde cada
una de ellas corresponde a un lanzamiento).


*** Experimento

Así, "/realizar/" el experimento consiste en evaluar las variables
aleatorias de la matriz anterior (las columnas) en un mismo elemento
$n$ de su dominio $\Omega$ (se suele denominar a dicho elemento
/suceso elemental/); es decir, consiste en mirar la componente
$n$-ésima de los ~rep~ embriones, o lo que es lo mismo, en elegir
"una" fila de la matriz.

El azar consiste en que no sabemos en que punto del dominio se
evaluarán las variables aleatorias. Para simular dicha circunstancia
usaremos el modulo ~random~ para escoger una fila al azar.

#+BEGIN_SRC jupyter-python :results silent
import random
#+END_SRC

#+BEGIN_SRC jupyter-python
trial   = random.choice(range(SampleSp.m))
outcome = trial|SampleSp
print(trial)
outcome
#+END_SRC

#+RESULTS:
:RESULTS:
25
[[file:./.ob-jupyter/738ac1d2dca82d57f0722c5bb1a51d5c5606a173.png]]
:END:

#+BEGIN_SRC jupyter-python
print('number of heads: ', sum([int(e==1) for e in outcome]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of heads:  2
:END:

#+BEGIN_SRC jupyter-python
print('number of tails: ', sum([int(e==2) for e in trial|SampleSp]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of tails:  0
:END:

#+BEGIN_SRC jupyter-python
print('number of tails: ', sum([int(e==3) for e in trial|SampleSp]) )
#+END_SRC

#+RESULTS:
:RESULTS:
number of tails:  2
:END:

**** Frecuencia de los posibles resultados

Podemos contar el número de veces que se nuestra la primera cara en
cada uno de los posibles resultados
#+BEGIN_SRC jupyter-python :results silent
res = [sum([int(e==1) for e in r]) for r in (~SampleSp).lista]
#+END_SRC

Podemos mirar la frecuencia contando el número de veces que aparece
cada lado en cada caso.

#+BEGIN_SRC jupyter-python :results silent
def count_elements(seq) -> dict:
    """Tally elements from `seq`."""
    hist = {}
    for i in seq:
        hist[i] = hist.get(i, 0) + 1
    return hist
#+END_SRC


#+BEGIN_SRC jupyter-python
count_elements(res)
#+END_SRC

#+RESULTS:
:RESULTS:
| 4: | 1 | 3: | 8 | 2: | 24 | 1: | 32 | 0: | 16 |
:END:

O con un histograma

#+BEGIN_SRC jupyter-python
import numpy as np
import matplotlib.pyplot as plt

# An "interface" to matplotlib.axes.Axes.hist() method
n, bins, patches = plt.hist(x=res, bins='auto', color='#0504aa',
                            alpha=0.7, rwidth=0.85)
plt.grid(axis='y', alpha=0.75)
plt.xlabel('Number of heads')
plt.ylabel('Frequency')
plt.title('Histogram of possible number of heads')
#plt.text(23, 45, r'$\mu=15, b=3$')
maxfreq = n.max()
# Set a clean upper y-axis limit.
plt.ylim(ymax=np.ceil(maxfreq / 10) * 10 if maxfreq % 10 else maxfreq + 10)

#+END_SRC

#+RESULTS:
:RESULTS:
| 0.0 | 40.0 |
[[file:./.ob-jupyter/1ae661447ef3c680e32246f99bea04e6186d6c30.png]]
:END:

Este histograma de frecuencias nada tiene que ver con la probabilidad
de cada resultado (salvo si la moneda es justa y dividimos cada
frecuencia absoluta del histograma por el número de casos).

Para reflejar la probabilidad es necesario emplear el espacio euclídeo
de probabilidad, es decir, al espacio probabilizable hay que definir
una función esperanza. Lo podemos hacer incorporando una función de
masa de probabilidad, para los distintos valores de la variable
aleatoria embrión, o alternativamente asignando una probabilidad a
cada vector de la base canónica. 

Por cuestiones didácticas implementaremos ambas vías.


* Espacio euclideo de probabilidad

** Ejemplo de la demostración en el libro sobre la /construcción de subespacios independientes e isomorfos/.

#+BEGIN_SRC jupyter-python
R1=symbols('u:2')
R2=symbols('w:3')
lista=R1+R2
lista
#+END_SRC

#+RESULTS:
:RESULTS:
| u0 | u1 | w0 | w1 | w2 |
:END:

#+BEGIN_SRC jupyter-python :results verbatim :display text/plain
B = [x for x in aspa((R1,R2)) ]
B
#+END_SRC

#+RESULTS:
:RESULTS:
| u0 | w0 |
| u0 | w1 |
| u0 | w2 |
| u1 | w0 |
| u1 | w1 |
| u1 | w2 |
:END:


#+BEGIN_SRC jupyter-python :results raw
M = Matrix([ [ int(i in w) for i in lista ] for w in B]).ccol({len(R1),len(R1+R2)})
fmp = [fracc(3,4),fracc(1,4),fracc(1,2),fracc(1,4),fracc(1,4)]
M = Matrix([VAI(M[i],fmp[i]) for i in range(M.n)])
M
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/36ec88454f41adc788a6a870544df39b70912d8a.png]]


#+BEGIN_SRC jupyter-python
prodH     = lambda u,w: VAI([u[i]*w[i] for i in range(u.n)],u.prb*w.prb)
productoH = lambda x,n: VAI(V1(n),1) if not x else prodH(x[0], productoH(x[1:], n) )
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python
n = M.m
Q = [x for x in aspa([M[:2],M[2:]]) ]
baseC = Sistema([v for v in [productoH(s,n) for s in Q] if v.no_es_nulo()])
print([(baseC[i]).prb for i in range(len(baseC))])
sum([(baseC[i]).prb for i in range(len(baseC))])
#+END_SRC

#+RESULTS:
:RESULTS:
[3/8, 3/16, 3/16, 1/8, 1/16, 1/16]
$\displaystyle 1$
:END:


#+BEGIN_SRC jupyter-python
class SampleSpace(Matrix):
    def __init__(self, data, Prb=0):
        super().__init__(data)
        self.lista = [ VA(i,Prb) for i in self.lista ]
#+END_SRC

#+RESULTS:


* COMMENT Para exportar a ipynb                                   :noexports:

#+BEGIN_SRC emacs-lisp :exports none :results silent
(use-package ox-ipynb
  :load-path (lambda () (expand-file-name "ox-ipynb" scimax-dir)))
#+END_SRC


#+ox-ipynb-language: jupyter-python
#+BEGIN_SRC emacs-lisp :exports none :results silent
(setq  org-export-with-broken-links t)
(ox-ipynb-export-to-ipynb-file-and-open)
#+END_SRC


** COMMENT Variable aleatoria indicatriz (ahora creo que no hace falta) :noexports:

Vamos a crear un nuevo tipo de vector (que debe ser indicatriz) y que
posee un atributo adicional: la probabilidad asociada al suceso
indicado por dicho vector indicatriz (si el vector en nulo su
probabilidad será cero y si el vector es la constante 1, la
probabilidad será uno).
#+BEGIN_SRC jupyter-python :results silent
class VAI(VA):
    def __init__(self, data, p = [], rpr = 'columna'):
        super().__init__(data)
        if not all([int(i==0 or i==1) for i in self]):
            raise ValueError('No es un vector indicatriz')
        if not p:
            p = fracc(sum(self.lista),self.n)
        if not isinstance(p, (int, float, sympy.Basic)) or p<0 or p>1:
            raise ValueError('la probabilidad debe ser un número entre 0 y 1!')
        
        self.__class__ = VA
        self.P = self.fmp[1] if 1 in self.fmp else 0
#        if Vector(self).es_nulo(): self.fmp = {0:0} 
#        if Vector(self)==V1(Vector(self).n): self.fmp = {1:1}
#+END_SRC



#+BEGIN_SRC jupyter-python
VAI([0]*3).P
#+END_SRC

#+RESULTS:
:RESULTS:
0
:END:


#+BEGIN_SRC jupyter-python :results silent
class VAI1(VA):
    def __init__(self, n, rpr = 'columna'):
        self.__class__ = VA
        self.__init__(V1(n, rpr))
#+END_SRC

# super().__init__(V1(n, rpr))

# self.__class__ = VAI
# super().__init__(V0(n, rpr))
# self.__class__ = VAI

#+BEGIN_SRC jupyter-python :results silent
class VAI0(VA):
    def __init__(self, n, rpr = 'columna'):
        self.__class__ = VA
        self.__init__(V0(n, rpr))
#+END_SRC


Así, podemos generar un vector indicatriz e indicar la probabilidad
asociada al correspondiente suceso.


#+BEGIN_SRC jupyter-python
u = VA([1, 0, 1], (fracc(1,5),fracc(4,5)))
print(u.fmp)

#+END_SRC

#+RESULTS:
:RESULTS:
{1: 1/5, 0: 4/5}
:END:

Si el vector es nulo o es la constante uno, ignora la probabilidad que
indiquemos y asocia la probabilidad cero o uno respectivamente.

#+BEGIN_SRC jupyter-python
VAI(V0(5)).fmp
#+END_SRC

#+RESULTS:
:RESULTS:
| 0: | 1 |
:END:

