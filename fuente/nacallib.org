#+TITLE: Notación Asociativa para un Curso de Álgebra Lineal (NAcAL)
#+SUBTITLE: [[https://github.com/mbujosab/nacallib]] (Versión:  0.2.0)
#+AUTHOR: Marcos Bujosa
#+LANGUAGE: es-es
#+STARTUP: show5levels

#+OPTIONS: H:5
# +OPTIONS: toc:5
# +OPTIONS: toc:nil


#+LATEX_CLASS: report
#+LaTeX_HEADER: \usepackage{nacal}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LaTeX_HEADER: \usepackage{pdfpages}
#+LaTeX_HEADER: \usepackage{parskip}

# Para que no ejecute todo el código al exportar a pdf
#+PROPERTY: header-args :eval never-export
#+CALL: NombreEnChunksDeCodigo()


\maketitle

# +TOC: headlines 4

# |                 <c>                  |
# |            Versión 0.2.0             |
# | [[https://github.com/mbujosab/nacallib]] |

#+BEGIN_SRC jupyter-python  :results none :exports none
#from nacal import *
from AlgLin import *

def displaymath(t):
    return '$$' + t + '$$'

def dmath(t):
    return '$$' + latex(t) + '$$'

def math(t):
    return '$' + latex(t) + '$'

def dprint(t):
    return '=' + str(t) + '='

a,b,c,x,y,z = sympy.symbols('a b c x y z')

#+END_SRC

**** TODO Tareas pendientes                                        :noexport:

- [X] Homogeneizar estructura de cada Capítulo (ver índice)

- [X] Instanciar BlockM y Matrix con listas de listas (fila a fila)
- [X] Apilar sistemas
- [X] Producto Sistema por Vector 
- [X] Producto Sistema por Matriz
- [ ] Pensar otras variantes de productos y su significado o utilidad
- [X] Comprobación de que todos los elementos de un Sistema son del mismo tipo
- [X] Comprobación de que un Sistema es nulo
- [X] Primer no nulo
- [X] Último no nulo
- [X] Junta una lista de Sistemas en un único Sistema

- [ ] Ordenar los métodos adecuadamente en cada clase

- [X] Texto de ayuda de la subclase BlockV
- [X] Repasar textos de ayuda de las subclases 
- [X] Repasar textos de ayuda del operador selector en BlockM  y en Sistema (y subclases)

- [X] Implementar Matriz Identidad (necesario para el siguiente punto)
- [X] Creación de una Matrix diagonal a partir de un Vector
- [X] Normalización de un Vector (requiere producto punto vector por vector)

- [ ] Producto Hadamard para Vectores y Matrices

- [X] Texto de ayuda de la subclase BlockM

- [ ] Métodos útiles para la clase Matrix
- [ ] Comprobación de que una Matrix es singular


*** Ajustes para la compilación de la documentación       :noexport:
  :PROPERTIES:
  :UNNUMBERED: notoc
  :END:

#+NAME: NombreEnChunksDeCodigo
#+BEGIN_SRC emacs-lisp :results silent
(setq org-babel-exp-code-template
         (concat "\n#+ATTR_LATEX: :options label=%name\n"
              org-babel-exp-code-template)
               )
#+END_SRC


#  ############################
#   Inicio de la documentación 
#  ############################

*** Declaración de intenciones
  :PROPERTIES:  
  :UNNUMBERED: t  
  :END:  

Uno de los objetivos que me he propuesto para el curso Matemáticas II
(Álgebra Lineal) es mostrar que escribir matemáticas y usar un
lenguaje de programación son prácticamente la misma cosa. Este modo de
proceder debería ser un ejercicio muy didáctico ya que:
#+BEGIN_QUOTE
Un PC es muy torpe y se limita a ejecutar literalmente lo que se le
indica (un PC no interpreta interpolando para intentar dar sentido a
lo que se le dice... eso lo hacemos las personas, pero no los
ordenadores).

Consecuentemente este ejercicio impone una disciplina a la que en
general el alumno no está acostumbrado: /el ordenador hará lo que queremos solo si las expresiones tienen sentido e indican
correctamente lo que queremos./ Si el ordenador no hace lo que
queremos, será porque que no hemos escrito las ordenes de manera
correcta (lo que supone que también hemos escrito incorrectamente las
expresiones matemáticas).
#+END_QUOTE

Con esta idea en mente: 

 1. La notación del [[https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf][Curso de Álgebra Lineal]] pretende ser operativa; es
    decir, su uso debe ser directamente traducible a operaciones a
    realizar por un ordenador. Para lograr una mayor simplificación,
    la notación explota de manera intensiva la asociatividad.

 2. Muchas de las demostraciones del [[https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf][libro]] son algorítmicas. En
    particular aquellas las relacionadas con la eliminación. De esta
    manera las demostraciones describen literalmente la programación
    de los correspondientes algoritmos.

*** Un módulo específico para el curso de Álgebra Lineal
  :PROPERTIES:  
  :UNNUMBERED: t  
  :END:  

Aunque Python dispone de módulos para operar con vectores y matrices,
he decidido escribir mi propio módulo. De este modo logro que la
notación del [[https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf][libro]] y las expresiones empleadas con este módulo para
Python se parezcan lo más posible. Este documento describe tanto el uso del módulo [[https://pypi.org/project/nacal/][NAcAL]] como su código.
\begin{quote}
 \textsc{Tenga en cuenta que esto no es un
 \href{https://docs.python.org/es/3/tutorial/index.html}{tutorial} de
 Python}. 
\end{quote}
Mi labor es enseñar Álgebra Lineal (no Python). Afortunadamente usted
dispone de muchos cursos y material en la web para aprender Python. No
obstante, he escrito unos Notebooks de Jupyter que ofrecen unas breves
nociones de programación en Python (aunque muy incompletas).

Para subrayar el paralelismo entre las definiciones del [[https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf][curso]] y los
objetos (o ~Clases~) definidos en [[https://pypi.org/project/nacal/][NAcAL]], las partes auxiliares del
código se relegan al final.[fn:: aquellas que tienen que ver con la
comprobación de que los inputs de las funciones son adecuados, con
otras formas alternativas de instanciar clases, con la representación
de objetos en Jupyter usando código \LaTeX, etc.] Esto permitirá
apreciar cómo las definiciones del [[https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/libro.pdf][libro]] son implementadas de manera
literal en la librería de Python.
\begin{center}
  Antes de seguir, repase el Notebook
  \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F01_ListasYTuplas.ipynb}{\textbf{``Listas y tuplas''}}
    en la carpeta
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F}{``TutorialPython''}
    en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython}
\end{center}
Y recuerde que 
|                                <c>                                |
| *¡hacer matemáticas y programar son prácticamente la misma cosa!* |


* La clase ~Sistema~ y sus subclases ~BlockV~, ~Vector~, ~BlockM~ y ~Matrix~

***** Introducción
  :PROPERTIES:
  :NOTOC:    t
  :UNNUMBERED: t  
  :END:


En el primer capítulo se define una \emph{clase} para los
\emph{sistemas} (listas ordenadas de objetos) denominada =Sistema=; en
los capítulos siguientes se definen algunas subclases de la clase
=Sistema= (entre otras una para los \emph{vectores} y otra para las
\emph{matrices}).[fn:: Antes de seguir, mírese el Notebook referente a
[[https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F02_Clases.ipynb][``Clases'']] en la carpeta [[https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F][``TutorialPython'']] en
[[https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython]].]

En otras partes de esta documentación se definen clases que
implementan otros objetos empleados en el curso de [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf][Álgebra Lineal]]:
transformaciones elementales, subespacios vectoriales, espacios
afines, etc.

Cada vez que se define una nueva clase, se debe especificar tanto el
modo de instanciar la clase como sus atributos, sus modos de
representación (en particular el modo de representación para que los
Notebooks de Jupyter muestren representaciones semejantes a las
empleadas en el curso de Álgebra Lineal), así como todos los métodos
que actúan sobre ella.


** La clase ~Sistema~

En el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#chapter.1][libro]] del curso se dice que
\begin{center}
  Un \emph{sistema} es una lista ordenada de objetos.
\end{center}
Aunque Python ya posee =listas=, vamos a crear nuestra propia clase
denominada =Sistema=. De esta manera podremos implementar los métodos
descritos en el curso para los sistemas (que no son los mismos que
Python define para las =listas=). Por añadidura adecuaremos la
representación de los sistemas a la empleada en el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#chapter.1][libro]], donde los
sistemas genéricos se muestran entre /corchetes/ y con los elementos
de la lista /seguidos de/ `` =;= ''.[fn:: Como los vectores y las
matrices también son sistemas, crearemos para ellos subclases con las
respectivas representaciones tal y como se describen en el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf][curso]].]

La clase =Sistema= posee un atributo llamado =lista=, que es una
=list= de Python con la lista de objetos que componen el
=Sistema=. Una característica de un =Sistema= es que cada uno de sus
elementos será mostrado con su propia representación.  Por ejemplo, el
=Sistema=
#+BEGIN_SRC jupyter-python :exports code :results none
Sistema([ Vector([1,2,3]), I(2), T({1,2}) ]) 
#+END_SRC
contiene un vector de \R[3], la matriz identidad 2 por 2 y una
transformación intercambio entre las componentes 1 y 2 de un sistema;
y en un Notebook de Jupyter lo veremos así
#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dmath( Sistema([ Vector([1,2,3]), I(2), T({1,2}) ]) )
#+END_SRC

#+RESULTS:
$$\begin{bmatrix}\begin{pmatrix}1\\ 2\\ 3\end{pmatrix};& \left[ \begin{array}{cc}1&0\\0&1\\ \end{array} \right];& \underset{\left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]}{\pmb{\tau}};\end{bmatrix}$$

\noindent
(es decir, con la misma notación descrita en el curso de Álgebra Lineal).

Los ~Sistemas~ y las =listas= de Python no solo se diferencian en el
modo de representar los objetos que contienen, también en muchos de
sus métodos. Aunque algunos son comunes (en ciertos aspectos un
=Sistema= se comporta como una =list=) otros son específicos de los
=Sistemas=, y otros se han modificado para poder reservar los símbolos
de las operaciones algebraicas. Por ejemplo, las =listas= de Python se
concatenan con ``+'', pero los =Sistemas= se concatenan con el método
=concatena()=. Así reservamos el símbolo ``+'' para sumar =Sistemas=
componente a componente como se hace en Álgebra Lineal. Con ello
buscamos que lo que veamos y escribamos en un Notebook de Jupyter sea
lo más parecido posible a lo que vemos y escribimos en el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#chapter.1][curso de
Álgebra Lineal]].

\newpage

*** Implementación de los sistemas (o listas ordenadas) en la clase ~Sistema~

**** Texto de ayuda

El texto de ayuda de la clase =Sistema= es auto-explicativo y Python
lo muestra al teclear ~help(Sistema)~:

#+name: Texto de ayuda de la clase Sistema
#+BEGIN_SRC python
"""Clase para listas ordenadas con reprentación latex

Un Sistema es una lista ordenada de objetos. Los Sistemas se instancian
con una lista, tupla u otro Sistema. 

Parámetros:
    arg (list, tuple, Sistema): lista, tupla o Sistema de objetos.

Atributos:
    lista (list): lista de objetos.

Ejemplos:
>>> # Crea un nuevo Sistema a partir de una lista, tupla o Sistema
>>> Sistema( [ 10, 'hola', T({1,2}) ]  )           # con lista
>>> Sistema( ( 10, 'hola', T({1,2}) )  )           # con tupla
>>> Sistema( Sistema( [ 10, 'hola', T({1,2}) ] ) ) # con Sistema

[10; 'hola'; T({1, 2});]

"""
#+END_SRC

**** Método de inicialización

La clase se inicia con el método: =def__init__(self,...)=.

- Un =Sistema= se instancia con el argumento =arg= (que es una
  [[Ristras][/ristra/]] de objetos ---Sección [[Ristras]]).

- Añadimos un breve texto de ayuda que Python mostrará con: ~help Sistema.__init__~

- Cuando =arg= es una lista, tupla o =Sistema=, el atributo ~self.lista~
  guarda una lista en forma de =list= (lista de Python) con los
  elementos contenidos en =arg=.

- Cuando =arg= no es una lista, tupla, o =Sistema= se devuelve un
  mensaje de error.

- El atributo ~.n~ contiene el número de elementos del =Sistema=.

- El atributo ~.posicionDivisiones~ tiene que ver con una modificación
  de la [[Representación de la clase ~Sistema~][Representación de la clase ~Sistema~]] para /visualmente/ cortar
  el Sistema en sublistas con unas líneas verticales en las posiciones
  indicadas en este atributo (Véase la Sección [[Representación de la
  clase ~Sistema~]]).

#+name: Inicialización de la clase Sistema
#+BEGIN_SRC python 

def __init__(self, arg):
    """Inicializa un Sistema con una lista, tupla o Sistema"""                        
    if es_ristra(arg):
        self.lista = list(arg)                        
    else:
        raise ValueError('El argumento debe ser una lista, tupla, o Sistema.')

    self.n  = len(self)
    self.posicionDivisiones = {0}

#+END_SRC

En las siguientes secciones se definen los métodos de la clase
=Sistema=, empezando por aquellos que fuerzan a que un =Sistema= se
comporte como una =list= de Python en ciertos aspectos.

\medskip

**** Métodos similares a los de una ~list~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos de la clase Sistema para que actúe como si fuera una list de Python
       :END:

       Los siguientes métodos replican en la clase =Sistema= algunos aspectos
de la clase =list= de Python.

Para que un =Sistema= sea iterable necesitamos los métodos
``mágicos'' =__getitem__= (para seleccionar componentes) y
=__setitem__= (para modificar componentes).  Así, con ~A[0]~
obtendremos el primer elemento del sistema ~A~ y con ~A[2] = 0~
sustituiremos su tercer elemento por cero.[fn:: ¡Recuerde que en
Python los índices comienzan en =0=!  Aunque aquí incorporamos este
``pythonesco'' modo de indexar =Sistemas=, posteriormente (Sección
[[Implementación del operador selector por la derecha para la clase
~Sistema~]]) añadiremos otro método adicional que implementa el operador
selector `` =|= '' y que, tal como se hace en el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#chapter.1][libro]], emplea el =1=
como primer índice.]

#+BEGIN_SRC python

def __getitem__(self, i):
    """ Devuelve el i-ésimo coeficiente del Sistema """
    return self.lista[i]

def __setitem__(self, i, valor):
    """ Modifica el i-ésimo coeficiente del Sistema """
    self.lista[i] = valor
        
#+END_SRC

Con =len(A)= contamos el número de elementos del =Sistema=. 

#+BEGIN_SRC python

def __len__(self):
    """Número de elementos del Sistema """
    return len(self.lista)

#+END_SRC

Con =copy= podemos hacer una copia, por ejemplo ~B = A.copy()~ hace
una copia del sistema \SV{A} (aunque lograremos el mismo resultado con
~B = Sistema(A)~).

#+BEGIN_SRC python

def copy(self):
    """ Genera un Sistema copiando la lista de otro """
    return type(self)(self.lista)

#+END_SRC

Más adelante se añade otro [[Método para copiar un Sistema con todos sus atributos][Método para copiar un Sistema y sus atributos]] (~fullcopy()~).

Comprobamos si ~A~ y ~B~ son iguales con ~A == B~ y si son distintos con
~A != B~.

#+BEGIN_SRC python

def __eq__(self, other):
    """Indica si es cierto que dos Sistemas son iguales"""
    return self.lista == other.lista

def __ne__(self, other):
    """Indica si es cierto que dos Sistemas son distintos"""
    return self.lista != other.lista

#+END_SRC

Con =A.reverse()= invertimos el orden de los elementos de =A=
(cambiamos ~A~). Con =reversed(A)= obtenemos un nuevo =Sistema= con
los elementos de ~A~ en el orden inverso a como aparecen en =A=.

#+BEGIN_SRC python

def reverse(self):
    """Da la vuelta al orden de la lista del sistema"""
    self.posicionDivisiones =  {len(self)-i for i in self.posicionDivisiones}
    self.lista.reverse()
    
def __reversed__(self):
    """Reversed(S) devuelve una copia de S con la lista en orden inverso"""
    copia = self.fullcopy()
    copia.reverse()
    return copia
    
#+END_SRC

**** Concatenación de ~Sistemas~

Concatenamos dos =Sistemas= con el método ~concatena()~. 

(/Primero definimos un método auxiliar que se usa cuando/
~divisionesVisuales~ /es/ ~True~).

Cuando intentamos concatenar un =Sistema= con algo que no lo es obtenemos
un mensaje de error.

Cuando el =Sistema= no es vacío el procedimiento arranca con una copia
completa de dicho sistema (es decir, una copia que también incluye
valor del atributo ~.posicionDivisiones~). Pero si el =Sistema= es
vacío obtenemos una copia completa del segundo sistema (y con dicha
copia el método termina).

~A.concatena(B)~ es un nuevo =Sistema= cuya =lista= es la
concatenación de la =lista= del sistema ~A~ seguida de la =lista= del
sistema ~B~; por tanto, el número ~n~ de elementos del =Sistema=
resultante es la suma del número de elementos de ~A~ más el de ~B~.

Si queremos visualizar cortes o divisiones que separen sublistas del
=Sistema=, a las divisiones visuales pre-existentes en ambos
=Sistemas=, se añade otra en la posición que separa los sistemas
originales. El método ~nuevoConjuntoMarcas()~ devuelve el conjunto de
índices donde representar dichos cortes.

Si los elementos de la lista resultante no tienen la misma longitud
(por ejemplo, si concatenamos dos matrices con distinto número de
filas), entonces el sistema no puede ser representado como un arreglo
rectangular de objetos porque no tiene dicha estructura. En tal caso
el tipo de objeto resultante será un =Sistema= genérico.

#+name: Método de la clase Sistema para concatenar dos sistemas
#+BEGIN_SRC python

def concatena(self, other, marcasVisuales = False):
    """Concatena dos Sistemas"""    
    def nuevoConjuntoMarcas(Sistema_A, Sistema_B):
        return Sistema_A.posicionDivisiones.union(
            {len(Sistema_A)},
            {len(Sistema_A)+indice for indice in Sistema_B.posicionDivisiones} )
    
    if not isinstance(other, Sistema):
        raise ValueError('Un Sistema solo se puede concatenar a otro Sistema')

    if self:
        sistemaAmpliado = self.fullcopy()
    else:
        return other.fullcopy()
        
    sistemaAmpliado.lista = self.lista + other.lista
    sistemaAmpliado.n     = len(self)  + len(other)
        
    if marcasVisuales: 
        sistemaAmpliado.posicionDivisiones = nuevoConjuntoMarcas(self, other)

    return sistemaAmpliado if self.es_arreglo_rectangular() else Sistema(sistemaAmpliado)

#+END_SRC

El método =junta()= crea el =Sistema= resultante de concatenar una
lista de sistemas. Por ejemplo ~A.junta([B,C,D])~ devuelve el sistema
cuya =lista= es la concatenación de las =listas= de los sistemas ~A~,
~B~, ~C~ y ~D~. Si ~marcas~ es ~True~ se muestran los cortes entre los
distintos subsistemas.
#+name: Método que junta una lista de Sistemas en un único Sistema
#+BEGIN_SRC python

def junta(self, lista, marcas = False):
    """Junta una lista o tupla de Sistemas en uno solo concatenando las
    correspondientes listas de los distintos Sistemas

    """
    reune = lambda lista,marcas: lista[0] if len(lista)==1 else lista[0].concatena(reune(lista[1:],marcas), marcas)    
    return reune([self] + [sistema for sistema in lista], marcas)
    
#+END_SRC

#+name: Método que amplía la lista de un Sistema con nuevos elementos
#+BEGIN_SRC python

def amplia(self, args, marcas = False):
    """Añade más elementos al final de la lista de un Sistema"""
    A = self.fullcopy()
    return A.concatena(Sistema(CreaLista(args)), marcas)

#+END_SRC

**** Sustitución y simplificación de expresiones simbólicas en un ~Sistema~

***** Sustitución de variables simbólicas. 

#+name: Sustitución de variables simbólicas
      #+BEGIN_SRC python :noweb yes

def subs(self, reglasDeSustitucion=[]):
    """ Sustitución de variables simbólicas """
    reglas = CreaLista(reglasDeSustitucion)
    self.lista = [ sympy.S(elemento).subs(CreaLista(reglas)) for elemento in self.lista ]
    return self

#+END_SRC

El argumento es una lista de [[https://docs.sympy.org/latest/tutorials/intro-tutorial/basic_operations.html][reglas de sustitución]] formadas por pares
=(símbolo, valor)=; por ejemplo ~[(a,2), (b,0), (c,a)]~.

# a,b,c = sympy.symbols('a b c')

#+BEGIN_SRC jupyter-python :exports code :results raw :results silent
A = Sistema([ a, b, c ])
A.subs( [(a,222), (b,sympy.sqrt(5)), (c,a)] )
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dmath(A)
#+END_SRC

#+RESULTS:
$$\left[ \begin{array}{ccc}222;& \sqrt{5};& a;\end{array} \right]$$

Cuando hay una única regla de sustitución, basta escribir como
argumento el correspondiente par. Por ejemplo: ~A.subs( (a,0) )~.

***** Métodos para [[https://docs.sympy.org/latest/tutorials/intro-tutorial/simplification.html][simpificar]] expresiones simbólicas 

Simplificación de las expresiones simbólicas contenidas en la ~lista~ de un ~Sistema~

#+name: Simplificación de expresiones simbólicas
#+BEGIN_SRC python :noweb yes

def simplify(self):
    """ Simplificación de expresiones simbólicas """
    self.lista = [ sympy.S(elemento).simplify() for elemento in self.lista ]
                                                               
def factor(self):
    """ Factorización de expresiones simbólicas """
    self.lista = [ sympy.S(elemento).factor() for elemento in self.lista ]

#+END_SRC

#+BEGIN_SRC jupyter-python :exports code :results silent
x, y, z = sympy.symbols('x y z')
A    = Sistema([ (x**3 + x**2 - x - 1)/(x**2 + 2*x + 1),   x**2*z + 4*x*y*z + 4*y**2*z])
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dmath(A)
#+END_SRC

#+RESULTS:
$$\left[ \begin{array}{cc}\frac{x^{3} + x^{2} - x - 1}{x^{2} + 2 x + 1};& x^{2} z + 4 x y z + 4 y^{2} z;\end{array} \right]$$

#+BEGIN_SRC jupyter-python :exports code :results raw :results silent
A.simplify()
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dmath(A)
#+END_SRC

#+RESULTS:
$$\left[ \begin{array}{cc}x - 1;& z \left(x^{2} + 4 x y + 4 y^{2}\right);\end{array} \right]$$

**** Otros métodos de la clase ~Sistema~
       :PROPERTIES:
       :header-args+: :noweb-ref Otros métodos de la clase Sistema
       :END:
***** Método para copiar un Sistema con todos sus atributos

# def __deepcopy__
# [[https://pythonforthelab.com/blog/deep-and-shallow-copies-of-objects/]]

#+BEGIN_SRC python

def fullcopy(self):
    """ Copia la lista de otro Sistema y sus atributos"""
    new_instance = self.copy()
    new_instance.__dict__.update(self.__dict__)
    return new_instance

#+END_SRC

***** Método para recuperar el ~Sistema~ genérico de cualquier subclase de ~Sistema~

Con el método =sis= obtendremos el =Sistema= correspondiente a
cualquier =Sistema= o subclase de =Sistema=. Así, si ~A~ es una
=Matrix=, con ~A.sis()~ obtenemos el =Sistema= de =Vectores=
(columnas) asociado.
#+BEGIN_SRC python

def sis(self):
    """Devuelve el Sistema en su forma genérica"""
    return Sistema(self.lista)

#+END_SRC

***** Comprobación de que un ~Sistema~ es nulo

#+BEGIN_SRC python

def es_nulo(self, sust=[]):
    """Indica si es cierto que el Sistema es nulo"""
    return self.subs(sust) == self*0

def no_es_nulo(self, sust=[]):
    """Indica si es cierto que el Sistema no es nulo"""
    return self.subs(sust) != self*0

#+END_SRC

***** Comprobación de que un ~Sistema~  tiene estructura de arreglo rectangular

Un =Sistema= es un arreglo rectangular de objetos si es un =Sistema=
de =Sistemas= con idéntica longitud (como en el caso de una matriz,
pues todas sus columnas tienen el mismo número de elementos).
#+BEGIN_SRC python

def es_arreglo_rectangular(self):
    """Indica si el Sistema tiene estructura de arreglo rectangular"""

    def solo_contiene_sistemas(sis):
        return all([isinstance(elemento, Sistema) for elemento in sis])

    def elementos_con_la_misma_logitud(sis):
        primerElemento = sis|1
        return all([len(primerElemento)==len(elemento) for elemento in sis])

    if solo_contiene_sistemas(self) and elementos_con_la_misma_logitud(self):
        return True
    else:
        return False

def no_es_arreglo_rectangular(self):
    """Indica si el Sistema no tiene estructura de arreglo rectangular"""
    return not self.es_arreglo_rectangular()

#+END_SRC

***** Comprobación de que todos los elementos de un ~Sistema~ son del mismo tipo

      #+BEGIN_SRC python

def es_de_composicion_uniforme(self):
   """Indica si es cierto que todos los elementos son del mismo tipo"""
   if all([es_numero(c) for c in self]):
      return True
   else:
      return all(type(elemento)==type(self|1) for elemento in self)

#+END_SRC

***** Comprobación de que todos los elementos de un ~Sistema~ son del mismo tipo y tienen la misma longitud

#+BEGIN_SRC python

def es_de_composicion_y_longitud_uniforme(self):
   """Indica si es cierto que todos los elementos son del mismo tipo y
   longitud

   """
   if self.es_de_composicion_uniforme() and es_numero(self|1):
      return True
   elif self.es_de_composicion_uniforme() and not es_numero(self|1):
      return all(len(elemento)==len(self|1) for elemento in self)
   else:
      return False
   
#+END_SRC

***** Búsqueda del primer, o del último, elemento no nulo del ~Sistema~

# #+BEGIN_SRC 
# def primer_no_nulo(self, p = 0, sust=[]):
#     """Devuelve o una lista con la posición del primer no nulo despues de
#     la posición p o vacía si todos son nulos"""
#     return next(([i] for i, x in enumerate(self.subs(sust),1) if CreaSistema(x).no_es_nulo() and i>p), [])
# #+END_SRC

#+BEGIN_SRC python

def primer_no_nulo(self, reglasDeSustitucion=[]):
    """Devuelve una lista con la posición del primer no nulo o vacía si
    todos los elementos son nulos

    """
    sistema = self.subs(reglasDeSustitucion)
    return next( ([indice] for indice, elemento in enumerate(sistema, 1) if CreaSistema(elemento).no_es_nulo()), [])

def ultimo_no_nulo(self, reglasDeSustitucion=[]):
    """Devuelve una lista con la posición del primer no nulo o vacía si
    todos los elementos son nulos

    """
    sistema = reversed(self.copy()).subs(reglasDeSustitucion)
    return next( ([len(self)-indice] for indice,elemento in enumerate(sistema) if CreaSistema(elemento).no_es_nulo()), [])

elementoPivote     = lambda self:  self.extractor(self.primer_no_nulo()) if self.primer_no_nulo() else False

elementoAntiPivote = lambda self:  self.extractor(self.ultimo_no_nulo()) if self.ultimo_no_nulo() else False

#+END_SRC

***** Extractor de un elemento dada una lista de indices (coordenadas)

#+BEGIN_SRC python

def extractor(self, listaDeIndices = []):
    """Selección consecutiva por la derecha del sistema A empleando la
    lista de enteros de c. Ej.: si c = [5,1,2] devuelve A|5|1|2

    """
    objeto = self
    for indice in listaDeIndices:
        objeto = objeto|indice
    return objeto if listaDeIndices else []

#+END_SRC

***** Reordena un ~Sistema~ para generar un ~BlockM~
#+BEGIN_SRC python
   
def reshape(self, orden=[]):
    "Reordena los elementos de un Sistema para generar un BlockM"
    if not orden or isinstance(orden, int):
        return self
    elif orden[0]*orden[1] == self.n:
        return ~BlockM(list(zip(*(iter(self.lista),) * orden[0])))
    else:
        raise ValueError('El orden indicado es incompatible con el número de elementos del Sistema')
        return None

#+END_SRC

**** Métodos que devuelven ~SubEspacios~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos que devuelven SubEspacios
       :END:
***** Espacio generado los los elementos del ~Sistema~

      #+BEGIN_SRC python

def span(self, sust=[], Rn=[]):
    return SubEspacio(self.sis(), sust, Rn)

#+END_SRC

***** Espacio Nulo de un ~Sistema~ de composición y longitud uniforme

#+BEGIN_SRC python

def espacio_nulo(self, sust=[], Rn=[]):
    if self: Rn = self.n
    K     = self.elim(0, False, sust)
    E     = I(self.n) & T(K.pasos[1])
    lista = [v for j,v in enumerate(E,1) if (K|j).es_nulo()]
    return SubEspacio(Sistema(lista)) if lista else SubEspacio(Sistema([]), Rn=Rn)

#+END_SRC

**** Método de resolución de sistema de Ecuaciones lineales
       :PROPERTIES:
       :header-args+: :noweb-ref Método de resolución de sistema de Ecuaciones lineales
       :END:

#+BEGIN_SRC python

def sel(self, v, sust=[]):
    """Devuelve la lista o EAfin con las soluciones x de sistema*x=v

    """
    A           = self.amplia(-v)
    operaciones = A.elim(1,False,sust).pasos[1]
    testigo     = 0| (I(A.n) & T(operaciones)) |0
    Normaliza   = T([]) if testigo==1 else T([( fracc(1,testigo), A.n )])
    pasos       = operaciones+[Normaliza] if Normaliza else operaciones
    K           = A & T(pasos)
    
    if (K|0).no_es_nulo():
        return Sistema([])
    else:
        solP = (I(self.n).amplia(V0(self.n)) & T(pasos))|0
        if self.espacio_nulo().sgen.es_nulo():
            return Sistema([solP])
        else:
            return EAfin(self.espacio_nulo().sgen, solP, 1)

#+END_SRC

*** Operaciones algebraicas sobre ~Sistemas~

**** Implementación del operador selector por la derecha para la clase ~Sistema~

Esta sección muestra la implementación del operador selector tal como
se describe en el curso, es decir, la selección de elementos de un
~Sistema~ con el operador =|= actuando por la derecha. El siguiente
texto de ayuda es auto-explicativo y Python lo muestra al teclear
~help(Sistema.__or__)~.

#+name: Texto de ayuda para el operador selector por la derecha para la clase Sistema
#+BEGIN_SRC python
"""Extrae el j-ésimo componente del Sistema; o crea un Sistema con la
tupla de elementos indicados (los índices comienzan por el número 1)

Parámetros:
    j (int, list, tuple, slice): Índice (o lista de índices) del 
          elementos (o elementos) a seleccionar

Resultado:
          ?: Si j es int, devuelve el elemento j-ésimo del Sistema.
    Sistema: Si j es list, tuple o slice devuelve el Sistema formado por
          los elementos indicados en la lista, tupla o slice de índices.

Ejemplos:
>>> # Extrae el j-ésimo elemento del Sistema 
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | 2

Vector([0, 2])

>>> # Sistema formado por los elementos indicados en la lista (o tupla)
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | [2,1]
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | (2,1)

[Vector([0, 2]); Vector([1, 0])]

>>> # Sistema formado por los elementos indicados en el slice
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | slice(1,3,2)

[Vector([1, 0]), Vector([3, 0])]

"""
#+END_SRC

Cuando el argumento ~j~ es un número entero (~int~), se selecciona el
=j=-ésimo elemento del sistema (recuerde que en Python los índices de
objetos iterables comienzan en cero; consecuentemente, al seleccionar
el =j=-ésimo elemento del sistema ~A~ con el operador selector
(=A|j=), lo que realmente estamos ejecutando es la operación
~A.lista[j-1]~).

Se emplea el método (=self|indice=) (siendo =indice= un =int=) para
definir el operador selector cuando =j= es una lista o tupla de
índices y generar así un sistema con las componentes indicadas. El
sistema obtenido será del mismo tipo que =self=, es decir, o un
=Sistema= genérico, o un =BlockV=, o un =Vector=, o una =BlockM=, o
una =Matrix= dependiendo de a qué objeto se aplica el selector.

Cuando el argumento =j= es de tipo =slice(start,stop,step)=, se crea
un =Sistema= con la selección de ciertos componentes; comenzando por
aquél cuyo índice es ~start~, y seleccionando de ~step~ en ~step~
componentes hasta llegar al de índice ~stop~. Dicho sistema será del
mismo tipo que ~self~. Si el primer argumento de ~slice~ es ~None~ se
seleccionan los componentes empezando por el primero. Si el segundo
argumento de ~slice~ es ~None~ se recorren todos los índices hasta
llegar al último componente. Si se omite el tercer argumento de
~slice~ (o si el tercer argumento es ~None~) entonces ~step~ es igual
a uno. Así, ~slice(None,None)~ selecciona todos los componentes;
~slice(2,None,2)~ selecciona los componentes pares hasta el final; y
~slice(4,11,3)~ selecciona un componente de cada tres comenzando por
el cuarto y hasta llegar al undécimo (es decir, los índices 4, 7 y
10).

#+name: Operador selector por la derecha para la clase Sistema
#+BEGIN_SRC python :noweb no-export

def __or__(self,j):
    <<Texto de ayuda para el operador selector por la derecha para la clase Sistema>>
    if isinstance(j, int):
        return self[j-1]
        
    elif isinstance(j, (list,tuple) ):
        return type(self) ([ self|indice for indice in j ])
    
    elif isinstance(j, slice):
        start = None if j.start is None else j.start-1 
        stop  = None if j.stop  is None else (j.stop if j.stop>0 else j.stop-1)
        step  = j.step  or 1
        return type(self) (self[slice(start,stop,step)])

#+END_SRC

El operador selector por la derecha funciona de la misma manera tanto
para la clase =Sistema= como para cualquiera de sus subclases.

**** Implementación del operador selector por la izquierda para la clase ~Sistema~

# *¿Debo dejarlo aquí, o definirlo solo para los sistemas tipo Matriz?*

En el curso de Álgebra Lineal admitimos la selección de elementos por
la izquierda, $\;\elemL{\Vect{v}}{i}=\elemR{\Vect{v}}{i}$.

La implementación de esta operación es inmediata\dots si el selector
por la izquierda hace lo mismo que el selector por la derecha, basta
con llamar al selector por la derecha: =self|i=.

#+name: Operador selector por la izquierda para la clase Sistema
#+BEGIN_SRC python :noweb no-export

def __ror__(self,i):
    """Hace exactamente lo mismo que el método __or__ por la derecha."""
    return self | i

#+END_SRC

(/Tenga en cuenta que este método cambia en las subclases =BlockM= y =Matrix=, pues lo usaremos para seleccionar las filas de dichos arreglos rectangulares de objetos./)

**** Suma y diferencia de ~Sistemas~

Con la definición de la clase =Sistema= y el operador selector =|= por
la derecha, ya podemos definir las operaciones de suma de dos sistemas
y de producto de un sistema por un escalar. Fíjese que las
definiciones de las operaciones en Python (usando el operador =|=) son
idénticas a las empleadas en el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#section.1.2][curso]], donde hemos definido la suma de
dos vectores de \R[n] como el vector tal que
\begin{displaymath}
  \fbox{\begin{math} \elemR{(\Vect{a}+\Vect{b})}{i}=\eleVR{a}{i}+\eleVR{b}{i} \end{math}}
  \quad\text{para}\quad i=1:n
\end{displaymath}
y la [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#section.1.5][suma de matrices]] como la matriz tal que
\begin{displaymath}
  \fbox{\begin{math} \elemRP{\Mat{A}+\Mat{B}}{j}=\VectC{A}{j}+\VectC{B}{j} \vphantom{\Big(} \end{math}}
  \quad\text{para}\quad i=1:n.
\end{displaymath}
Ambas son casos particulares de sumas elemento a elemento entre dos sistemas de $n$ elementos:
\begin{displaymath}
  \fbox{\begin{math} \elemRP{\SV{a}+\SV{b}}{i}=\elemR{\SV{a}}{i}+\elemR{\SV{b}}{i} \end{math}}
  \quad\text{para}\quad i=1:n.
\end{displaymath}
Usando el operador selector podemos ``literalmente'' transcribir esta definición
#+BEGIN_SRC python :export none
Sistema ([ (self|i) + (other|i) for i in range(1,len(self)+1) ])
#+END_SRC
donde ~self~ es el sistema \SV{A}, ~other~ es \SV{B}, y
~range(1,self.n+1)~ es el rango de valores: $1:n$.

Hay que tener en cuenta que cuando el =Sistema= es un =Vector= el
resultado es un =Vector= y cuando el =Sistema= es una =Matrix= el
resultado es una =Matrix=. Es decir, el código debe devolver un objeto
del mismo tipo que ~self~. Esto lo logramos sustituyendo ~Sistema~ por
~type(self)~ en el código anterior. Así, la implementación final es:
#+BEGIN_SRC python :export none
type(self) ([ (self|i) + (other|i) for i in range(1,len(self)+1) ])
#+END_SRC
Por último, nótese que para que la implementación funcione es
necesario que los elementos $\elemR{\SV{a}}{i}$ y $\elemR{\SV{b}}{i}$
sean sumables, es decir, es necesario que la operación
#+BEGIN_SRC python :export none
(self|i) + (other|i)
#+END_SRC
esté definida para cada ~i~. (De manera análoga definimos diferencia
entre =Sistemas=).

Python muestra el texto de ayuda para la suma tecleando ~help(Sistema.__add__)~.
#+name: Texto de ayuda para el operador resta en la clase Sistema
#+BEGIN_SRC python
"""Devuelve el Sistema resultante de sumar dos Sistemas

Parámetros: 
    other (Sistema): Otro sistema del mismo tipo y misma longitud

Ejemplos:
>>> Sistema([10, 20, 30]) + Sistema([-1, 1, 1])

Sistema([9, 21, 31]) 
>>> Vector([10, 20, 30]) + Vector([-1, 1, 1])

Vector([9, 21, 31]) 
>>> Matrix([[1,5],[5,1]]) + Matrix([[1,0],[0,1]]) 

Matrix([Vector([2, 5]); Vector([5, 2])]) """
#+END_SRC

Python muestra el texto de ayuda para la diferencia tecleando ~help(Sistema.__sub__)~.
#+name: Texto de ayuda para el operador diferencia en la clase Sistema
#+BEGIN_SRC python
"""Devuelve el Sistema resultante de restar dos Sistemas

Parámetros: 
    other (Sistema): Otro sistema del mismo tipo y misma longitud

Ejemplos:
>>> Sistema([10, 20, 30]) - Sistema([1, 1, -1])

Sistema([9, 19, 31])
>>> Vector([10, 20, 30]) - Vector([1, 1, -1])

Vector([9, 19, 31])
>>> Matrix([[1,5],[5,1]]) - Matrix([[1,0],[0,1]]) 

Matrix([Vector([0, 5]); Vector([5, 0])]) 
"""
#+END_SRC

#+name: Suma y diferencia de Sistemas
#+BEGIN_SRC python :noweb no-export

def __add__(self, other):
    <<Texto de ayuda para el operador suma en la clase Sistema>>
    if not type(self)==type(other) or not len(self)==len(other):
        raise ValueError ('Solo se suman Sistemas del mismo tipo y misma longitud')
    suma = self.fullcopy()
    suma.lista = [ (self|i) + (other|i) for i in range(1,len(self)+1) ]
    suma.posicionDivisiones.update(other.posicionDivisiones)
    return suma
            
def __sub__(self, other):
    <<Texto de ayuda para el operador diferencia en la clase Sistema>>
    if not type(self)==type(other) or not len(self)==len(other):
        raise ValueError ('Solo se restan Sistemas del mismo tipo y misma longitud')
    diferencia = self.fullcopy()
    diferencia.lista = [ (self|i) - (other|i) for i in range(1,len(self)+1) ]
    diferencia.posicionDivisiones.update(other.posicionDivisiones)
    return diferencia
            
#+END_SRC

**** Producto de un ~Sistema~ por un escalar a su izquierda

El producto de un sistema \SV{a} por un escalar $x$ a su izquierda es
el \emph{sistema}
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\SV{a}}{i}=x \elemRPE{\SV{a}}{i}
  \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
cuya transcripción literal es
\begin{center}
  \Verb/ Sistema ( [ x*(self|i) for i in range(1,len(self)+1) ] ) /
\end{center}
# #+BEGIN_SRC python :export none
# Sistema ( [ x*(self|i) for i in range(1,len(self)+1) ] )
# #+END_SRC
donde =x= es un número (=int=, =float= o un objeto del módulo [[https://docs.sympy.org/latest/index.html][Sympy]]
~sympy.Basic~) y =self= es \SV{A}.

Casos particulares son el producto de un /vector/ \Vect{a}
por un escalar $x$ a su izquierda, que es el /vector/:
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\Vect{a}}{i}=x \eleVRPE{a}{i}
  \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
Y el producto de una /matriz/ \Mat{A} por un escalar $x$ a su
izquierda, que es la /matriz/:
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\Mat{A}}{j}=x\VectCPE{A}{j}
    \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
Como en los casos particulares se obtienen /sistemas/ de tipos
particulares (/vectores/ en el primer caso y /matrices/ en el
segundo), debemos sustituir =Sistema= por =type(self)= para
obtener sistemas del mismo tipo que ~self~:
\begin{center}
  \Verb/ type(self) ( [ x*(self|i) for i in range(1,len(self)+1) ] ) /
\end{center}
# #+BEGIN_SRC python :export none
# type(self) ( [ x*(self|i) for i in range(1,len(self)+1) ] )
# #+END_SRC

Texto de ayuda para el operador producto por la izquierda en la clase =Sistema=
#+name: Texto de ayuda para el operador producto por la izquierda de un Sistema
#+BEGIN_SRC python
"""Multiplica un Sistema por un número a su izquierda

Parámetros:
    x (int, float o sympy.Basic): Escalar por el que se multiplica
Resultado:
    Sistema resultante de multiplicar cada componente por x
Ejemplo:
>>> 3 * Sistema([10, 20, 30]) 

Sistema([30, 60, 90]) 
"""
#+END_SRC

#+name: Producto de un Sistema por un escalar a su izquierda
#+BEGIN_SRC python :noweb no-export

def __rmul__(self, x):
    <<Texto de ayuda para el operador producto por la izquierda de un Sistema>>
    if es_numero(x):
        multiplo = self.fullcopy()
        multiplo.lista = [ x*(self|i) for i in range(1,len(self)+1) ]
        return multiplo

#+END_SRC

También nos viene viene bien manejar el opuesto de un =Sistema=:
\begin{math}
 -\SV{A}=-1\cdot\SV{A}.
\end{math}

#+name: Opuesto de un Sistema
#+BEGIN_SRC python :noweb no-export

def __neg__(self):
    """Devuelve el opuesto de un Sistema"""
    return -1*self

#+END_SRC

**** Producto de un ~Sistema~ por escalar, ~Vector~ o  ~Matrix~ a su derecha

En el curso se acepta que el producto de un =Sistema= por un escalar
es conmutativo. Por tanto,
\begin{displaymath}
  \fbox{\begin{math} 
           \SV{A}x=x\SV{A}
        \end{math}}
\end{displaymath}
por tanto también debemos implementar el producto
\begin{center}
  \Verb/ self * x /
\end{center}
donde ~self~ es el =Sistema= y =x= es un número (~int~, ~float~,
~sympy.Basic~).


El producto de \SV{A}, de $n$ componentes, por un vector \Vect{x} de
\R[n] a su derecha se define como
\begin{displaymath}  
    \fbox{$\SV{A}\Vect{x}\;=\;\elemRPE{\SV{A}}{1}x_1+\cdots+\elemRPE{\SV{A}}{n}x_n\;=\;\sum_{j=1}^n\elemRPE{\SV{A}}{j}x_j$}
    %\fbox{$\SV{A}\Vect{x}\;=\;\elemRPE{\SV{A}}{1}\elemRPE{\Vect{x}}{1}+\cdots+\elemRPE{\SV{A}}{n}\elemRPE{\Vect{x}}{n}\;=\;\sum_{j=1}^n\elemRPE{\SV{A}}{j}\elemRPE{\Vect{x}}{j}$}
    \qquad\text{para}\; j=1:n.
\end{displaymath}
cuya transcripción será
\begin{center}
  \Verb/ sum([ (self|j)*(x|j) for j in range(1,x.n+1) ]) /
\end{center}
donde ~self~ es un =Sistema= y ~x~ es un (=Vector=).

Fíjese que el /producto punto/ (o producto escalar usual en \R[n]) de
dos vectores \Vect{a} y \Vect{x} en $\R[n]$ es un caso particular en
el que el sistema $\SV{A}$ es un vector $\Vect{a}$.

El producto del sistema \SV{A} de $p$ componentes por una matriz
\Matdim{x}{p}{n} de \R[n] a su derecha se define como el sistema tal
que
\begin{displaymath}
  \fbox{$\elemR{(\SV{A}\Mat{X})}{j}=\SV{A}(\VectC{X}{j})$}
  \qquad\text{para}\; j=1:n.
\end{displaymath}
cuya transcripción será
\begin{center}
  \Verb/ type(self) ( [ self*(x|j) for j in range(1,x.n+1)] ) /
\end{center}
donde ~self~ es el =Sistema= y ~x~ es una =Matrix=.

Fíjese que el /producto de matrices/ es un caso particular en el que
el sistema $\SV{A}$ es una matriz $\Mat{A}$.

Además, sabemos por las notas de la asignatura que en el caso
particular de que el sistema $\SV{A}$ sea un vector, el resultado es
una combinación lineal de las filas de la matriz \Mat{X} (es decir, el
resultado es un vector). Para recordar que el vector resultante es una
combinación lineal de las filas, lo representaremos en forma de fila.

Python muestra el siguiente texto de ayuda al teclear
~help(Sistema.__mul__)~.
#+name: Texto de ayuda para el operador producto por la derecha en la clase Sistema
#+BEGIN_SRC python
"""Multiplica un Sistema por un número, Vector o una Matrix a su derecha

Parámetros:
    x (int, float o sympy.Basic): Escalar por el que se multiplica
      (Vector): con tantos componentes como el Sistema
      (Matrix): con tantas filas como componentes tiene el Sistema

Resultado:
    Sistema del mismo tipo: Si x es int, float o sympy.Basic, devuelve 
       el Sistema que resulta de multiplicar cada componente por x
    Objeto del mismo tipo de los componentes del Sistema: Si x es Vector,
       devuelve una combinación lineal de los componentes del Sistema, 
       donde los componentes de x son los coeficientes de la combinación.
    Sistema del mismo tipo: Si x es Matrix, devuelve un Sistema cuyas 
       componentes son combinación lineal de las componentes originales.
       
Ejemplos:
>>> # Producto por un número
>>> Vector([10, 20, 30]) * 3

Vector([30, 60, 90])
>>> Matrix([[1,2],[3,4]]) * 10

Matrix([[10,20],[30,40]])
>>> # Producto por un Vector
>>> Vector([10, 20, 30]) * Vector([1, 1, 1])

60
>>> Matrix([Vector([1, 3]), Vector([2, 4])]) * Vector([1, 1])

Vector([3, 7])
>>> # Producto por una Matrix
>>> Vector([1,1,1])*Matrix( ( [1,1,1], [2,4,8], [3,-1,0] ) )

Vector([6, 4, 9])
>>> Matrix([Vector([1, 3]), Vector([2, 4])]) * Matrix([Vector([1,1])]))

Matrix([Vector([3, 7])])

"""
#+END_SRC

#+RESULTS: Texto de ayuda para el operador producto por la derecha en la clase Sistema
: None

Para implementar la operación =Sistema= por número se llama a la
operación número por =Sistema=.

Para implementar =Sistema= por =Vector= se usa la función ~sum~; que
tiene dos argumentos: el primero es la lista de objetos a sumar, y el
segundo es un primer objeto al que se suman los de la lista (por
defecto es el \emph{número} ``$0$''). Como la suma de $0$ y un
elemento del =Sistema= puede no tener sentido, se emplea el siguiente
truco: ese primer objeto es el primer elemento de la lista
multiplicado por $0$.

Para implementar =Sistema= por =Matrix= se usa la operación =Sistema=
por =Vector= para generar cada uno de los elementos del sistema
resultante. Cuando el =Sistema= es un =Vector=, la operación =Sistema=
por =Matrix= calcula el producto de un =Vector= por una =Matrix=. Para
recordar que el vector resultante es una combinación lineal de las
filas de la matriz, la representación del resultado sera en forma
horizontal (~rpr='fila'~) si se emplea la representación =latex=.

#+name: Producto de un Sistema por un escalar un Vector o una Matrix a su derecha
#+BEGIN_SRC python :noweb no-export

def __mul__(self,x):
    <<Texto de ayuda para el operador producto por la derecha en la clase Sistema>>
    if es_numero(x):
        return x*self

    elif isinstance(x, Vector):
        if len(self) != x.n:
            raise ValueError('Sistema y Vector incompatibles')
        if self.es_arreglo_rectangular():
            if not all([f.es_de_composicion_y_longitud_uniforme() for f in ~BlockM([BlockV([i]) for i in self])]):
                raise ValueError('El sistema de la derecha debe tener elementos de composicion y longitud uniforme')
        elif not self.es_de_composicion_y_longitud_uniforme():
            raise ValueError('El sistema de la derecha debe tener elementos de composicion y longitud uniforme')
            
        return sum([(self|j)*(x|j) for j in range(1,len(self)+1)], 0*self|1)
    
    elif isinstance(x, Matrix):
        if len(self) != x.m:
            raise ValueError('Sistema y Matrix incompatibles')
        if isinstance(self, BlockV):
            return BlockV( [ self*(x|j) for j in range(1,(x.n)+1)], rpr='fila' )
        elif isinstance(self, BlockM):
            return BlockM ( [ self*(x|j) for j in range(1,(x.n)+1)] )
        else:
            return type(self) ( [ self*(x|j) for j in range(1,(x.n)+1)] )

#+END_SRC

*** Transformaciones elementales de un ~Sistema~

En el [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#section.9.3][libro]] del curso se definen las transformaciones elementales de
=Sistemas= de vectores como una generalización a las transformaciones
elementales de las columnas de una =Matrix=. Puesto que cada =Matrix=
es un =Sistema= de =Vectores=, implementamos de manera general las
transformaciones elementales sobre =Sistemas= genéricos.

Como el método no verifica si las operaciones son licitas, podría
obtener un error si el sistema contiene objetos incompatibles con
dichas operaciones; por ejemplo, si el =Sistema= contiene una cadena
de caracteres y un número, al intentar sumar un múltiplo de uno de los
elementos al otro obtendremos un error (aunque esto no pasará con los
intercambios).

**** Texto de ayuda transformaciones elementales por la derecha

#+name: Texto de ayuda de las transformaciones elementales de un Sistema
#+BEGIN_SRC python
"""Transforma los elementos de un Sistema 

    T(abreviaturas): transformaciones a aplicar sobre un Sistema S
Ejemplos:
>>>  S & T({1,3})                # Intercambia los elementos 1º y 3º
>>>  S & T((5,1))                # Multiplica por 5 el primer elemento
>>>  S & T((5,2,1))              # Suma 5 veces el 2º elem al 1º
>>>  S & T([{1,3},(5,1),(5,2,1)])# Aplica la secuencia de transformac.
             # sobre los elementos de S y en el orden de la lista
"""
#+END_SRC

**** Implementación de las transformaciones elementales por la derecha

(/aunque sea una composición de transformaciones elementales, también
se incluye el intercambio./)

#+name: Transformaciones elementales de los elementos de un Sistema
#+BEGIN_SRC python :noweb no-export

def __and__(self,operaciones):
    <<Texto de ayuda de las transformaciones elementales de un Sistema>>
    def transformacionDelSistema(abrv):
        if isinstance(abrv,set):
            self.lista = [ (self|max(abrv)) if k==min(abrv) else \
                           (self|min(abrv)) if k==max(abrv) else \
                           (self|k)                 for k in range(1,len(self)+1)].copy()
            
        elif isinstance(abrv,tuple) and (len(abrv) == 2):
            self.lista = [ (abrv[0])*(self|k) if k==abrv[1] else (self|k) \
                                                    for k in range(1,len(self)+1)].copy()

        elif isinstance(abrv,tuple) and (len(abrv) == 3):
            self.lista = [ (abrv[0])*(self|abrv[1]) + (self|k) if k==abrv[2] else (self|k)
                                                    for k in range(1,len(self)+1)].copy()

    for abrv in operaciones.abreviaturas:
        transformacionDelSistema(abrv)

    return self
        
#+END_SRC

*Nótese que al actuar sobre =self.lista=, las transformaciones elementales no crean nuevos 
=Sistemas= sino que modifican el =Sistema= sobre el que actúan.*

**** Implementación de las transformaciones elementales por la izquierda

Hacen lo mismo que por la derecha (como ocurre con el operador selector)

#+name: Transformaciones elementales por la izquierda de un Sistema
#+BEGIN_SRC python 
        
def __rand__(self, operaciones):
    """Hace exactamente lo mismo que el método __and__ por la derecha."""
    return self & operaciones
    
#+END_SRC

*** Eliminación
**** Reducción por eliminación mediante transformaciones elementales

#+name: Análisis de las opciones de eliminación elegidas
#+BEGIN_SRC python

def analisis_opcion_elegida(tipo):
    'Análisis de las opciones de eliminación elegidas'
    lista = [100,20,10,4,2,1]
    opcion = set()
    for t in lista:
        if (tipo - (tipo % t)) in lista:
            opcion.add(tipo - (tipo % t))
            tipo = tipo % t
    return opcion
    
#+END_SRC


#+name: Variantes de eliminación
#+BEGIN_SRC python :noweb no-export
def metodos_auxiliares_de_la(variante):
    """Define los métodos auxilares y el módo de actuació sobre el sistema
    en función de la variante de elimiación elegida.

    'variante' es la suma de los siguientes números:
        
       +1 reduccion rápida (solo transformaciones tipo I)
       +2 doble reducción
       +4 por filas
      +10 normalización de los pivotes
      +20 escalonamiento
     +100 de atrás hacia delante
    
    Por defecto arg = 0 (reducción simple hacia delante, por
    columnas y evitando fraciones)

    """
    if 100 in analisis_opcion_elegida(variante): # reducción hacia delante
        componentesAmodificar     = lambda    sistema:  filter(lambda x:  x < indiceXP, range(1,len(sistema)+1))
        recorrido                 = lambda    sistema:  reversed(list(enumerate(CreaSistema(sistema),1)))
        XPivote                   = lambda componente:  elementoAntiPivote(componente)
        posicionXPivote           = lambda componente:  ultimo_no_nulo(componente)
                
    else:                                    # reducción hacia atrás
        componentesAmodificar     = lambda    sistema:  filter(lambda x:  x > indiceXP, range(1,len(sistema)+1))
        recorrido                 = lambda    sistema:  enumerate(CreaSistema(sistema),1)
        XPivote                   = lambda componente:  elementoPivote(componente)
        posicionXPivote           = lambda componente:  primer_no_nulo(componente)
        
    if 4 in analisis_opcion_elegida(variante):   # reducción de los componentes en arreglos rectangulares
        if (not self.es_arreglo_rectangular()) or (not all([item.es_de_composicion_uniforme() for item in self])):
            raise ValueError('El sistema debe ser un arreglo rectangular con componentes de composición uniforme')
        sistema = ~self.fullcopy().subs(sust);
    else:
        sistema = self.fullcopy().subs(sust);

    if 2 in analisis_opcion_elegida(variante):   # doble reducción (reducción posiciones anteriores y posteriores al pivote)
        componentesAmodificar = lambda    sistema:  filter(lambda x: x != indiceXP, range(1,len(sistema)+1))

    return sistema, recorrido, XPivote, posicionXPivote, componentesAmodificar

    
def Reduccion(sistema):
    if 1 in analisis_opcion_elegida(variante):   # reducción rápida (solo trasformaciones tipo I)
        operaciones = [ (-fracc(ValorAEliminar(indiceVAE), pivote), indiceXP, indiceVAE)  \
                                                    for indiceVAE in componentesAmodificar(sistema)]
    else:                                        # reducción lenta (evitando fracciones)
        operaciones = [[( denom(ValorAEliminar(indiceVAE), pivote),           indiceVAE), \
                        (-numer(ValorAEliminar(indiceVAE), pivote), indiceXP, indiceVAE)] \
                                                    for indiceVAE in componentesAmodificar(sistema)]
    return filtradopasos(T(operaciones))

def Normalizacion(sistema):
    return filtradopasos(T([ (fracc(1, XPivote(sistema|indiceXP)), indiceXP)
                             for indiceXP,_ in recorrido(sistema) if XPivote(sistema|indiceXP)]))

def Escalonamiento(sistema):
    M = sistema.copy()
    if 100 in analisis_opcion_elegida(variante): # con reducción hacia atrás
        destino       = lambda     : (M.n)-r+1
        resto         = lambda    r: slice(None, max(M.n-r,1))
        columnaAMover = lambda i, r: posicionXPivote(i|M|resto(r))[0]   if posicionXPivote(i|M|resto(r)) and i==posicionXPivote(M|posicionXPivote(i|M|resto(r))[0]  )[0] else 0
    else:                                        # con reducción hacia delante
        destino       = lambda     : r
        resto         = lambda    r: slice(r+1, None)
        columnaAMover = lambda i, r: posicionXPivote(i|M|resto(r))[0]+r if posicionXPivote(i|M|resto(r)) and i==posicionXPivote(M|posicionXPivote(i|M|resto(r))[0]+r)[0] else 0

    r = 0
    intercambios = []
    for i,_ in recorrido(M|1):
        indiceColumnaPivote = columnaAMover(i,r)
        if indiceColumnaPivote:
            r += 1
            intercambio  = T( {destino(), indiceColumnaPivote} )
            M & intercambio
            intercambios.append(intercambio)
            
    return filtradopasos(T(intercambios))


def transformacionYPasos(sistema, operacion, pasosPrevios):
    pasoDado = operacion(sistema)
    if 4 in analisis_opcion_elegida(variante):    # reducción de los componentes en arreglos rectangulares
        pasosAcumulados = [~pasoDado] + pasosPrevios if pasoDado else pasosPrevios
    else:
        pasosAcumulados = pasosPrevios  + [pasoDado] if pasoDado else pasosPrevios
    sistema & T(pasoDado)
    return sistema.subs(sust), pasosAcumulados


def sistemaFinalYPasosDchaIzda(sistema,transformaciones):
    if 4 in analisis_opcion_elegida(variante):    # reducción de los componentes en arreglos rectangulares
        TransformacionesPorLaIzquierda = filtradopasos(transformaciones)
        TransformacionesPorLaDerecha   = []
        if self.es_arreglo_rectangular():
            sistema = ~sistema
    else: 
        TransformacionesPorLaDerecha   = filtradopasos(transformaciones)
        TransformacionesPorLaIzquierda = []

    SistemaFinal =  sistema.subs(sust)
    pasos        = [TransformacionesPorLaIzquierda, TransformacionesPorLaDerecha]
    SistemaFinal.tex, SistemaFinal.pasos = texYpasos(self, pasos, rep, sust, repsust)
    SistemaFinal.TrF = T(SistemaFinal.pasos[0])
    SistemaFinal.TrC = T(SistemaFinal.pasos[1])
    return SistemaFinal

#+END_SRC



#+name: Eliminación
#+BEGIN_SRC python :noweb no-export

def elim(self, variante=0, rep=False, sust=[], repsust=False):
    """Versión pre-escalonada de un sistema por eliminacion Derecha-Izquierda"""
    <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
    <<Variantes de eliminación>>
    <<Análisis de las opciones de eliminación elegidas>>
    
    if not self:
        return sistemaFinalYPasosDchaIzda(Sistema([]), [T([])] )
    
    if not self.es_de_composicion_y_longitud_uniforme():
        raise ValueError('Los elementos del sistema deben ser del mismo tipo y longitud')
    
    ValorAEliminar = lambda indiceVAE: sistema.extractor([indiceVAE]+posicionXPivote(sistema|indiceXP))
    sistema, recorrido, XPivote, posicionXPivote, componentesAmodificar = metodos_auxiliares_de_la(variante)
    
    pasosAcumulados = []
    for indiceXP,_ in recorrido(sistema):
        pivote = XPivote(sistema|indiceXP)        
        if pivote:                               # reducción
            sistema, pasosAcumulados = transformacionYPasos(sistema,  Reduccion,  pasosAcumulados)
            
    if 10 in analisis_opcion_elegida(variante):  # normalización de pivotes
        sistema, pasosAcumulados = transformacionYPasos(sistema,  Normalizacion,  pasosAcumulados)

    if 20 in analisis_opcion_elegida(variante):  # escalonamiento
        sistema, pasosAcumulados = transformacionYPasos(sistema, Escalonamiento,  pasosAcumulados)

    return sistemaFinalYPasosDchaIzda(sistema, pasosAcumulados)
        
#+END_SRC



#+name: formas escalonadas
#+BEGIN_SRC python

def K(self,rep=0, sust=[], repsust=0):
    """Una forma pre-escalonada por columnas (K) de una Matrix"""
    return self.elim(0, rep, sust, repsust)
    
def L(self,rep=0, sust=[], repsust=0): 
    """Una forma escalonada por columnas (L) de una Matrix"""
    return self.elim(20, rep, sust, repsust)
    
def R(self,rep=0, sust=[], repsust=0):
    """Forma escalonada reducida por columnas (R) de una Matrix"""
    return self.elim(32, rep, sust, repsust)

def U(self,rep=0, sust=[], repsust=0): 
    """Una forma escalonada por filas (U) de una Matrix"""
    return self.elim(24, rep, sust, repsust)

def UR(self,rep=0, sust=[], repsust=0): 
    """Una forma escalonada reducida por filas (U) de una Matrix"""
    return self.elim(36, rep, sust, repsust)

#+END_SRC

**** Representación de los procesos de eliminación Gaussiana

Cuando hemos encadenado varios procedimientos de eliminación,
deberíamos poder ver los pasos desde el principio hasta el final. Para
ello comprobamos si =data= fue obtenido mediante un proceso previo de
eliminación. El modo de saberlo es comprobar si =data= posee el
atributo =pasos=.  El atributo =tex= guarda el código \LaTeX{} que
muestra el proceso completo, y se construye aplicando el método
=PasosYEscritura=.  El atributo =pasos= guarda las listas de
abreviaturas de las transformaciones elementales empleadas. Por
comodidad añadimos dos atributos más: =TrF= es la
\texttt{T}transformación aplicada a las filas y =TrC= es la
\texttt{T}ransformación aplicada a las columnas.

#+name: Método que define los atributos .tex y .pasos y representa los pasos si se pide
#+BEGIN_SRC python

def texYpasos(data, pasos, rep=0, sust=[], repsust=0):
    pasosPrevios = data.pasos if hasattr(data, 'pasos') and data.pasos else [[],[]]
    TexPasosPrev = data.tex   if hasattr(data, 'tex')   and data.tex   else []
    if repsust:
        tex = rprElim(data, pasos, TexPasosPrev, sust)
    else:
        tex = rprElim(data, pasos, TexPasosPrev)
    pasos[0] = pasos[0] + pasosPrevios[0] 
    pasos[1] = pasosPrevios[1] + pasos[1]
    
    if rep:
        display(Math(tex))
    
    return tex, pasos

#+END_SRC

Cuando mostramos los pasos, es más legible mostrar únicamente los
que modifican la matriz (omitiendo sustituciones de una columna por
ella misma, productos de una columna por 1, o sumas de un vector nulo
a una columna). 

El atributo ~tex~ guardará el código \LaTeX{} que muestra el proceso
completo. Si ha habido transformaciones previas, la cadena de \LaTeX{}
que permite su representación en el entorno Jupyter estará guardada en
la variable (=TexPasosPrev=), y a dicha cadena hay que añadir la
correspondiente cadena de \LaTeX{} que permita representar los nuevos =pasos= dados como argumento de este método. Si =TexPasosPrev= es
vacío, la escritura comienza con la representación de =data=. A la
hora de representar los pasos hay que tener en cuenta si se dan sobre
las filas (~l==0~) o sobre las columnas (~l==1~). 

#+name: Representación de un proceso de eliminación rprElim
#+BEGIN_SRC python

def rprElim(data, pasos, TexPasosPrev=[], sust=[]):
    """Escribe en LaTeX los pasos efectivos y los sucesivos sistemas"""
    A     = data.fullcopy().subs(sust)
    tex   = latex(A) if not TexPasosPrev else TexPasosPrev
    
    # transformaciones por la izquierda
    for  _,pasoDeEliminacion in enumerate(pasos[0][::-1]):
        if data.es_arreglo_rectangular(): # entonces transforman las filas
            tex += '\\xrightarrow[' + latex( pasoDeEliminacion.subs(sust) ) + ']{}' 
            tex += latex( ( pasoDeEliminacion & A).subs(sust) )
        else:  # hacen lo mismo que por la derecha
            tex += '\\xrightarrow{' + latex( pasoDeEliminacion.subs(sust) ) + '}'
            tex += latex( (A & pasoDeEliminacion ).subs(sust) )
        
    # transformaciones por la derecha
    for  _,pasoDeEliminacion in enumerate(pasos[1]):
        tex += '\\xrightarrow{' + latex( pasoDeEliminacion.subs(sust) ) + '}'
        tex += latex( (A & pasoDeEliminacion ).subs(sust) )
                
    return tex

#+END_SRC

#+name: Representación de un proceso de eliminación rprElimCF
#+BEGIN_SRC python

def rprElimCF(data, pasos, TexPasosPrev=[], sust=[]):
    """Escribe en LaTeX los pasos efectivos y los sucesivos arreglos rectangulares"""
    if not data.es_arreglo_rectangular():
        raise ValueError('El sistema tiene que ser un arreglo rectangular')
    if len(pasos[0])!=len(pasos[1]):
        raise ValueError('Esta representación requiere el mismo número de pasos por la izquierda y la derecha')
    
    A = data.fullcopy().subs(sust)                                                               
    tex = latex(data) if not TexPasosPrev else TexPasosPrev

    for  i,pasoDeEliminacionFilas in enumerate(pasos[0][::-1]):
        tex += '\\xrightarrow{' + latex( (pasos[1][i]).subs(sust) ) + '}'
        tex += latex( (A & pasos[1][i]).subs(sust) )
        tex += '\\xrightarrow[' + latex( (pasoDeEliminacionFilas).subs(sust) ) + ']{}' 
        tex += latex( (pasoDeEliminacionFilas & A).subs(sust) )
                                                               
    return tex

#+END_SRC

#+name: Representación de un proceso de eliminación rprElimFyC
#+BEGIN_SRC python

def rprElimFyC(data, pasos, TexPasosPrev=[], sust=[]):
    """Escribe en LaTeX los pasos efectivos y los sucesivos arreglos rectangulares"""
    if not data.es_arreglo_rectangular():
        raise ValueError('El sistema tiene que ser un arreglo rectangular.')
    if len(pasos[0])!=len(pasos[1]):
        raise ValueError('Esta representación requiere el mismo número de pasos por la izquierda y la derecha')
    
    A = data.fullcopy().subs(sust)
    tex = latex(data) if not TexPasosPrev else TexPasosPrev

    for  i,pasoDeEliminacionFilas in enumerate(pasos[0][::-1]):
        tex += '\\xrightarrow' \
                + '[' + latex( (pasoDeEliminacionFilas).subs(sust) ) + ']' \
                + '{' + latex( (pasos[1][i]).subs(sust)            ) + '}'
        tex += latex( ( pasoDeEliminacionFilas & A & pasos[1][i] ).subs(sust) )
                                                               
    return tex

#+END_SRC

Estos procedimientos son para ``mostrar'' en los Jupyter notebooks los pasos de eliminación.

#+name: Representación de un proceso de eliminación dispElim, dispElimFyC y dispElimCF
#+BEGIN_SRC python

def dispElim(self, pasos, TexPasosPrev=[]):
    display(Math(rprElim(self, pasos, TexPasosPrev)))

def dispElimFyC(self, pasos, TexPasosPrev=[]):
    display(Math(rprElimFyC(self, pasos, TexPasosPrev)))

def dispElimCF(self, pasos, TexPasosPrev=[]):
    display(Math(rprElimCF(self, pasos, TexPasosPrev)))

#+END_SRC

*** Representación de la clase ~Sistema~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos de representación de la clase Sistema
       :END:

# Véase [[https://www.digitalocean.com/community/tutorials/python-str-repr-functions]]

Necesitamos indicar a Python cómo representar los objetos de tipo
=Sistema=. Los sistemas, son secuencias finitas de objetos que
representaremos con corchetes, separando los elementos por ``;''
\begin{displaymath}
  \Vect{v}=[v_1;\ \ldots;\ v_n;]
\end{displaymath}
Si la lista es vacía, entonces se pintan unos corchetes =[ ]= sin
 ``;'' (por no haber elementos). 

Definimos varios tipos de representación.

- La primera se muestra con la función =print()= o la función =str()=
  y está formada por caracteres ASCII. Es la que se ve en la línea de
  comandos. Entre corchetes muestra todos los elementos de
  =self.lista= separados por ``puntos y comas'' (=;=):
  
  Si, por ejemplo, el atributo =.posicionDivisiones= (/``corta Sistema''/) indica que
  se separen las dos primeras componentes del sistema respecto de la
  última, esta representación pinta una barra vertical detrás de la
  segunda componente (véase la Sección [[Ejemplo de representación de un
  ~Sistema~]]).

# f-strings https://realpython.com/python-f-strings/  necesito python 3.12 mínimo
# l=[f"{((i,)|I(4))!s}" for i,e in enumerate(I(4)) ]
# f"{'\n'.join(l)}"

#+BEGIN_SRC python

def __str__(self):
    """ Muestra un Sistema en su representación python """
    pc = ';' if len(self.lista) else ''
    ln = [len(n) for n in particion(self.posicionDivisiones,self.n)]
    return '[' + \
             ';|'.join(['; '.join([str(c) for c in s]) \
                       for s in [ self|i for i in particion(self.posicionDivisiones, self.n)] ]) + pc + ']'

#+END_SRC

- La segunda forma de representación se muestra con la función
  =repr()= y también está formada por caracteres ASCII. Se parece a la
  anterior, pero indica explícitamente que el objeto es un =Sistema= y
  no muestra ninguna barra vertical que separe el sistema en
  sublistas.

 
#+BEGIN_SRC python

def __repr__(self):
    """ Muestra un Sistema en su representación python """
    pc = ';' if len(self.lista) else ''
    return 'Sistema([' + '; '.join( repr (e) for e in self ) + pc + '])'

#+END_SRC


 - La representación =latex= (\LaTeX{}) es similar a la primera
   representación (=str=), pues también muestra barras
   verticales que separan la lista de elementos en sub-listas si el
   atributo =.posicionDivisiones= así lo indica. La única diferencia es que los
   elementos aparecen con su representación =latex= (cuando la
   tienen).

   Es la representación que los Notebooks de Jupyter emplean por
   defecto (y también es usada por Emacs (Scimax) mediante los dos
   últimos métodos que aparecen más abajo).

   Llamamos a la representación =latex= con los métodos =display()= y
   =pinta()=.

   # Véase la Sección [[Otros métodos auxilares]])

#+BEGIN_SRC python

def latex(self):
    """ Construye el comando LaTeX para representar un Sistema """
    pc = ';' if len(self) else r'\ '
    ln = [len(i) for i in particion(self.posicionDivisiones, len(self))]                                                           
    return \
        r'\left[ \begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
        r';& '.join([latex(e) for e in self]) + pc + \
        r'\end{array} \right]'

#+END_SRC


- Jupyter llama al método =__repr_html__= (que a su vez llama al
  método general =html= (véase [[Métodos de representación para el
  entorno Jupyter]]) para mostrar la representación =latex= de los
  objetos en el navegador.

#+BEGIN_SRC python
def _repr_html_(self):
    """ Construye la representación para el entorno jupyter notebook """
    return html(self.latex())

#+END_SRC

- Es posible trabajar con los Jupyter Notebooks dentro de [[https://www.gnu.org/software/emacs/][Emacs]] con la
  configuración [[https://github.com/jkitchin/scimax][Scimax]]. Para poder visualizar la representación
  \LaTeX{} dentro del editor, es necesario generar las imágenes en
  ficheros auxiliares ~png~. Para ello, definimos un par de
  representaciones adicionales usadas en los Notebooks con Emacs.

#+BEGIN_SRC python
def _repr_latex_(self):
    """ Representación para el entorno jupyter en Emacs """
    return '$'+self.latex()+'$'

def _repr_png_(self):
    """ Representación png para el entorno jupyter en Emacs """
    try:
        expr = '$'+self.latex()+'$'
        workdir = tempfile.mkdtemp()
        with open(join(workdir, 'borrame.png'), 'wb') as outputfile:
            sympy.preview(expr, viewer='BytesIO', outputbuffer=outputfile)
        return open(join(workdir, 'borrame.png'),'rb').read()
    except:
        return '$'+self.latex()+'$'
                                                               
#+END_SRC

***** Método para establecer los índices donde poner marcas de corte de un Sistema

Para separar visualmente distintas partes de un sistema es necesario
indicar los índices de los componentes tras lo que se mostrará una
barra vertical. Para especificar dichos índices se llama al método
=ccol()= (que usaremos para visualmente /cortar por columnas/ una
matriz).
#+BEGIN_SRC python

def ccol(self, conjuntoIndices={}):
    """Modifica el atributo posicionDivisiones para insertar lineas entre
    determinados elementos del sistema

    """
    self.posicionDivisiones = set(conjuntoIndices) if conjuntoIndices else {0}
    return self

#+END_SRC

**** Ejemplo de representación de un ~Sistema~
   :PROPERTIES:
   :header-args:    :tangle no
   :END:

Veamos la representación =str= de un sistema =A= con tres elementos:
#+BEGIN_SRC jupyter-python :exports code :results silent 
A = Sistema([ 2, fracc(a,b), sympy.sqrt(5), ])
print( A )
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw # :results output replace 
dprint( A )
#+END_SRC

#+RESULTS:
=[2; a/b; sqrt(5);]=

Si incluimos una separación visual detrás de la segunda componente de
=A= su representación =str= es:
#+BEGIN_SRC jupyter-python :exports code :results silent
A.ccol({2})
print( A )
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dprint( A )
#+END_SRC

#+RESULTS:
=[2; a/b;|sqrt(5);]=

Sin embargo, la representación =repr= no muestra la barra vertical de
separación:
#+BEGIN_SRC jupyter-python :exports code :results silent
repr( A )
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dprint( repr(A) )
#+END_SRC

#+RESULTS:
=Sistema([2; a/b; sqrt(5);])=

La barra vertical de separación visual sí se muestra en la
representación =latex= (es la representación empleada por defecto en
los Notebooks de Jupyter y en el material del curso de Álgebra
Lineal):
#+BEGIN_SRC jupyter-python :exports both
pinta(A)
#+END_SRC

#+RESULTS:
:RESULTS:
$\displaystyle \left[ \begin{array}{cc|c}2;& \frac{a}{b};& \sqrt{5};\end{array} \right]$
:END:

**** Ejemplo de representación con un ~Sistema~ más complejo
   :PROPERTIES:
   :header-args: :tangle no
   :header-args: :results output replace
   :END:

Únicamente cuando un =Sistema= tiene una estructura muy sencilla las
tres formas de representación de ~Sistemas~ son prácticas. Por
ejemplo, la representación =str= se ve mal cuando el sistema contiene
objetos que son complicados de representar (por ejemplo matrices
dentro de otros sistemas). Por otra parte, aunque la representación
=repr= indica claramente cuál es el tipo de cada objeto, es difícil
ver qué contiene cada uno de los objetos. La representación =latex=
es, con diferencia, la más fácil de interpretar de un simple vistazo.

En el siguiente ejemplo, con =.ccol({1})= indicamos que el primer
elemento del sistema debe estar visualmente separado del resto.

#+BEGIN_SRC jupyter-python :exports code :results silent
a,b,c = sympy.symbols('a b c')
vv = Vector([1,2,3])
Z = Sistema( [ Vector([6,8,10],rpr='fila').ccol({2}), vv , 1492] ) 
ZZ = Sistema([ Z, 'Hola', Matrix([Vector([0,sympy.pi,fracc(a,2)]),Vector([0,0,0])])  ]).ccol({1})
print(ZZ)
repr(ZZ)
ZZ
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dprint( ZZ )
#+END_SRC

#+RESULTS:
=[[(6, 8,|10,); (1, 2, 3,); 1492;];|Hola; |  0   0|\n| pi   0|\n|a/2   0|;]=

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dprint( repr(ZZ) )
#+END_SRC

#+RESULTS:
=Sistema([Sistema([Vector([6, 8, 10]); Vector([1, 2, 3]); 1492;]); 'Hola'; Matrix([Vector([0, pi, a/2]), Vector([0, 0, 0])]);])=

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
pinta(ZZ)
#+END_SRC

#+RESULTS:
$\displaystyle \left[ \begin{array}{c|cc}\left[ \begin{array}{ccc}\left( \begin{array}{c}6\\8\\ \hline 10\\ \end{array} \right);& \left( \begin{array}{c}1\\2\\3\\ \end{array} \right);& 1492;\end{array} \right];& \mathtt{\text{Hola}};& \left[ \begin{array}{cc}0&0\\\pi&0\\\frac{a}{2}&0\\ \end{array} \right];\end{array} \right]$


\clearpage

*** La clase ~Sistema~ completa

#+name: Definición de la clase Sistema
#+BEGIN_SRC python :noweb no-export
class Sistema:
    <<Texto de ayuda de la clase Sistema>>
    <<Inicialización de la clase Sistema>>
    <<Métodos de la clase Sistema para que actúe como si fuera una list de Python>>
    <<Método de la clase Sistema para concatenar dos sistemas>>
    <<Método que junta una lista de Sistemas en un único Sistema>>
    <<Método que amplía la lista de un Sistema con nuevos elementos>>
    <<Sustitución de variables simbólicas>>
    <<Simplificación de expresiones simbólicas>>
    <<Sustitución de un símbolo por otro símbolo o valor en un Sistema>>
    <<Otros métodos de la clase Sistema>>
    <<Métodos que devuelven SubEspacios>>
    <<Método de resolución de sistema de Ecuaciones lineales>>
    <<Operador selector por la derecha para la clase Sistema>>
    <<Operador selector por la izquierda para la clase Sistema>>
    <<Suma y diferencia de Sistemas>>
    <<Producto de un Sistema por un escalar a su izquierda>>
    <<Opuesto de un Sistema>>
    <<Producto de un Sistema por un escalar un Vector o una Matrix a su derecha>>
    <<Transformaciones elementales de los elementos de un Sistema>>
    <<Transformaciones elementales por la izquierda de un Sistema>>
    <<Reducción por eliminacion>>
    <<Eliminación>>
    <<formas escalonadas>>
    <<Métodos de representación de la clase Sistema>>
    
#+END_SRC


** La subclase ~BlockV~

En el curso de Álgebra Lineal empleamos arreglos rectangulares de
objetos (principalmente las matrices). En NAcAL, la clase de los
arreglos rectangulares de objetos son los =BlockM= (``Block
Matrix''). Son =Sistemas= formados por una lista de =Sistemas= de la
misma longitud y que representamos verticalmente para formar las
columnas del arreglo rectangular.

En consecuencia, los elementos de un =BlockM= son /sistemas con una
representación vertical/. Así pues, en este capítulo se define una
primera subclase de la clase =Sistema= cuya representación difiere de
la de los =Sistemas= genéricos. A estos subsistemas los denominamos
=BlockV=.

Por defecto, los =BlockV= tienen representación =latex= vertical
(opcionalmente podremos representarlos horizontalmente). Para
distinguirlos de los =Sistemas= genéricos, su lista de componentes
está encerrada entre paréntesis (en lugar de corchetes); y si se
representan horizontalmente, tras de cada elemento aparece una /coma/
(=,=) en lugar de un /punto y coma/ (=;=). Así que para instanciar un
=BlockV=, además del argumento con la lista de elementos del sistema,
disponemos de un segundo argumento opcional (=rpr=) que indica si
queremos una representación vertical (por defecto es la que se usará
si no se indica nada) u horizontal. En todo lo demás, un =BlockV= es
como un =Sistema= genérico.

*** Implementación

**** Texto de ayuda

#+name: Texto de ayuda de la subclase BlockV
#+BEGIN_SRC python
"""BlockV es un Sistema que se puede representar verticalmente.

Se puede instanciar con una lista, tupla o otro Sistema. Si al
instanciar un BlockV la lista, tupla o sistema solo contiene números
el objeto obtenido es un Vector (subclase de BlockV).

El atributo 'rpr' indica si la representación latex debe mostrar el
sistema en disposición vertical (por defecto) u horizontal.

Parámetros:
    sis   (list, tuple, Sistema): Lista, tupla o Sistema de objetos.
    rpr   (str): Para su representación latex (en vertical por defecto).
                  Si rpr='fila' se representa en forma horizontal. 

Atributos de la subclase:
    rpr   (str): modo de representación en Jupyter.

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    posicionDivisiones (set) : Conjunto de índices donde pintar
                                separaciones visuales

Ejemplos:
>>> # Instanciación a partir de una lista, tupla o Sistema de números
>>> BlockV( [1,'abc',(2,)] )            # con una lista
>>> BlockV( (1,'abc',(2,)) )            # con una tupla
>>> BlockV( Sistema( [1,'abc',(2,)] ) ) # con un Sistema
>>> BlockV( BlockV ( [1,'abc',(2,)] ) ) # a partir de otro BlockV

BlockV( [1,'abc',(2,)] )

>>> BlockV( [1,2,3)] )                  # con una lista de números

Vector( [1,2,3] )
"""
#+END_SRC

**** Método de inicialización:

=BlockV= es una subclase =Sistema=. Se inicia con el método: ~def
__init__(self, arg, rpr='columna')~.

- La clase =BlockV= se instancia con dos argumentos. 

  1. =arg= es obligatorio y debe ser una lista, tupla o =Sistema=.

  2. =rpr= es opcional e indica si queremos que la representación
     =latex= sea en forma horizontal o en vertical. Por defecto la
     representación es vertical. Para una disposición horizontal ~rpr~
     de ser la cadena de caracteres =fila=, es decir, ~rpr='fila'~.

- Con =super().__init__(arg)= la subclase =BlockV= hereda los métodos
  y atributos de la clase =Sistema=. En consecuencia =BlockV= tendrá
  los atributos =lista=, =n= y =posicionDivisiones= así como todos los
  métodos definidos para la clase =Sistema=.

- El atributo =rpr= tomará el valor indicado al instanciar la clase
  (='columna'= por defecto). Y el atributo =n= será igual al número de
  elementos del sistema (su longitud).

- Por último, un =BlockV= cuya lista tan solo contiene números es un
  vector de \R[n].

  Consecuentemente, cuando todos los elementos de =arg= son [[Números][números]]
  (Véase la Sección [[Números]]) el objeto que se crea es un =Vector= (una
  subclase de =BlockV= que solo contiene números).


#+name: Inicialización de la subclase BlockV
#+BEGIN_SRC python

def __init__(self, arg, rpr='columna'):
    """Inicializa un BlockV con una lista, tupla o Sistema"""
    super().__init__(arg)
    self.rpr  =  rpr
    self.n  = len(self)
    
    if all( [es_numero(e) for e in arg] ): self.__class__ = Vector

#+END_SRC

*** Representación de la clase ~BlockV~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos de representación de la subclase BlockV
       :END:

Un =BlockV= es una secuencia finita de objetos; es decir, un
=Sistema=.  La única diferencia respecto de un =Sistema= genérico es
su representación. Por tanto solo necesitamos redefinir las
representaciones =str=, =repr= y =latex= de esta subclase particular
de =Sistema=.

#+BEGIN_SRC python

def __repr__(self):
    """ Muestra el BlockV en su representación Python """
    return 'BlockV(' + repr(self.lista) + ')'
                           
def __str__(self):
    """ Muestra el BlockV en su representación Python """
    pc = ',' if len(self.lista) else ''
    ln = [len(n) for n in particion(self.posicionDivisiones,self.n)]
    return '(' + \
        ',|'.join([', '.join([str(c) for c in s]) \
                   for s in [ self|i for i in particion(self.posicionDivisiones, self.n)]]) + \
        pc + ')'

def latex(self):
    """ Construye el comando LaTeX para representar un BlockV """
    pc = ',' if len(self) else r'\ '
    ln = [len(n) for n in particion(self.posicionDivisiones,self.n)]
    if self.rpr == 'fila' or self.n==1:    
        return \
            r'\left( \begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
            r',& '.join([latex(e) for e in self]) + pc + \
            r'\\ \end{array} \right)'
    else:
        return \
            r'\left( \begin{array}{c}' + \
            r'\\ \hline '.join([r'\\'.join([latex(c) for c in e]) \
                                for e in [ self|i for i in particion(self.posicionDivisiones, self.n)]]) + \
            r'\\ \end{array} \right)'

#+END_SRC

**** Ejemplo de representación de un ~BlockV~
   :PROPERTIES:
   :header-args: :tangle no
   :header-args: :results output replace
   :END:

Veamos la representación de un =BlockM= cuya lista contiene una matriz
dos por tres y tres números.
#+BEGIN_SRC jupyter-python :exports code :results silent
BV = BlockV([Matrix([[1,2,3],[4,5,6]]), 1,0,0])
#+END_SRC

La representación =str= es no es práctica en este caso, pues su
elemento =Matrix= necesita de un salto de línea, por lo que la
visualización algo deficiente:
#+BEGIN_SRC jupyter-python :exports results :display text/plain
# :results raw :results output replace
dprint(BV) 
#+END_SRC

#+RESULTS:
:RESULTS:
=(|1 2 3|\n|4 5 6|, 1, 0, 0,)=
:END:

La representación =repr= es mejor, pero resulta difícil leer 
qué objetos son elementos de otros:
#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dprint( repr(BV) )
#+END_SRC

#+RESULTS:
=BlockV([Matrix([Vector([1, 4]), Vector([2, 5]), Vector([3, 6])]), 1, 0, 0])=

La representación =latex= es la mejor:
#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
pinta( BV )
#+END_SRC

#+RESULTS:
$\displaystyle \left( \begin{array}{c}\left[ \begin{array}{ccc}1&2&3\\4&5&6\\ \end{array} \right]\\1\\0\\0\\ \end{array} \right)$

y también la podemos usar en horizontal:
#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
BV.rpr='fila'
pinta( BV )
#+END_SRC

#+RESULTS:
$\displaystyle \left( \begin{array}{cccc}\left[ \begin{array}{ccc}1&2&3\\4&5&6\\ \end{array} \right],& 1,& 0,& 0,\\ \end{array} \right)$

*********** COMMENT Ejemplo descartado                             :noexport:
Repetimos aquí el último ejemplo de representación de la clase
=Sistema= pero en este caso en forma de =BlockV=.  Fíjese que al
disponer los elementos en vertical en la representación =latex=, es
ligeramente más fácil entender la estructura del sistema.
#+BEGIN_SRC jupyter-python :exports code :results silent
vv = Vector([1,2,3])
Z = Sistema( [ Vector([6,8,10],rpr='fila').ccol({2}), vv , 1492] )  
ZZ = BlockV([ Z, 'Hola', Matrix([Vector([0,sympy.pi,fracc(a,2)]),Vector([0,0,0])])  ]).ccol({1})
print(ZZ)
repr(ZZ)
ZZ
#+END_SRC

#+BEGIN_SRC jupyter-python :exports results :results raw
# :results output replace
pinta( BV )
#+END_SRC

#+RESULTS:
$\displaystyle \left( \begin{array}{c}\left[ \begin{array}{ccc}1&2&3\\4&5&6\\ \end{array} \right]\\1\\0\\0\\ \end{array} \right)$

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
dprint( repr(ZZ) )
#+END_SRC

#+RESULTS:
=BlockV([Sistema([Vector([6, 8, 10]); Vector([1, 2, 3]); 1492;]), 'Hola', Matrix([Vector([0, pi, a/2]), Vector([0, 0, 0])])])=

#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
pinta(ZZ)
#+END_SRC

#+RESULTS:
$\displaystyle \left( \begin{array}{c}\left[ \begin{array}{ccc}\left( \begin{array}{cc|c}6,& 8,& 10,\\ \end{array} \right);& \left( \begin{array}{c}1\\2\\3\\ \end{array} \right);& 1492;\end{array} \right]\\ \hline \mathtt{\text{Hola}}\\\left[ \begin{array}{cc}0&0\\\pi&0\\\frac{a}{2}&0\\ \end{array} \right]\\ \end{array} \right)$

*** La clase ~BlockV~ completa

#+name: Definición de la subclase BlockV
#+BEGIN_SRC python :noweb no-export
class BlockV(Sistema):
    <<Texto de ayuda de la subclase BlockV>>
    <<Inicialización de la subclase BlockV>>
    <<Métodos de representación de la subclase BlockV>>
#+END_SRC


** La subclase ~Vector~

El [[https://mbujosab.github.io/CursoDeAlgebraLineal/libro.pdf#section.1.1][curso]] de Álgebra Lineal define un vector de \R[n] del siguiente
modo
\begin{center}
  Un \emph{vector} de \R[n] es un \emph{sistema} de $n$ números reales;
\end{center}
y se indica que los vectores se representan entre paréntesis tanto
horizontal como verticalmente. Por tanto hay que redefinir la
representación de la clase ~Vector~ para que los =Vectores= no sean
representados como =Sistemas= genéricos, sino a la manera de los
vectores.

Pero esto ya se hace en el capítulo anterior con los =BlockV=. Como un
=Vector= es un =BlockV= que solo contiene números, lo más sencillo es
definir la clase =Vector= como una subclase =BlockV= que solo contiene
números. Así solo necesitamos redefinir la representación =repr= para
que indique específicamente que se trata de un =Vector=, ya que la
subclase =Vector= hereda el resto de métodos y atributos de la clase
=Sistema= y la subclase =BlockV=.

# \begin{pycode}
# v1, v2, v3 = sympy.symbols('v_1 v_2 v_3')
# v = Vector( [v1, v2, v3,] )
# \end{pycode}
# \[\Vect{v}=\py{latex(Vector(v,'fila'))},\]
# o bien en forma de columna:
# \[\Vect{v}=\py{latex(v)}.\]

*** Implementación de los vectores de \R[n] en la subclase ~Vector~

**** Texto de ayuda

#+name: Texto de ayuda de la subclase Vector
#+BEGIN_SRC python
"""Clase para los Sistemas de números.

Sólo se puede instanciar con una lista, tupla o Sistema de objetos
int, float o sympy.Basic. Si se instancia con un Vector se crea una
copia del mismo.

El atributo 'rpr' indica si, en la representación latex, el vector
debe ser escrito como columna (por defecto) o como fila.

Parámetros:
    sis (list, tuple, Sistema): Lista, tupla o Sistema de objetos
        de tipo int, float o sympy.Basic.
    rpr (str): Para su representación latex (en 'columna' por defecto).
        Si rpr='fila' el vector se representa en forma de fila. 

Atributos heredados de la subclase BlockV::
    rpr   (str)    : modo de representación en Jupyter.

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    posicionDivisiones (set) : Conjunto de índices donde pintar
                                separaciones visuales

Ejemplos:
>>> # Instanciación a partir de una lista, tupla o Sistema de números
>>> Vector( [1,2,3] )           # con lista
>>> Vector( (1,2,3) )           # con tupla
>>> Vector( Sistema( [1,2,3] ) )# con Sistema
>>> Vector( Vector ( [1,2,3] ) )# a partir de otro Vector

Vector([1,2,3])
"""
#+END_SRC

**** Método de inicialización:

La clase se inicia con el método: ~def __init__(self, arg, rpr='columna')~.

- La clase =Vector= emplea dos argumentos. El primero (=arg=) es una
  lista, tupla o =Sistema= de objetos tipo =int=, =float= o
  ~sympy.Basic~. Cuando =arg= es un =Vector= se obtiene una copia. El
  segundo argumento (=rpr=) es opcional e indica si queremos que la
  representación =latex= sea en forma horizontal o en vertical (Véase
  la subclase =BlockV=).

- Python mostrará el texto de ayuda sobre el método =__init__= con:
  ~help Vector.__init__~

- Se verifica que =arg= es una secuencia de números (Sección
  [[Ristras]]). Si no lo es obtenemos un error.

- Con =super().__init__(arg)= la subclase =Vector= hereda los métodos
  y atributos de la clase =BlockV= (por tanto, =Vector= tendrá un
  atributo =lista=, así como el resto de atributos y todos los métodos
  definidos para la clase =Sistema= y la subclase =BlockV=).


# - Se definen dos atributos para la subclase clase =Vector=: los
#  atributos =rpr= y =n=.
#
#  * =self.rpr= indica si el vector ha de ser representado como fila o
#    como columna en el entorno [[https://jupyter.org/][Jupyter]].
#
#  * =self.n= es el número de elementos de la lista del =Sistema=.
#
#  */!Ya tenemos traducido al lenguaje Python la definición de vector de \R[n]!/*


#+name: Inicialización de la subclase Vector
#+BEGIN_SRC python :noweb no-export

def __init__(self, arg, rpr='columna'):
    """Inicializa Vector con una lista, tupla o Sistema de números"""                       
    if not es_ristra_de_numeros(arg):
        raise ValueError('no todos los elementos son números o parámetros!')
    
    super().__init__(arg)

#+END_SRC

*** Métodos específicos de la subclase ~Vector~

Aquí se definen algunos métodos específicos de la subclase
=Vector=. El primero calcula la norma euclídea de un =Vector= de
\R[n], es decir, la raíz cuadrada del producto punto del vector por si
mismo.

El segundo usa dicha norma para devolver un múltiplo con norma uno de
cualquier un vector no nulo.

#+name: Normalización de un Vector
#+BEGIN_SRC python

def norma(self):
    """Devuelve la norma de un vector"""
    return sympy.sqrt(self*self)
                                                               
def normalizado(self):
    """Devuelve un múltiplo de norma uno si el vector no es nulo"""
    if self.es_nulo(): raise ValueError('Un vector nulo no se puede normalizar')
    return self * fracc(1,self.norma())

#+END_SRC

El tercer método devuelve una =Matrix= diagonal cuya diagonal
principal es igual a =Vector=.

#+name: Creación de una Matrix diagonal a partir de un Vector
#+BEGIN_SRC python

def diag(self):
    """Crea una Matrix diagonal cuya diagonal es self"""
    return Matrix([a*(I(self.n)|j) for j,a in enumerate(self, 1)])

#+END_SRC

*** Representación de la clase ~Vector~

Necesitamos indicar a Python cómo representar los objetos de tipo
~Vector~.

Los vectores, son secuencias finitas de números que escribimos entre
paréntesis en forma de fila
\begin{displaymath}
  \Vect{v}=(v_1,\ldots,v_n)
\end{displaymath}
o en forma de columna
\begin{displaymath}
  \Vect{v}=\begin{pmatrix}v_1\\ \vdots \\ v_n\end{pmatrix}.
\end{displaymath}

Esta forma de representación ya se ha establecido para la subclase
=BlockV=, por lo que no es necesario volver a programarla. Tan solo
re-especificamos la representación de tipo =repr= para que
explícitamente indique que el objeto es un =Vector=.

#+name: Métodos de representación de la subclase Vector
#+BEGIN_SRC python

def __repr__(self):
    """ Muestra el vector en su representación Python repr """
    return 'Vector(' + repr(self.lista) + ')'

#+END_SRC
*** La clase ~Vector~ completa

#+name: Definición de la subclase Vector
#+BEGIN_SRC python :noweb no-export
class Vector(BlockV):
    <<Texto de ayuda de la subclase Vector>>
    <<Inicialización de la subclase Vector>>
    <<Normalización de un Vector>>
    <<Creación de una Matrix diagonal a partir de un Vector>>
    <<Métodos de representación de la subclase Vector>>
#+END_SRC


** Las subclases ~V0~ y ~V1~

La clase ~V0~ corresponde a vectores nulos. La clase ~V1~ corresponde
a vectores constantes cuyas componentes son todas iguales a 1. En
ambos casos se instancian con un parámetro que indica el número de
componentes y, opcionalmente, el parámetro =rpr= para indicar si la
representación =latex= es en forma de fila o de columna.

#+name: Definición de las subclases V0 y V1
#+BEGIN_SRC python

class V0(Vector):
    """Clase para los Vectores nulos"""
    def __init__(self, n, rpr = 'columna'):
        """Inicializa un vector nulo de n componentes

        V0 se inicializa con

        1) un entero que indica el  número de componentes nulas
    
        2) la cadena de texto rpr. Si rpr = 'fila' la representación
        es horizontal (en otro caso es vertical)

        """
        super().__init__([0]*n, rpr)
        self.__class__ = Vector

class V1(Vector):
    """Clase para los Vectores constantes 1"""
    def __init__(self, n, rpr = 'columna'):
        """Inicializa un vector uno de n componentes

        V1 se inicializa con

        1) un entero que indica el  número de componentes nulas
    
        2) la cadena de texto rpr. Si rpr = 'fila' la representación
        es horizontal (en otro caso es vertical)

        """
        super().__init__([1]*n, rpr)
        self.__class__ = Vector

#+END_SRC


** La subclase ~BlockM~

Un =BlockM= es un sistema de =BlockVs= de la misma longitud, es decir,
es un arreglo rectangular de objetos. A sus elementos los llamaremos
/columnas/ del =BlockM=.

*** Implementación
**** Texto de ayuda

#+name: Texto de ayuda de la clase BlockM
#+BEGIN_SRC python
"""Clase para arreglos rectangulares de objetos.

Sistema formado por BlockVs con el mismo número de componentes. Se
instancia con: 1) una lista, tupla o Sistema de BlockVs (serán sus
columnas); 2) una lista, tupla o Sistema de listas, tuplas o Sistemas
con la misma longitud (serán sus filas); 3) otro BlockM (se obtendrá
una copia).

Parámetros:
    arg (list, tuple, Sistema): Lista, tupla o Sistema de BlockVs
        (con identica longitud); o de listas, tuplas o Sistemas (con
        identica longitud).

Atributos:
    m              (int) : número de filas
    corteElementos (set) : Conjunto de índices donde pintar
                            separaciones visuales entre filas

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    posicionDivisiones (set) : Conjunto de índices donde pintar
                                separaciones visuales

Ejemplos:
>>> # Crear un BlockM a partir de una lista de Vectores o BlockVs:
>>> a = BlockV( ['Hola',2,3] ); b = Vector( [1,2,5] ); c = Vector( [1,2,7] )
>>> BlockM( [a,b,c] )

BlockM([BlockV(['Hola', 2, 3]), Vector([1, 2, 5]), Vector([1, 2, 7])])
>>> # Crear una BlockM a partir de una lista de listas, tuplas o Sistemas
>>> A = BlockM([('Hola',1,1),[2,2,2],Vector([3,5,7])])

BlockM([BlockV(['Hola', 2, 3]), Vector([1, 2, 5]), Vector([1, 2, 7])])

"""
#+END_SRC
   
**** Método de inicialización:

#+name: Inicialización de la subclase BlockM
#+BEGIN_SRC python

def __init__(self, arg):
    """Inicializa un BlockM con una

    1) lista, tupla o Sistema de BlockVs con el mismo número de
    elementos,
    
    2) tupla, lista o Sistema de tuplas, listas o Sistemas con el
    mismo número de elementos,
    
    3) con otra BlockM.

    """
    super().__init__(arg)
    
    lista = Sistema(arg).lista
    
    if all([(isinstance(elemento, BlockV) and len(elemento)==len(lista[0])) for elemento in lista]):
        self.lista   = lista.copy()

    elif all([(es_ristra(elemento) and len(elemento)==len(lista[0])) for elemento in lista]):

        self.lista = BlockM([ BlockV([ elemento[i] for elemento in lista ]) for i in range(len(lista[0])) ]).lista

    elif isinstance(arg, BlockM):
        self.lista   = arg.lista.copy()

    else: 
        raise ValueError("""El argumento debe ser una lista de BlockVs
        o una lista, tupla o Sistema de listas, tuplas o sistemas con
        el mismo número de elementos!""")
    
    self.n  = len(self)
    try: 
        self.m  = (self|1).n
    except:
        self.m  = 0
            
    self.corteElementos = {0}
   
    for v in self.lista:
        v.rpr='columna'
        
    if all( [isinstance(e,Vector) for e in self] ): self.__class__ = Matrix
    
#+END_SRC

*** Métodos de la clase ~BlockM~
**** Transposición de un BlockM

#+name: Operador transposición
#+BEGIN_SRC python

def __invert__(self):
    """
    Devuelve la traspuesta de un BlockM.
    
    Ejemplo:
    >>> ~BlockM([ [1,2,3], [2,4,6] ])
    
    Matrix([ Vector([1, 2, 3]), Vector([2, 4, 6]) ])
    """
    M = BlockM([ Sistema(columna) for columna in self ])
    M.corteElementos, M.posicionDivisiones = self.posicionDivisiones, self.corteElementos
    return M

#+END_SRC

**** Comprobación de que las filas o columnas son de composición homogenea

Si queremos aplicar transformaciones elementales a las columnas o a
las filas de un =BlockM= es necesario que las operaciones entre
componentes tengan sentido. Los siguientes dos métodos nos indican si
es posible realizar dichas operaciones por columnas (si éstas son
homogéneas) o por filas.
#+name: Comprobación de que las filas o columnas son de composición homogenea
#+BEGIN_SRC python

def columnas_homogeneas(self):
    """Indica si las columnas contienen objetos del mismo tipo y longitud"""
    return self.es_de_composicion_y_longitud_uniforme()

def filas_homogeneas(self):
    """Indica si las filas contienen objetos del mismo tipo y longitud"""
    return (~self).es_de_composicion_y_longitud_uniforme()

#+END_SRC

**** Apilado de =BlockMs=

Creamos un =BlockM= apilando =BlockMs= uno encima de otro si tienen el
mismo número de elementos.
#+name: Apila una lista de Sistemas con el mismo número de elementos un BlockM
#+BEGIN_SRC python

def apila(self, lista, marcasVisuales = False):
    """Apila una lista o tupla de BlockMs con el mismo número de elementos
    (columnas) en un BlockM concatenando los respectivos elementos

    """
    apila_dos = lambda x, other, marcasVisuales=False: ~((~x).concatena(~other, marcasVisuales))
    apila = lambda x: x[0] if len(x)==1 else apila_dos( apila(x[0:-1]), x[-1], marcasVisuales)
    return apila([self] + [s for s in CreaLista(lista)])

#+END_SRC

**** Operador selector por la izquierda

#+name: Texto de ayuda para el operador selector por la izquierda para la clase BlockM
#+BEGIN_SRC python
"""Extrae la j-ésima fila de un BlockM en forma de BlockV; o crea un
BlockM cuyas filas corresponden a las filas indicadas en una tupla o
lista de índices (los índices comienzan por el número 1)

Parámetros:
    j (int, list, tuple, slice): Índice (o lista de índices) del 
          elementos (o elementos) a seleccionar

Resultado:
          ?: Si j es int, devuelve la j-ésima fila del BlockM.
    Sistema: Si j es list, tuple o slice devuelve el BlockM cuyas
          filas son las filas indicadas en la lista, tupla o slice de
          índices.

Ejemplos:
>>> # Extrae la j-ésima fila del BlockM 
>>> 1 | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]])

BlockV(['Hola', 2, 3])
>>> # Sistema formado por los elementos indicados en la lista (o tupla)
>>> [2,1] | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]])
>>> (2,1) | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]])

BlockM([BlockV([1, 'Hola']), Vector([2, 2]), Vector([5, 3])])

>>> # Sistema formado por los elementos indicados en el slice
>>> slice(1,3,2) | BlockM([['Hola', 2, 3], [1, 2, 5], [1, 2, 7]]

BlockM([BlockV(['Hola', 1]), Vector([2, 2]), Vector([3, 7])])

"""
#+END_SRC

#+name: Operador selector por la izquierda para la clase BlockM
#+BEGIN_SRC python :noweb no-export

def __ror__(self,i):
    <<Texto de ayuda para el operador selector por la izquierda para la clase BlockM>>
    if isinstance(i,int):
        return  BlockV( (~self)|i , rpr='fila' )

    elif isinstance(i, (list,tuple,slice)):        
        return ~BlockM( (~self)|i ) 
        
#+END_SRC

*** Otros métodos de la clase ~BlockM~
**** Extiende una ~BlockM~ a lo largo de la diagonal con una lista de ~BlockMs~

#+name: Extiende una BlockM a lo largo de la diagonal con una lista de BlockMs
#+BEGIN_SRC python
   
def extDiag(self, lista, c=False):
    "Extiende una BlockM a lo largo de la diagonal con una lista de BlockMs"
    lista = CreaLista(lista)
    if not all(isinstance(elemento, BlockM) for elemento in lista): 
        return ValueError('No es una lista de BlockMs')
    Ext_dos = lambda x, y: x.apila(M0(y.m,x.n),c).concatena(M0(x.m,y.n).apila(y,c),c)
    ExtDiag = lambda x: x[0] if len(x)==1 else Ext_dos( ExtDiag(x[0:-1]), x[-1] )
    return ExtDiag([self]+lista)

#+END_SRC

**** Vectoriza un ~BlockM~ apilando sus elementos para formar un ~BlockV~
#+name: Vectoriza un BlockM apilando sus elementos para formar un BlockV
#+BEGIN_SRC python
   
def vec(self):
    "Vectoriza un BlockM apilando sus elementos para formar un BlockV"
    return BlockV(Sistema([]).junta(self))

#+END_SRC


# def ExtiendeDiag(self, lista):
#     if not all(isinstance(elemento, BlockM) for elemento in lista): 
#         return ValueError('No es una lista de BlockMs')
#     Ext_dos = lambda x, y: BlockM([[x,M0(x.m,y.n)],[M0(y.m,x.n),y] ])
#     ExtDiag = lambda x: x[0] if len(x)==1 else Ext_dos( ExtDiag(x[0:-1]), x[-1] )
#     return ExtDiag([self]+lista)

*** Transformaciones elementales de las filas de un ~BlockM~

**** Texto de ayuda

#+name: Texto de ayuda de las transformaciones elementales de un BlockM
#+BEGIN_SRC python
"""Transforma las filas de un BlockM

Atributos:
    operaciones (T): transformaciones a aplicar sobre las filas
                     de un BlockM A
Ejemplos:
>>>  T({1,3})   & A               # Intercambia las filas 1 y 3
>>>  T((5,1))   & A               # Multiplica por 5 la fila 1
>>>  T((5,2,1)) & A               # Suma 5 veces la fila 2 a la fila 1
>>>  T([(5,2,1),(5,1),{1,3}]) & A # Aplica la secuencia de transformac.
            # sobre las filas de A y en el orden inverso al de la lista

"""
#+END_SRC

**** Implementación de las transformaciones elementales de las filas

Para implementar las transformaciones elementales de las filas usamos
el truco de aplicar las operaciones sobre las columnas de la
transpuesta y de nuevo transponer el resultado: =~(~self & t)=.  Pero
hay que recordar que las transformaciones más próximas a la matriz se
ejecutan antes y que
\begin{math}
  \;\SITEF{1}{k}{\Mat{A}}=
  \TransP*{\Transp*{\SITEF{1}{k}{\Mat{A}}}}=
  \TransP*{\TrC[\Transp*{\SOEg[1][k]}]{\MatTpE*{A}}}=
  \TransP*{\TrC[\SOEg[k][1]]{\MatTpE*{A}}}.
\end{math}

#+name: Transformaciones elementales de las filas de un BlockM
#+BEGIN_SRC python :noweb no-export

def __rand__(self, operaciones):
    <<Texto de ayuda de las transformaciones elementales de un BlockM>>
    for item in reversed(operaciones.abreviaturas):
        if isinstance(item, (set, tuple) ):
            self.lista = (~(~self & T(item))).lista.copy()
    
        elif isinstance(item, list):
            for k in item:          
                ~T(k) & self
    
    return self 

#+END_SRC


# *Al actuar sobre =self.lista=, las transformaciones modifican el =BlockM= sobre el que actúan.*

*** Representación de la clase BlockM

#+name: Método de representación repr de la subclase BlockM
#+BEGIN_SRC python

def __repr__(self):
    """ Muestra un BlockM en su representación Python repr """
    return 'BlockM(' + repr(self.lista) + ')'
                           
#+END_SRC


#+name: Métodos de representación str y LaTeX de las subclases Matrix y BlockM
#+BEGIN_SRC python

def __str__(self):
    """ Muestra un BlockM en su representación Python str """
    ln  = [len(n) for n in particion(self.posicionDivisiones,self.n)]
    car = max([len(str(e)) for c in self for e in c])

    def escribeFila(f,d=0):
        parte = lambda f,d=0: str(' '.join([str(e).rjust(d) for e in f])) 
        s = '|'+'|'.join([parte([e for e in c],d) for c in [p|f for p in particion(self.posicionDivisiones, self.n)] ])+'|'
        return s
    
    num_guiones = len(escribeFila(1|self, car))
    s = ('\n'+ '-'*(num_guiones) + '\n').join(['\n'.join([escribeFila(f,car) for f in ~s]) \
                                               for s in [i|self for i in particion(self.corteElementos, self.m)]])
    return s

def latex(self):
    """ Construye el comando LaTeX para representar una BlockM """
    ln = [len(n) for n in particion(self.posicionDivisiones, self.n)]                                                           
    return \
        '\\left[ \\begin{array}{' + '|'.join([n*'c' for n in ln])  + '}' + \
        '\\\\ \\hline '.join(['\\\\'.join(['&'.join([latex(e) for e in f.lista]) \
                                           for f in (~M).lista]) \
           for M in [ i|self for i in particion(self.corteElementos,self.m)]]) + \
         '\\\\ \\end{array} \\right]'
        
#+END_SRC

***** Método para definir por puntos de corte en los elementos un BlockM (sus ``filas'')

Para separar visualmente distintas partes de los ~BlockV~ (las
columnas) de un ~BlockM~ es necesario indicar los índices de los
puntos de corte de sus elementos (tras los que se mostrará una línea
horizontal). Para especificar dichos índices se llama al método
=cfil()= (pues lo usaremos para visualmente /cortar por filas/ una
matriz).

#+name: Método para definir por puntos de corte en los elementos un BlockM
#+BEGIN_SRC python

def cfil(self, conjuntoIndices={}):
    """Modifica el atributo .corteElementos para insertar lineas
    horizontales entre las filas del BlockM

    """
    self.corteElementos = set(conjuntoIndices) if conjuntoIndices else {0}
    return self

#+END_SRC


\clearpage

*** La clase ~BlockM~ completa

#+name: Definición de la subclase BlockM
#+BEGIN_SRC python :noweb no-export
class BlockM(Sistema):
    <<Texto de ayuda de la clase BlockM>>
    <<Inicialización de la subclase BlockM>>
    <<Operador transposición>>
    <<Comprobación de que las filas o columnas son de composición homogenea>>
    <<Apila una lista de Sistemas con el mismo número de elementos un BlockM>>
    <<Operador selector por la izquierda para la clase BlockM>>
    <<Vectoriza un BlockM apilando sus elementos para formar un BlockV>>
    <<Transformaciones elementales de las filas de un BlockM>>
    <<Método para definir por puntos de corte en los elementos un BlockM>>
    <<Extiende una BlockM a lo largo de la diagonal con una lista de BlockMs>>
    <<Método de representación repr de la subclase BlockM>>
    <<Métodos de representación str y LaTeX de las subclases Matrix y BlockM>>
#+END_SRC


** La subclase ~Matrix~   

*** Implementación de las matrices en la subclase ~Matrix~

**** Texto de ayuda

#+name: Texto de ayuda de la clase Matrix
#+BEGIN_SRC python
"""Matrix un Sistema de Vectores con el mismo número de componentes.

Una Matrix se puede instanciar con:

 1. una lista, tupla o Sistema de Vectores con el mismo número de
    componentes o longitud (serán las columnas).
 2. una lista, tupla o Sistema de listas, tuplas o Sistemas de núemros
    con la misma longitud (serán las filas de la matriz).

Parámetros:
    arg (list, tuple, Sistema): Lista, tupla o Sistema de Vectores con
        mismo núm. de componentes (sus columnas); o de listas, tuplas
        o Sistemas de números de misma longitud (sus filas).

Atributos heredados de la clase Sistema:
    lista              (list): list con los elementos.
    n                  (int) : número de elementos de la lista.
    posicionDivisiones (set) : Conjunto de índices donde pintar
                                separaciones visuales

Atributos heredados de la subclase BlockM:
    m              (int) : número de filas
    corteElementos (set) : Conjunto de índices donde pintar
                            separaciones visuales entre filas

Ejemplos:
>>> # Crear una Matrix a partir de una lista de Vectores:
>>> a = Vector( [1,2] ); b = Vector( [1,0] ); c = Vector( [9,2] )
>>> Matrix( [a,b,c] )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crear una Matrix a partir de una lista de listas de números
>>> A = Matrix( [ [1,1,9], [2,0,2] ] )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crea una Matrix a partir de otra Matrix
>>> Matrix( A )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])

"""
#+END_SRC
   
**** Método de inicialización:

#+name: Inicialización de la subclase Matrix
#+BEGIN_SRC python

def __init__(self, data):
    """Inicializa una Matrix con una

    1) lista, tupla o Sistema de Vectores con el mismo número de
    elementos,
    
    2) tupla, lista o Sistema de tuplas, listas o Sistemas de números
    con el mismo número de elementos,
    
    3) con otra Matrix.

    """

    super().__init__(data)
    
    lista = Sistema(data).lista

    if all([(isinstance(elemento, Vector) and len(elemento)==len(lista[0])) for elemento in lista]):
        self.lista   = lista.copy()

    elif Sistema(lista).es_de_composicion_y_longitud_uniforme() and es_ristra(lista[0]) and es_numero(lista[0][0]):
        self.lista = Matrix([ Vector([elemento[i] for elemento in lista]) for i in range(len(lista[0])) ]).lista

    elif isinstance(data,Matrix):
        self.lista   = data.lista.copy()

    else: 
        raise ValueError("""El argumento debe ser una lista de Vectores o una lista de listas o
        tuplas con el mismo número de elementos!""")
    
    super().__init__(data)

    for v in self.lista:
        v.rpr='columna'
        
#+END_SRC

*** Métodos específicos de la subclase ~Matrix~
**** Disposición de los elementos de una ~Matrix~

#+name: Información sobre la disposición de los elementos de una Matrix
#+BEGIN_SRC python

def es_cuadrada(self):
    """Indica si es cierto que la Matrix es cuadrada"""
    return self.m==self.n
    
def es_simetrica(self):
    """Indica si es cierto que la Matrix es simétrica"""
    return self == ~self
    
def es_triangularSup(self):
    """Indica si es cierto que la Matrix es triangular superior"""
    return not any(sum([[i|self|j for i in range(j+1,self.m+1)]      \
                                  for j in range(1  ,self.n+1)], []))
    
def es_triangularInf(self):
    """Indica si es cierto que la Matrix es triangular inferior"""
    return (~self).es_triangularSup()
    
def es_triangular(self):
    """Indica si es cierto que la Matrix es triangular inferior"""
    return self.es_triangularSup() | self.es_triangularInf()
    
def es_diagonal(self):
    """Indica si es cierto que la Matrix es diagonal"""
    return self.es_triangularSup() & self.es_triangularInf()

#+END_SRC

**** Creación de un ~Vector~ a partir de la diagonal de una ~Matrix~

#+name: Creación de un Vector a partir de la diagonal de una Matrix
#+BEGIN_SRC python

def diag(self):
    """Crea un Vector a partir de la diagonal de la Matriz"""
    return Vector([ (j|self|j) for j in range(1,min(self.m,self.n)+1)])

#+END_SRC

**** Normalizado de las columnas (o filas) de una matriz

#+name: Normalizado de las columnas o filas de una matriz
#+BEGIN_SRC python

def normalizada(self, opcion='Columnas'):
    if opcion == 'Columnas':
        if any( vector.es_nulo() for vector in self):
            raise ValueError('algún vector es nulo')
        return Matrix([ vector.normalizado() for vector in self])
    else:
        return ~(~self.normalizada())
        
#+END_SRC

**** Potencias de una ~Matrix~ cuadrada
Ahora podemos calcular la \texttt{n}-ésima potencia de una =Matrix=.
Cuando =n= es un entero positivo; basta multiplicar la =Matrix=
por si misma =n= veces.

Si =n= es un entero negativo, entonces necesitamos calcular la inversa
de la \texttt{n}-ésima potencia; para ello usará el método de
eliminación Gaussiano que se describirá en el
Capítulo~\ref{part:Algoritmos}.

#+name: Potencia de una Matrix
#+BEGIN_SRC python

def __pow__(self,n):
    """Calcula la n-ésima potencia de una Matrix"""
    if not isinstance(n,int): raise ValueError('La potencia no es un entero')
    if not self.es_cuadrada:  raise ValueError('Matrix no es cuadrada')

    M = self if n else I(self.n)
    for i in range(1,abs(n)):
    	M = M * self

    return M.inversa() if n < 0 else M

#+END_SRC

**** Determinante mediante la expansión de Laplace

#+name: Determinante mediante la expansión de Laplace
#+BEGIN_SRC python

def det(self, sust=[]):
    """Calculo del determinate mediante la expansión de Laplace"""
    if not self.es_cuadrada(): raise ValueError('Matrix no cuadrada')
                                                               
    def cof(self,f,c):
        """Cofactor de la fila f y columna c"""
        excl = lambda k: tuple(i for i in range(1,self.m+1) if i!=k)
        return (-1)**(f+c)*(excl(f)|self|excl(c)).det()
                                                               
    if self.m == 1:
        return 1|self|1

    A = Matrix(self.subs(sust))
    # expansión por la 1ª columna 
    return sympy.simplify(sum([((f|A|1)*cof(A,f,1)).subs(sust) for f in range(1,A.m+1)])) 
                                                                                                                              
#+END_SRC

**** Método de Gram-Schmidt

#+name: Método Gram-Schmidt para ortogonalizar un sistema de Vectores de Rn
#+BEGIN_SRC python

def GS(self):
    """Devuelve una Matrix equivalente cuyas columnas son ortogonales

    Emplea el método de Gram-Schmidt"""
    A = Matrix(self)
    for n in range(2,A.n+1):
        A & T([ (-fracc((A|n)*(A|j),(A|j)*(A|j)), j, n) \
                for j in range(1,n) if (A|j).no_es_nulo() ])
    return A

#+END_SRC

**** Otros métodos específicos de las matrices cuadradas que usan eliminación
***** Rango de una Matrix

#+name: Rango de una Matrix
#+BEGIN_SRC python

def rg(self):
    """Rango de una Matrix"""
    return [v.no_es_nulo() for v in self.K()].count(True)

#+END_SRC

***** Comprobación de que una Matrix es singular o de que es invertible

#+name: Comprobación de que una Matrix es singular o de que es invertible
#+BEGIN_SRC python

def es_singular(self):
    if not self.es_cuadrada():
        raise ValueError('La matriz no es cuadrada')
    return self.rg()<self.n
  
def es_invertible(self):
    if not self.es_cuadrada():
        raise ValueError('La matriz no es cuadrada')
    return self.rg()==self.n
  
#+END_SRC

***** Cálculo de la matriz inversa

En la representación se muestra primero la reducción adelante y atrás,
luego se escalona y finalmente se normaliza.

#+name: Cálculo de la matriz inversa
#+BEGIN_SRC python

def inversa(self, rep=0):                                                               
    """Inversa de Matrix"""
    if not self.es_cuadrada():
        raise ValueError('Matrix no cuadrada')
    
    pasos = self.elim(2).elim(20).elim(10).pasos
    TrF = pasos[0]
    TrC = pasos[1]
    tex   = rprElim(self.apila(I(self.n),1),pasos)
    
    if rep:
        display(Math(tex))

    if self.es_singular():
        raise ValueError('Matrix es singular')

    InvMat = I(self.n) & T(TrC)
    InvMat.pasos = pasos
    InvMat.TrF   = TrF
    InvMat.TrC   = TrC
    InvMat.tex   = tex
    return InvMat

#+END_SRC

***** Cálculo del determinante

#+name: Cálculo del determinante por eliminación
#+BEGIN_SRC python

def determinante(self, rep = False, sust = []):
    """Calculo del determinate mediante eliminación"""
    if not self.es_cuadrada(): raise ValueError('Matrix no cuadrada')
    
    return Determinante(self.subs(sust),rep).valor
                       
#+END_SRC

***** Diagonalización por Semejanza

#+name: Diagonalizando por Semejanza en una matriz por bloques triangulares
#+BEGIN_SRC python :noweb no-export
def diagonalizaS(self, espectro, rep=False, sust=[]):
    <<Texto de ayuda para la clase DiagonalizaS>>
    D            = Matrix(self.subs(sust))
    <<Comprobaciones previas a la diagonalización>>
    espectro     = [sympy.S(l).subs(sust) for l in espectro]    
    S            = I(D.n)
    Tex          = latex( D.apila(S,1) )
    pasosPrevios = [[],[]]
    selecc       = list(range(1, D.n+1))

    for landa in espectro:
        m = selecc.pop()
        <<Restamos lambda*I>>
        # eliminamos elementos superiores de la columna con elim de izda a dcha
        TrCol = filtradopasos((slice(None,m)|D|slice(None,m)).elim(20).pasos[1])
        <<Aplicación de las transformaciones y sus inversas espejo>>
        
        if m < D.n: # eliminamos elementos inferiores de la columna con los pivotes de la diagonal
            for i,_ in enumerate(slice(m+1,None)|D|m, m+1):
                TrCol = filtradopasos([ T([(-fracc(i|D|m, i|D|i), i, m)]) ]) if i|D|i else [T([])]
                <<Aplicación de las transformaciones y sus inversas espejo>>     
        <<Sumamos lambda*I>>
                    
    if rep: display(Math(Tex))
    D.espectro = espectro[::-1]
    D.tex = Tex
    D.S   = S
    D.TrC = pasosPrevios[1]
    D.TrF = [op.Tinversa().espejo() for op in D.TrC[::-1]]
    D.pasos = [D.TrF, D.TrC]
    return D
    
#+END_SRC

#+name: Texto de ayuda para la clase DiagonalizaS
#+BEGIN_SRC python
"""Diagonaliza por bloques triangulares una Matrix cuadrada

Encuentra una matriz diagonal semejante mediante trasformaciones de
sus columnas y las correspondientes transformaciones inversas espejo
de las filas. Requiere una lista de autovalores (espectro), que deben
aparecer en dicha lista tantas veces como sus respectivas
multiplicidades algebraicas. Los autovalores aparecen en la diagonal
principal de la matriz diagonal. El atributo S de dicha matriz
diagonal es una matriz cuyas columnas son autovectores de los
correspondientes autovalores.  """
#+END_SRC


#+name: Comprobaciones previas a la diagonalización
#+BEGIN_SRC python

def no_son_autovalores(A, L):
    no_son=[l for i,l in enumerate(L) if (D-l*I(D.n)).es_invertible()]
    if no_son:
        print('los valores de la siguiente lista no son autovalores de la matriz:', no_son)
        return True
    else:
        False

def espectro_correcto(A, L):
    x = sympy.symbols('x')    
    monomio = lambda l,x: l-x
    p = (A-x*I(A.n)).det()
    for l in L:
        p, r = sympy.div(p, monomio(l,x), domain ='QQ')    
    return False if p!=1 or r!=0 else True

if not D.es_cuadrada:
    raise ValueError('Matrix no es cuadrada')

if not isinstance(espectro, list):
    raise ValueError('espectro no es una lista')

if no_son_autovalores(D, espectro):
    raise ValueError('quite de la lista los valores que no son autovalores')
    
if not len(espectro)==D.n:
    raise ValueError('el espectro propocionado tiene un número inadecuado de autovalores')

if not espectro_correcto(D, espectro):
    raise ValueError('introduzca una lista correcta de autovalores')

#+END_SRC


#+name: Restamos lambda*I
#+BEGIN_SRC python

D = (D-(landa*I(D.n))).subs(sust)
Tex += r'\xrightarrow[\boxed{' + latex(landa) + r'\mathbf{I}}]{(-)}' + latex((D.apila(S,1)).subs(sust))

#+END_SRC

#+name: Sumamos lambda*I
#+BEGIN_SRC python

D = (D+(landa*I(D.n))).subs(sust)
Tex += r'\xrightarrow[\boxed{' + latex(landa) + r'\mathbf{I}}]{(+)}' + latex((D.apila(S,1)).subs(sust))

#+END_SRC


#+name: Aplicación de las transformaciones y sus inversas espejo
#+BEGIN_SRC python

if T(TrCol):
    Tex             = rprElim( D.apila(S,1),  [[], TrCol], Tex, sust) if TrCol else Tex
    D               = (D & T(TrCol)).subs(sust)
    S               = (S & T(TrCol)).subs(sust)
    pasosPrevios[1] = pasosPrevios[1] + TrCol
    
    TrFilas         = [ T( [op.Tinversa().espejo() for op in TrCol[::-1]] ) ]
    
    Tex             = rprElim( D.apila(S,1), [TrFilas, []], Tex, sust) if TrCol else Tex
    D               = (T(TrFilas) & D).subs(sust)
    pasosPrevios[0] = TrFilas + pasosPrevios[0]

#+END_SRC

***** Diagonalización por Congruencia

#+name: Texto de ayuda para la clase DiagonalizaC
#+BEGIN_SRC python
"""Diagonaliza por congruencia una Matrix simétrica (evitando dividir)

Encuentra una matriz diagonal por conruencia empleando una matriz B
invertible (y entera si es posible) por la derecha y su transpuesta
por la izquierda. No emplea los autovalores. En general los elementos
en la diagonal principal no son autovalores, pero hay tantos elementos
positivos en la diagonal como autovalores positivos, tantos negativos
como autovalores negativos, y tantos ceros como auntovalores nulos.

"""
#+END_SRC


#+name: Diagonalizando por Congruencia una matriz simétrica
#+BEGIN_SRC python :noweb no-export
def diagonalizaC(self, rep=False, sust=[]):
    <<Texto de ayuda para la clase DiagonalizaC>>
    <<Definición del método auxiliar BuscaPrimerNoNuloEnLaDiagonal>>
    
    D            = Matrix(self.subs(sust))
    
    if not D.es_simetrica():
        raise ValueError('La matriz no es simétrica')
     
    pasosPrevios = [ [], [] ]
    
    for i in range(1, D.n):
        p = BuscaPrimerNoNuloEnLaDiagonal(D, i)
        j = [k for k,col in enumerate(D|slice(i,None),i) if (i|col and not k|col)]
        
        if not (i|D|i):
            if p:
                Tr = T( {i, p} )
                p = i
                <<Aplicación de las transformaciones a las columnas y a las filas>>
            elif j:
                Tr = T( (1, j[0], i) )
                p = i
                <<Aplicación de las transformaciones a las columnas y a las filas>>
        if p:
            Tr = T(((i,)|D).elim(1).pasos[1]) 
            <<Aplicación de las transformaciones a las columnas y a las filas>>
           
    D.pasos     = pasosPrevios
    D.tex       = rprElimCF(Matrix(self.subs(sust)), D.pasos, [], sust) 
    D.TrF       = filtradopasos(T(D.pasos[0]))
    D.TrC       = filtradopasos(T(D.pasos[1]))
    D.B         = I(self.n) & D.TrC
    
    if rep: 
        display(Math(D.tex))

    return D   
    
#+END_SRC


#+name: Definición del método auxiliar BuscaPrimerNoNuloEnLaDiagonal
#+BEGIN_SRC python

def BuscaPrimerNoNuloEnLaDiagonal(self, i=1):
    """Indica el índice de la primera componente no nula de a diagonal
    desde de la posición i en adelante. Si son todas nulas devuelve 0

    """
    
    d = (slice(i,None)|self|slice(i,None)).diag().sis()
    return next((pos for pos, x in enumerate(d) if x), -i) + i

#+END_SRC


#+name: Aplicación de las transformaciones a las columnas y a las filas
#+BEGIN_SRC python

pasos = [ filtradopasos([~Tr]), filtradopasos([Tr]) ]
pasosPrevios[0] = pasos[0] + pasosPrevios[0]
pasosPrevios[1] = pasosPrevios[1] + pasos[1]
D = (T(pasos[0]) & D & T(pasos[1])).subs(sust)

#+END_SRC


**** Diagonalización ortogonal de una matriz simétrica

#+name: Diagonalizando Ortogonalmente una matriz simétrica
#+BEGIN_SRC python :noweb no-export

def diagonalizaO(self, espectro, sust=[]):
    <<Texto de ayuda para la clase DiagonalizaO>>
    D            = Matrix(self.subs(sust))
    
    if not D.es_simetrica():
        raise ValueError('La matriz no es simétrica')
    
    <<Comprobaciones previas a la diagonalización>>
    <<Método auxiliar para creación de una base ortonormal donde \Vect{q} es el último vector>>
    
    espectro     = [sympy.S(l).subs(sust) for l in espectro]    
    S            = I(D.n)
    Tex          = latex( D.apila(S,1) )
    pasosPrevios = [[],[]]
    selecc       = list(range(1,D.n+1))

    for l in espectro:
        D       = (D - l*I(D.n)).subs(sust)
        k       = len(selecc)
        nmenosk = (D.n)-k
        m       = selecc.pop()
        TrCol   = filtradopasos((slice(None,m)|D|slice(None,m)).elim(20, False, sust).pasos[1])
        D       = (D + l*I(D.n)).subs(sust)
        
        
        q = ( (I(k) & T(TrCol)).subs(sust) )|0
        q = (sympy.sqrt(q*q)) * q
        
        Q = BaseOrtNor(q).concatena(M0(k,nmenosk)).apila( \
                M0(nmenosk,k).concatena(I(nmenosk)))  if nmenosk else BaseOrtNor(q)
            
        S = (S*Q).subs(sust)
        D = (~Q*D*Q).subs(sust)

    D.Q = S
    D.espectro = espectro[::-1]
    return D

#+END_SRC


#+name: Texto de ayuda para la clase DiagonalizaO
#+BEGIN_SRC python
"""Diagonaliza ortogonalmente una Matrix simétrica

Encuentra una matriz diagonal por semejanza empleando una matriz
ortogonal Q a la derecha y su inversa (transpuesta) por la izquierda.
Requiere una lista de autovalores (espectro), que deben aparecer
tantas veces como sus respectivas multiplicidades algebraicas. Los
autovalores aparecen en la diagonal principal de la matriz
diagonal. El atributo Q de la matriz diagonal es la matriz ortogonal
cuyas columnas son autovectores de los correspondientes autovalores.

"""
#+END_SRC

#+name: Método auxiliar para creación de una base ortonormal donde \Vect{q} es el último vector
#+BEGIN_SRC python

def BaseOrtNor(q):
    "Crea una base ortonormal cuyo último vector es 'q'"
    if not isinstance(q,Vector): raise ValueError('El argumento debe ser un Vector')
    M = Matrix([q]).concatena(I(q.n)).GS()
    l = [ j for j, v in enumerate(M, 1) if v.no_es_nulo() ]
    l = l[1:len(l)]+[l[0]]
    return (M|l).normalizada()

#+END_SRC

*** Representación de la clase ~Matrix~

#+name: Método de representación repr de la subclase Matrix
#+BEGIN_SRC python

def __repr__(self):
    """ Muestra una Matrix en su representación Python repr """
    return 'Matrix(' + repr(self.lista) + ')'
                           
#+END_SRC

*** La clase ~Matrix~ completa

#+name: Definición de la subclase Matrix
#+BEGIN_SRC python :noweb no-export
class Matrix(BlockM):
    <<Texto de ayuda de la clase Matrix>>
    <<Inicialización de la subclase Matrix>>
    <<Información sobre la disposición de los elementos de una Matrix>>
    <<Creación de un Vector a partir de la diagonal de una Matrix>>
    <<Normalizado de las columnas o filas de una matriz>>
    <<Potencia de una Matrix>>
    <<Determinante mediante la expansión de Laplace>>
    <<Método Gram-Schmidt para ortogonalizar un sistema de Vectores de Rn>>
    <<Rango de una Matrix>>
    <<Comprobación de que una Matrix es singular o de que es invertible>>
    <<Cálculo de la matriz inversa>>
    <<Cálculo del determinante por eliminación>>
    <<Diagonalizando por Semejanza en una matriz por bloques triangulares>>
    <<Diagonalizando por Congruencia una matriz simétrica>>
    <<Diagonalizando Ortogonalmente una matriz simétrica>>
    <<Método de representación repr de la subclase Matrix>>
#+END_SRC


** Las subclases ~M0~, ~M1~ e ~I~

#+name: Definición de las subclases M0, M1 e I
#+BEGIN_SRC python

class M0(Matrix):
    def __init__(self, m, n=None):
        """ Inicializa una matriz nula de orden m por n """
        n = m if n is None else n

        super().__init__( [V0(m)]*n )
        self.__class__ = Matrix

class M1(Matrix):
    def __init__(self, m, n=None):
        """ Inicializa una matriz nula de orden m por n """
        n = m if n is None else n

        super().__init__( [V1(m)]*n )
        self.__class__ = Matrix

class I(Matrix):
    def __init__(self, n):
        """ Inicializa la matriz identidad de tamaño n """
        super().__init__([[(i==j)*1 for i in range(n)] for j in range(n)])
        self.__class__ = Matrix

#+END_SRC

#+RESULTS: Definición de las subclases M0, M1 e I


** Las subclases ~Elim~, ~ElimG~, ~ElimGJ~,  ~ElimGF~, ~ElimGJF~, ~InvMat~, ~InvMatF~ e ~InvMatFC~

Por comodidad y compatibilidad con la versión anterior de NAcAL
creamos las siguientes subclases de Sistema que resultan tras aplicar
ciertos pasos de eliminación.

*** Subclases de ~Sistema~: ~Elim~, ~ElimG~, ~ElimGJ~,  ~ElimGF~ y  ~ElimGJF~
       :PROPERTIES:
       :header-args+: :noweb-ref Definición de las subclases ElimX
       :END:

Son una forma alternativa de llamar a los métodos ~.K()~, ~.L()~,
~.R()~, ~.U()~ y ~.UR()~. Los dos últimos, ~.U()~ y ~.UR()~ (es decir,
~ElimGF~ y ~ElimGJF~) solo tienen sentido si el Sistema es un arreglo
rectangular y cada uno de sus componentes es de composición uniforme,
es decir, es necesario que las operaciones de eliminación estén
definidas entre los elementos de cada componente del sistema. Es el
método correspondiente a la eliminación por filas en matrices.
#+BEGIN_SRC python

class Elim(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve una forma pre-escalonada de un sistema

           operando con sus elementos (y evitando operar con
           fracciones).  Si rep es no nulo, se muestran en Jupyter los
           pasos dados

        """
        self.__dict__.update(sistema.K(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

#+END_SRC

#+BEGIN_SRC python

class ElimG(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve una forma escalonada de un sistema

           operando con sus elementos (y evitando operar con
           fracciones).  Si rep es no nulo, se muestran en Jupyter los
           pasos dados

        """
        self.__dict__.update(sistema.L(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

#+END_SRC

#+BEGIN_SRC python

class ElimGJ(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada reducida de un sistema

           operando con sus elementos (y evitando operar con
           fracciones).  Si rep es no nulo, se muestran en Jupyter los
           pasos dados

        """
        self.__dict__.update(sistema.R(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

#+END_SRC

#+BEGIN_SRC python

class ElimGF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada por filas (si es posible)

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """        
        self.__dict__.update(sistema.U(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

#+END_SRC

#+BEGIN_SRC python

class ElimGJF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la forma escalonada reducida por filas (si es posible)

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """        
        self.__dict__.update(sistema.UR(rep, sust, repsust).__dict__)
        self.__class__ = type(sistema)

#+END_SRC

*** Subclases de ~Matrix~: ~InvMat~, ~InvMatF~ e ~InvMatFC~
       :PROPERTIES:
       :header-args+: :noweb-ref Definición de las subclases InvMatX
       :END:

Son una forma alternativa de llamar al método ~.inversa()~,
#+BEGIN_SRC python :noweb no-export

class InvMat(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la matriz inversa y los pasos dados sobre las columnas

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
        A = sistema.subs(sust).inversa()
        A.tex, A.pasos = texYpasos(sistema.apila(I(sistema.n),1), A.pasos, rep, sust, repsust)
        A.TrF = A.pasos[0]
        A.TrC = A.pasos[1]
        self.__dict__.update(A.__dict__)
        self.__class__ = type(sistema)

#+END_SRC

#+BEGIN_SRC python :noweb no-export

class InvMatF(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la matriz inversa y los pasos dados sobre las filas

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>

        if not sistema.es_cuadrada():
            raise ValueError('Matrix no cuadrada')
    
        pasos = sistema.elim(26).elim(26).elim(14).pasos
        A = T(pasos[0]) & I(sistema.n)
        A.tex, A.pasos = texYpasos(sistema.concatena(I(sistema.n),1), pasos, rep, sust, repsust)
        A.TrF = A.pasos[0]
        A.TrC = A.pasos[1]
        self.__dict__.update(A.__dict__)
        self.__class__ = type(sistema)

#+END_SRC

#+BEGIN_SRC python :noweb no-export

class InvMatFC(Sistema):
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Devuelve la matriz inversa y los pasos dados sobre las filas y columnas

           y evitando operar con fracciones.  Si rep es no nulo, se
           muestran en Jupyter los pasos dados

        """
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>

        if not sistema.es_cuadrada():
            raise ValueError('Matrix no cuadrada')
    
        pasos = sistema.elim(24).elim(10).pasos
        A = sistema.copy()
        nan = sympy.symbols('\ ')
        dummyMatrix = M1(A.n)*nan
        A.tex, A.pasos = texYpasos(A.concatena(I(A.n),1).apila(I(A.n).concatena(dummyMatrix,1),1), pasos, rep, sust, repsust)
        A.TrF = A.pasos[0]
        A.TrC = A.pasos[1]
        A.F   = T(A.TrF) & I(A.n)
        A.C   = I(A.n) & T(A.TrC)
        A.lista = (A.C*A.F).lista
        self.__dict__.update(A.__dict__)
        self.__class__ = type(sistema)

#+END_SRC
# A.C * A.F es la inversa de A


* La clase ~T~ (transformación elemental)
  
** La clase ~T~

*** Introducción

Vamos a implementar las transformaciones de un sistema $\SV{A}$
mediante secuencias de /transformaciones elementales de Tipo I y II/ e
/intercambios/. Para que funcionen las /transformaciones elementales/
debe estar definida tanto la suma de los elementos del sistema como el
producto de los elementos por un escalar:

- Tipo I: :: $~\TESC{\lambda}{i}{j}{\SV{A}}$ suma $\lambda$ veces el
  elemento $i$ al elemento $j$ ($i\ne j$);
- Tipo II: :: $~\TEPC{\lambda}{i}{\SV{A}}$ multiplica el elemento $i$ por
  $\lambda\ne0$.
- Intercambio: :: $~\TEIC{i}{j}{\SV{A}}$ intercambia los elementos $i$ y
  $j$.

***** Comentario sobre la notación. 

Cualquier trasformación elemental de un sistema se puede lograr con el
producto del sistema por una matriz elemental, y /la notación empleada
busca parecerse a la notación del producto matricial/ (por ello, para
ilustrar lo que sigue usaremos como ejemplo de sistema una matriz
\Mat{A}):
\begin{quotation}
  Al poner la \emph{abreviatura} ``$\TrEl$'' de la
  transformación elemental a derecha es como si multiplicáramos la
  matriz \Matdim{A}{m}{n} por la derecha por la correspondiente matriz
  elemental
  \begin{displaymath}
    \TEC{\Mat{A}}=\Mat{A}\TECpE{\Mat{I}}\quad \text{donde la matriz \Mat{I} es de orden $n$}.
  \end{displaymath}

  De manera similar, al poner la \emph{abreviatura} ``$\TrEl$''
  de la transformación elemental a izquierda, es como si
  multiplicáramos la matriz \Matdim{A}{m}{n} por la izquierda por la
  correspondiente matriz elemental
  \begin{displaymath}
    \TEF{\Mat{A}}=\TEFpE{\Mat{I}}\Mat{A}\quad \text{ donde la matriz \Mat{I} es de orden $m$}.
  \end{displaymath}
\end{quotation}
Con ello se gana, entre otras cosas, que la notación sea
asociativa. Pero si se puede hacer con matrices elementales\dots ¿qué
ventaja tiene introducir en el discurso las transformaciones
elementales en lugar de utilizar simplemente matrices elementales?

Fíjese que una matriz cuadrada es un objeto muy ``pesado''\dots una
matriz de orden $n$ posee $n^2$ coeficientes. Afortunadamente una
matriz elemental es casi una matriz identidad salvo por el cambio de
uno de sus elementos. Por tanto, para describir completamente una
matriz elemental es necesario indicar su orden $n$ y qué componente ha
cambiado.[fn:: Fíjese que la notación usada en el libro del curso de
Álgebra Lineal para las matrices elementales no las describe
completamente; se deja al lector la deducción de cuál es el orden de
la matriz elemental necesario para poder realizar el producto
$\Mat{A}\TECpE{\Mat{I}}$ o el producto $\TEFpE{\Mat{I}}\Mat{A}$.]  Por
este motivo...

|                                     <c>                                      |
| *La ventaja de las transformaciones elementales es que omiten el orden $n$.* |
|                                                                              |
pues solo necesitan indicar el índice de los elementos que intervienen
en la transformación.

***** Traducción de las transformaciones elementales a Python

Vamos a definir la siguiente traducción de esta notación a Python:

|                       <r> |                <r> | <l>                       | <l>                |
|                     Curso |             Python | Curso                     | Python             |
|---------------------------+--------------------+---------------------------+--------------------|
|                         / |                    | <                         |                    |
|    $\TEIF{i}{j}{\Mat{A}}$ |  ~T( {i,j } ) & A~ | $\TEIC{i}{j}{\Mat{A}}$    | ~A & T( {i,j} )~   |
|                           |                    |                           |                    |
|    $\TEPF{a}{j}{\Mat{A}}$ |   ~T( (a,j) ) & A~ | $\TEPC{a}{j}{\Mat{A}}$    | ~A & T( (a,j) )~   |
|                           |                    |                           |                    |
| $\TESF{a}{i}{j}{\Mat{A}}$ | ~T( (a,i,j) ) & A~ | $\TESC{a}{i}{j}{\Mat{A}}$ | ~A & T( (a,i,j) )~ |
|---------------------------+--------------------+---------------------------+--------------------|

El código Python de la columna izquierda, donde la transformación se
aplica por la izquierda, solo será aplicable a los =BlockM= (solo
ellos tienen ``filas''). El código Python de la columna derecha será
aplicable a los =Sistemas=, pues opera con son elementos.


Vemos que:
 1. Representar el intercambio con un conjunto, permite admitir la
    repetición del índice, pues $\{i,i\}=\{i\}$, denotando un caso
    especial en el que la matriz no cambia (esto simplificará el
    método de Gauss).
 2. Tanto para los pares =(a,i)= como para las ternas =(a,i,j)=:
    + La columna (fila) que cambia es la del índice que aparece en última posición.
    + El escalar de la primera posición multiplica a la columna
      (fila) correspondiente al índice que le sigue.

Empleando listas de abreviaturas extendemos la notación para expresar
secuencias de transformaciones elementales, es decir,
\begin{math}
  \TrEl_{1}\cdots\TrEl_{k}.
\end{math}
Así logramos la siguiente equivalencia entre expresiones
\begin{displaymath}
  \text{\tt{T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}}
  \quad = \quad
  \text{\tt{T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] )}}
\end{displaymath}
De esta manera
\begin{eqnarray*}
  \TrC{\Mat{A}}:\qquad &
  \Mat{A} \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
  \;=\; \Mat{A} \text{\tt{ \& T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] )}}
  \\\\
  \TrF{\Mat{A}}:\qquad &
  \text{\tt{ T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{) \& }} \Mat{A}
  \;=\; \text{\tt{ T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] ) \& }} \Mat{A}.
\end{eqnarray*}

Así, usando abreviaturas y si \Mat{A} es de orden $m\times n$, el primer caso es equivalente a escribir el producto de matrices
\begin{displaymath}
  \TrC{\Mat{A}}\;=\;\Mat{A}\TECpE*[1]{\Mat{I}}\TECpE*[2]{\Mat{I}}\cdots\TECpE*[k]{\Mat{I}}
  \qquad
  \text{donde \Mat{I} es de orden $n$};
\end{displaymath}
y el segundo caso es equivalente a escribir el producto de matrices
\begin{displaymath}
  \TrF{\Mat{A}}
  \;=\;
  \TEFpE*[1]{\Mat{I}}\TEFpE*[2]{\Mat{I}}\cdots\TEFpE*[k]{\Mat{I}}\Mat{A}
  \qquad
  \text{donde \Mat{I} es de orden $m$...}
\end{displaymath}
¡Pero gracias a las abreviaturas de las transformaciones elementales
no es necesario indicar el orden (el número de filas y columnas) de
las matrices elementales en ningún momento!

***** Necesidad de creación de una nueva clase

Python ejecuta las órdenes de izquierda a derecha. Fijándonos en la
expresión
\begin{displaymath}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
\end{displaymath}
podríamos pensar que podemos implementar la transformación elemental
como un método de la clase =Sistema=. Así, al definir el método
=__and__= por la derecha del =Sistema= podemos indicar que
\begin{math}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{)}}
\end{math}
es una nueva matriz con las columnas modificadas. Python no tiene
problema en ejecutar
\begin{math}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
\end{math}
pues ejecutar de izquierda a derecha, es lo mismo que ejecutar
\begin{math}
  \Bigg[\Big[\big[\Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{)}}\big] \text{\tt{\& T(}}\ t_2\ \text{\tt{)}} \Big] \text{\tt{\&}} \cdots \Bigg]\text{\tt{\& T(}}\ t_k  \text{\tt{)}}
\end{math}
donde la expresión dentro de cada corchete es una =Matrix=, por lo que
las operaciones están bien definidas. La dificultad aparece con
\begin{displaymath}
  \text{\tt{ T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{) \& }} \Mat{A}
\end{displaymath}
Lo primero que Python tratara de ejecutar es
\begin{math}
    \text{\tt{T(}}\ t_1\ \text{\tt{) \& T(}} \ t_2 \text{\tt{)}},
\end{math}
pero ni $\text{\tt{T(}}\ t_1 \text{\tt{)}}$ ni $\text{\tt{T(}}\ t_2
\text{\tt{)}}$ son matrices, por lo que esto no puede ser programado
como un método de la subclase =BlockM= (recuerde que al actuar por la
izquierda se opera con las filas, y solo los =BlockMs= tiene definidas
las filas).

Así pues, definiremos una nueva clase que almacene las /abreviaturas/
$t_i$ (``$\OEg[i]$'') de las operaciones elementales, de manera que
podamos definir
\begin{math}
  \text{\tt{T(}}\ t_i\ \text{\tt{) \& T(}} \ t_j \text{\tt{)}},
\end{math}
como un método que ``compone'' dos transformaciones elementales
(``$\OEg[i]\OEg[j]$'') para formar una secuencia de abreviaturas (que
en última instancia será una secuencia de operaciones a ejecutar sobre
un =Sistema=).

El nuevo objeto, ~T~ (``transformación elemental''), nos permitirá
encadenar transformaciones elementales (es decir, almacenar una lista
de abreviaturas). El siguiente código inicializa la clase. El atributo =t= almacenará la abreviatura (o lista de abreviaturas) dada al
instanciar ~T~ o bien creará la lista de abreviaturas a partir de
otra  ~T~ (o lista de objetos ~T~) empleada para instanciar.

*** Implementación de las transformaciones elementales

**** Texto de ayuda

#+name: Texto de ayuda de la clase ~T~ 
#+BEGIN_SRC python
"""Clase para las transformaciones elementales

T ("Transformación elemental") guarda en su atributo 'abreviaturas'
una abreviatura (o una secuencia de abreviaturas) de transformaciones
elementales. El método __and__ actúa sobre otra T para crear una T que
es composición de transformaciones elementales (una la lista de
abreviaturas), o bien actúa sobre una BlockM (para transformar sus
filas).

Una T (transformación elemental) se puede instanciar indicando las
operaciones mediante un número arbitrario de

 1. abreviaturas(set): {índice, índice}. Abrev. de un intercambio de
                       entre los elementos correspondientes a dichos
                       índices

              (tuple): (escalar, índice). Abrev. transf. Tipo II que
                       multiplica el elemento correspondiente al
                       índice por el escalar

                       (escalar, índice1, índice2). Abrev.
                       transformación Tipo I que suma al elemento
                       correspondiente al índice2 el elemento
                       correspondiente al índice1 multiplicado por
                       el escalar

 2. transf. Elems.(T): Genera otra T cuyo atributo .abreviaturas es
                       una copia del atributo .abreviaturas de la
                       transformación dada

 3.      listas(list): Con cualesquiera de los anteriores objetos o
                       con sublistas formadas con los anteriores
                       objetos. Genera una T cuyo atributo
                       .abreviaturas es una concatenación de todas las
                       abreviaturas


Atributos:

   abreviaturas (set): lista con las abreviaturas de todas las
                       transformaciones

            rpr (str): Si rpr='v' (valor por defecto) se muestra la
                       lista de breviaturas en vertical. Con cualquier
                       otro valor se muestran en horizontal.

Ejemplos:
>>> # Intercambio entre elementoes
>>> T( {1,2} )

>>> # Trasformación Tipo II (multiplica por 5 el segundo elemento)
>>> T( (5,2) )

>>> # Trasformación Tipo I (resta el tercer elemento al primero)
>>> T( (-1,3,1) )

>>> # Secuencia de las tres transformaciones anteriores
>>> T( [{1,2}, (5,2), (-1,3,1)] )

>>> # T de una T
>>> T( T( (5,2) ) )

T( (5,2) )

>>> # T de una lista de T's
>>> T( [T([(-8, 2), (2, 1, 2)]), T([(-8, 3), (3, 1, 3)]) ] )

T( [(-8, 2), (2, 1, 2), (-8, 3), (3, 1, 3)] )

"""
#+END_SRC

**** Método de inicialización

#+name:  Inicialización de la clase ~T~
#+BEGIN_SRC python :noweb no-export

def __init__(self, *args, rpr='v'):
    """Inicializa una transformación elemental"""
    <<Verificación de que las .abreviaturas corresponden a transformaciones elementales o intercambios>>
    
    def CreaListaAbreviaturas(arg):
        if isinstance(arg, (tuple, set)):
            verificacion(arg)
            return [arg]
        if isinstance(arg, list):
            return [abrv for item in arg for abrv in CreaListaAbreviaturas(item)]
        if isinstance(arg, T):
            return CreaListaAbreviaturas(arg.abreviaturas) 
    
    def concatenaTodasLasAbreviaturasDeLos(args):
        return [abrv for item in args for abrv in CreaListaAbreviaturas(item)]
    
    self.abreviaturas = concatenaTodasLasAbreviaturasDeLos(args)
    self.rpr          = rpr

#+END_SRC

***** Verificación de que las abreviaturas corresponden a transformaciones elementales o intercambios

Un transformación elemental no puede multiplicar ningún elemento por
cero, ni sumar a un elemento un múltiplo de si mismo. Además, un
intercambio solo tiene sentido a lo sumo entre dos elementos.
#+name: Verificación de que las .abreviaturas corresponden a transformaciones elementales o intercambios
#+BEGIN_SRC python

def verificacion(abrv):
    if isinstance(abrv,tuple) and (len(abrv) == 2) and abrv[0]==0:
        raise ValueError('T( (0, i) ) no es una trasformación elemental')
    if isinstance(abrv,tuple) and (len(abrv) == 3) and (abrv[1] == abrv[2]):
        raise ValueError('T( (a, i, i) ) no es una trasformación elemental')
    if isinstance(abrv,set) and len(abrv)>2:
        raise ValueError ('El conjunto debe tener uno o dos índices para ser un intercambio')
    
#+END_SRC

*** Composición de Transformaciones o transformación de un ~Sistema~ por la izquierda

**** Texto de ayuda

#+name: Texto de ayuda para la composición de Transformaciones Elementales
#+BEGIN_SRC python
"""Composición de transformaciones elementales (o transformación filas)

Crea una T con una lista de abreviaturas de transformaciones elementales
(o llama al método que modifica las filas de una Matrix)

Parámetros:
    (T): Crea la abreviatura de la composición de transformaciones, es
         decir, una lista de abreviaturas
    (Matrix): Llama al método de la clase Matrix que modifica sus filas

Ejemplos:
>>> # Composición de dos Transformaciones elementales
>>> T( {1, 2} ) & T( (2, 4) )

T( [{1,2}, (2,4)] )

>>> # Composición de dos Transformaciones elementales
>>> T( {1, 2} ) & T( [(2, 4), (2, 1), {3, 1}] )

T( [{1, 2}, (2, 4), (2, 1), {3, 1}] )

>>> # Transformación de las filas de una Matrix
>>> T( [{1,2}, (4,2)] ) & A # multiplica por 4 la segunda fila de A y
                            # luego intercambia las dos primeras filas
"""        

#+END_SRC

**** Implementación

Describimos la composición de transformaciones
\begin{math}
  \text{\tt{T(}}t_1\text{\tt{) \& T(}}t_{2}\text{\tt{)}}
\end{math}
creando una lista de abreviaturas $[\OEg[1],\OEg[2]]$ (mediante la
concatenación de listas)[fn:: Recuerde que la suma de listas
(\texttt{list + list}) concatena las listas]. Si ~other~ es un
~BlockV~ o una ~BlockM~, se llama al método =__rand__= de la clase
~other~ (que transformará los elementos del vector en el primer caso,
y las filas de la matriz en el segundo; y que veremos más adelante).

#+name: Composición de Transformaciones Elementales o aplicación sobre las filas de una Matrix
#+BEGIN_SRC python :noweb no-export

def __and__(self, other):
    <<Texto de ayuda para la composición de Transformaciones Elementales>>
    if isinstance(other, T):
        return T(self.abreviaturas+other.abreviaturas, rpr=self.rpr)

    if isinstance(other, Sistema):
        return other.__rand__(self)

#+END_SRC

*** Transposición de transformaciones elementales



Puesto que
\begin{math}
  \;\SITEC{1}{k}{\Mat{I}}={\TECpE*[1]{\Mat{I}}\dotsm\TECpE*[k]{\Mat{I}}}\;
\end{math}
y puesto que el producto de matrices es asociativo, deducimos que la
transpuesta de $\TrC[\OEg[1]\OEg[2]\cdots\OEg[k]]{\Mat{I}}$ es
\begin{displaymath}
  \Transp{\TrC[\OEg[1]\OEg[2]\cdots\OEg[k]]{\Mat{I}}}
  \;=\;
  \TransP{\TECpE*[1]{\Mat{I}}\TECpE*[2]{\Mat{I}}\dotsm\TECpE*[k]{\Mat{I}}}
  \;=\;
  \Transp*{\TEC[k]{\Mat{I}}}\dotsm\Transp*{\TEC[2]{\Mat{I}}}\Transp*{\TEC[1]{\Mat{I}}}
  \;=\;
  \TEFpE*[k]{\Mat{I}}\dotsm\TEFpE*[2]{\Mat{I}}\TEFpE*[1]{\Mat{I}}
  \;=\;\TrF[\OEg[k]\cdots\OEg[2]\OEg[1]]{\Mat{I}}
\end{displaymath}
Nótese cómo al transponer no solo cambiamos de lado los subíndices,
sino también invertimos el orden de la secuencia de transformaciones
(de la misma manera que también cambia el orden en el que se
multiplican las matrices elementales).  Esto sugiere denotar a la
operación de invertir el orden de las transformaciones como una
transposición:
\begin{displaymath}
  \Transp*{\SOEg[1][k]} = \SOEg[k][1];
\end{displaymath}
así
\begin{displaymath}
  \Transp{\SITEC{1}{k}{\Mat{A}}}=
  \TrF[\Transp*{\SOEg[1][k]}]{\MatTpE*{A}}=
  \TrF[\SOEg[k][1]]{\MatTpE*{A}}
\end{displaymath}

*Fíjese que efectivamente hemos logrado que la notación con abreviaturas se comporte como la notación matricial!*

El siguiente procedimiento invierte el orden de la lista cuando =t= es
una lista de abreviaturas. Cuando =t= es una única abreviatura, no
hace nada.

#+name: Operador transposición para la clase ~T~
#+BEGIN_SRC python

def __invert__(self):
    """Transpone la lista de abreviaturas (invierte su orden)"""
    return T( list(reversed(self.abreviaturas)), rpr=self.rpr) if isinstance(self.abreviaturas, list) else self
    
#+END_SRC

*** Potencias e inversa de transformaciones elementales

Toda matriz de la forma $\TrC{\Mat{I}}$ ó $\TrF{\Mat{I}}$ es
invertible por ser producto de matrices elementales:
\begin{displaymath}
  \Transp{\TrC{\Mat{I}}}\Transp{\TrC[\InvOEg[k]\cdots\InvOEg[1]]{\Mat{I}}}=
  \TrC[\SOEg\cdot\InvOEg[k]\cdots\InvOEg[1]]{\Mat{I}}=
  \Mat{I};
\end{displaymath}
por lo que podemos denotar por $\Invp{\SOEg}$ a la sucesión de
$\InvOEg[k]\cdots\InvOEg[1]$. De este modo
\begin{displaymath}
  \Invp{\TrC{\Mat{I}}}=
  \TrC[\Invp*{\SOEg}]{\Mat{I}}=
  \TrC[\InvOEg[k]\cdots\InvOEg[1]]{\Mat{I}}.
\end{displaymath}
El siguiente método devuelve la potencia ~n~-ésima de una
transformación elemental y cuando ~n~ es $-1$ dicha potencia es la
inversa:
#+BEGIN_SRC jupyter-python :exports code :results silent
T([ (1, 2, 3), (fracc(1,3), 2), {1, 2} ]) **(-1)
#+END_SRC
#+BEGIN_SRC jupyter-python :exports results :display text/plain
# :results raw :results output replace
dprint( T([ (1, 2, 3), (fracc(1,3), 2), {1, 2} ]) **(-1) ) 
#+END_SRC
#+RESULTS:
:RESULTS:
=T([{1, 2}, (3, 2), (-1, 2, 3)])=
:END:
que en Jupyter veríamos como
#+BEGIN_SRC jupyter-python :exports results :results raw :results output replace
pinta( T([ (1, 2, 3), (fracc(1,3), 2), {1, 2} ]) **(-1) )
#+END_SRC

#+RESULTS:
$\displaystyle \underset{\begin{subarray}{c} \left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]\\\left[\left(3\right)\mathbf{2}\right]\\\left[\left(-1\right)\mathbf{2}+\mathbf{3} \right]\end{subarray}}{\pmb{\tau}}$

Al implementar el método, definimos la potencia de manera recursiva
(con una función auxiliar =lambda=). Además, si ~n~ es cero,
devolveremos una transformación que no haga nada (identidad); por
ejemplo $\OEin{1}{1}$.

#+name: Potencia de una ~T~
#+BEGIN_SRC python :noweb no-export

def __pow__(self,n):
    """Calcula potencias de una T (incluida la inversa)"""
    <<Método auxiliar que calcula la inversa de una Transformación elemental>>    
    if not isinstance(n,int):
        raise ValueError('La potencia no es un entero')

    potencia = lambda T, n: T if n==1 else T & potencia(T, n-1)
    TransformacionElemental = potencia(self,abs(n)) if n!=0  else  T({1})
    
    return TransformacionElemental if n>0 else Tinversa(TransformacionElemental)
        
#+END_SRC

#+name: Método auxiliar que calcula la inversa de una Transformación elemental
#+BEGIN_SRC python

def Tinversa ( self ):
    """Calculo de la inversa de una transformación elemental"""
    operaciones = [                      abrv     if isinstance(abrv,set) else \
                    ( -abrv[0], abrv[1], abrv[2]) if len(abrv)==3         else \
                    (fracc(1,abrv[0]),   abrv[1])   for abrv in CreaLista(self.abreviaturas) ]

    return ~T( operaciones, rpr=self.rpr)

#+END_SRC

*** Transformaciones elementales ``espejo''

Al diagonalizar por semejanza, y aplicar transformaciones elementales
por la derecha, que es lo mismo que multiplicar por una matriz
invertible por la derecha, necesitaremos expresar la correspondiente
matriz inversa mediante una secuencia de transformaciones elementales
de la filas de la matriz identidad. Esto se logra con el método
=espejo=.[fn:: Al no encontrar ningún nombre en los manuales de
Álgebra Lineal para este concepto, he adoptado este descriptivo
nombre.]

#+name: Transformación elemental espejo de una ~T~
#+BEGIN_SRC python
def espejo ( self ):
    """Calculo de la transformación elemental espejo de otra"""
    return T([ (abrv[0], abrv[2], abrv[1]) if len(abrv)==3 else abrv for abrv in CreaLista(self.abreviaturas)], rpr=self.rpr)
    
#+END_SRC

*** Sustitución de variables simbólicas

Sustituye la variable =c= por =v=, donde =v= puede ser un valor, u otra variable simbólica.

#+name: Sustitución de variables simbólicas en una Transformación elemental
#+BEGIN_SRC python

def subs(self, regla_de_sustitucion=[]):
    '''Sustitución simbólica en transformaciones elementales'''
    
    def sustitucion(operacion, regla_de_sustitucion):
        if isinstance(operacion, tuple):
            return tuple(sympy.S(operacion).subs(CreaLista(regla_de_sustitucion)) )
        elif isinstance(operacion, set):
            return set(sympy.S(operacion).subs(CreaLista(regla_de_sustitucion)) )
        elif isinstance(operacion, list):
            return [sustitucion(item, regla_de_sustitucion) for item in operacion] 
        elif isinstance(operacion, T):
            return operacion.subs(CreaLista(regla_de_sustitucion)) 
        
    self = T([sustitucion(operacion, regla_de_sustitucion) for operacion in self.abreviaturas])
    return self

#+END_SRC

*** Métodos similares a los de una ~list~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos de la clase ~T~ para que actúe como si fuera una list de Python
       :END:

**** T es iterable

Haremos que =T= sea iterable con los procedimientos ``mágicos'' =__getitem__=, que permite seleccionar pasos de =T=, y 
=__setitem__=, que permite modificar pasos de =T=. Con =__len__=
podremos contar el número de pasos de =T=.

#+BEGIN_SRC python

def __getitem__(self,i):
    """ Devuelve las transformaciones elementales del i-ésimo paso """
    return T(self.abreviaturas[i])

def __setitem__(self,i,value):
    """ Modifica las transformaciones elementales del i-ésimo paso """
    self.abreviaturas[i]=value
        
def __len__(self):
    """Número de pasos de T """
    return len(self.abreviaturas)

#+END_SRC

**** Igualdad entre transformaciones elementales

#+name: Igualdad entre transformaciones elementales
#+BEGIN_SRC python

def __eq__(self, other):
    """Indica si es cierto que dos Transformaciones elementales son iguales"""
    return self.abreviaturas == other.abreviaturas

#+END_SRC

*** Representación de la clase ~T~

De nuevo construimos los dos métodos de presentación. Uno para la
consola de comandos que escribe =T= y entre paréntesis la
abreviatura (una tupla o un conjunto) que representa la
transformación. Así,
\begin{itemize}
\item  \Verb/T( {1, 5} )/ \qquad: intercambio entre los vectores primero y quinto.
\item  \Verb/T( (6, 2) )/ \qquad: multiplica por seis el segundo vector.
\item  \Verb/T( (-1, 2, 3) )/\,: resta el segundo vector al tercero.
\end{itemize}
La otra representación es para el entorno Jupyter y replica la
notación usada en los apuntes de la asignatura:
\begin{displaymath}
  \begin{array}{|l||c|}
    \hline
    \text{Python} & \text{Representación en Jupyter} \\
    \hline\hline
    \text{\tt T( \{1, 5\} )}   & \underset{\left[\pe{1}{5}\right]}{\pmb{\tau}}\\\hline
    \text{\tt T( (6, 2) )}     & \underset{\left[\pr{6}{2}\right]}{\pmb{\tau}}                      \\\hline
    \text{\tt T( (-1, 2, 3) )} & \underset{\left[\su{-1}{2}{3}\right]}{\pmb{\tau}}          \\\hline
    %\text{\tt T( (6, 2) )}     & \underset{\left[(6)\mathbf{2}\right]}{\pmb{\tau}}                      \\\hline
    %\text{\tt T( (-1, 2, 3) )} & \underset{\left[(-1)\mathbf{2}+\mathbf{3}\right]}{\pmb{\tau}}          \\\hline
  \end{array}
\end{displaymath}
Los apuntes de la asignatura usan una notación matricial, y por tanto
es una notación que discrimina entre operaciones sobre las filas o las
columnas, situando los operadores a la izquierda o a la derecha de la
matriz. En este sentido, nuestra notación en Python hace lo
mismo. Así, en la siguiente tabla, la columna de la izquierda
corresponde a operaciones sobre las filas, y la columna de la derecha
a las operaciones sobre las columnas:
\begin{displaymath}
  \begin{array}{|r|r||l|l|}
    \hline
    \text{Mates II}&\text{Python} & \text{Mates II}&\text{Python}\\
    \hline\hline
    \TEIF{i}{j}{\Mat{A}}     & \text{{\tt T( \{i,j\} ) \& A}} &
    \TEIC{i}{j}{\Mat{A}}     & \text{{\tt A \& T( \{i,j\} ) }} \\ \hline
    \TEPF{a}{i}{\Mat{A}}     & \text{{\tt T( (a,i) ) \& A}}    &
    \TEPC{a}{j}{\Mat{A}}     & \text{{\tt A \& T( (a,j) ) }}   \\ \hline
    \TESF{a}{i}{j}{\Mat{A}} & \text{{\tt T( (a,i,j) ) \& A}}  &
    \TESC{a}{i}{j}{\Mat{A}} & \text{{\tt A \& T( (a,i,j) ) }} \\ \hline    
  \end{array}
\end{displaymath}

**** Secuencias de transformaciones

Considere las siguientes transformaciones
\begin{itemize}
\item multiplicar por 2 el primer vector, cuya abreviatura es:\qquad\quad \Verb/ (2, 1) /
\item intercambiar el tercer vector por cuarto, cuya abreviatura es:\quad \Verb/ {3, 4} /
\end{itemize}
Para indicar una secuencia que contiene ambas transformaciones,
usaremos una lista de abreviaturas: =[(2,1), {3,4}]=.
De esta manera, cuando componemos
ambas operaciones: =T( (2,1) ) & T( {3,4} )=,
nuestra librería nos devuelve la trasformación composición de las dos
operaciones *en el orden en el que han sido escritas*:
\begin{center}
  al escribir \mbox{\Verb/ T( (2, 1) ) & T( {3, 4} )/}
  \quad Python nos devuelve \quad
  \mbox{\Verb/T( [ (1, 2), {3, 4} ] )/}
\end{center}
Por tanto, si queremos realizar dichas operaciones sobre las columnas
de la matriz \Mat{A}, podemos hacerlo de dos formas: 
\begin{itemize}
\item \Verb/ A & T( (2, 1) ) & T( {3, 4} ) / \quad (indicando las transformaciones de una en una)
\item \Verb/ A & T( [(2, 1), {3, 4}] ) /    \quad (usando la transformación composición de ambas)
\end{itemize}
y si queremos operar sobre la filas hacemos exactamente igual, pero a
la izquierda de la matriz
\begin{itemize}
\item \Verb/ T( (2, 1) ) & T( {3, 4} ) & A/
\item \Verb/ T( [(2, 1), {3, 4}] ) & A/
\end{itemize}

***** Representación de una secuencia de transformaciones

\begin{displaymath}
  \begin{array}{|l||c|}
    \hline
    \text{Representación en la consola de Python} & \text{Representación en Jupyter} \\
    \hline\hline
    \text{ \tt T( [ (2, 1), (1, 3, 2) ] ) } &
    \underset{\delimitershortfall=-1pt
      \begin{subarray}{c}
        \\\left[\pr{2}{1}\right]
        \\\left[\su{1}{3}{2}\right]
      \end{subarray}}{\TrEl}
    \\\hline
  \end{array}
\end{displaymath}

***** Representación de transformaciones identidad

Si las transfomaciones multiplican un vector por 1, y suman un vector
nulo a otro vector, dichas transformaciones no cabian el sistema de
vectores. Lo habitual es que si un paso no modifica nada, que no se
represente, por ello se filtran los pasos con el procedimiento [[Cribado de secuencias de transformaciones][Cribado
de secuencias de transformaciones]]; si, a resultas del filtrado, la
lista de abreviaturas es vacía entonces la representación en \LaTeX{}
es una cadena vacía (no se pinta ningún símbolo en Jupyter). Si el
atributo =rpr= es distinto de ='v'= la representación en Jupiter se
realiza en horizontal.

#+name: Representación de la clase ~T~
#+BEGIN_SRC python

def __repr__(self):
    """ Muestra T en su representación Python """
    return 'T(' + repr(self.abreviaturas) + ')'

def _repr_html_(self):
    """ Construye la representación para el entorno Jupyter Notebook """
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para representar una Trans. Elem. """
    def simbolo(t):
        """Escribe el símbolo que denota una trasformación elemental particular"""
        if isinstance(t,(set,sympy.sets.sets.FiniteSet)):
            return '\\left[\\mathbf{' + latex(list(t)[0]) + \
              '}\\rightleftharpoons\\mathbf{' + latex(list(t)[-1]) + '}\\right]'
        if isinstance(t,(tuple, sympy.core.containers.Tuple)) and len(t) == 2:
            return '\\left[\\left(' + \
              latex(t[0]) + '\\right)\\mathbf{'+ latex(t[1]) + '}\\right]'
        if isinstance(t,(tuple, sympy.core.containers.Tuple)) and len(t) == 3:
            return '\\left[\\left(' + latex(t[0]) + '\\right)\\mathbf{' + \
              latex(t[1]) + '}' + '+\\mathbf{' + latex(t[2]) + '} \\right]'    

    if isinstance(self.abreviaturas, (set, tuple) ):
        return '\\underset{' + simbolo(self.abreviaturas) + '}{\\pmb{\\tau}}'

    elif self.abreviaturas == []:
        return ' '

    elif isinstance(self.abreviaturas, list) and self.rpr=='v':
        return '\\underset{\\begin{subarray}{c} ' + \
              '\\\\'.join([simbolo(i) for i in self.abreviaturas])  + \
              '\\end{subarray}}{\\pmb{\\tau}}'

    elif isinstance(self.abreviaturas, list):
        return '\\underset{' + \
               '}{\\pmb{\\tau}}\\underset{'.join([simbolo(i) for i in self.abreviaturas]) + \
               '}{\\pmb{\\tau}}'
              
#+END_SRC

*** La clase ~T~ completa

#+name: Definición de la clase T
#+BEGIN_SRC python :noweb no-export

class T:
    <<Texto de ayuda de la clase ~T~>>
    <<Inicialización de la clase ~T~>>
    <<Composición de Transformaciones Elementales o aplicación sobre las filas de una Matrix>>
    <<Operador transposición para la clase ~T~>>
    <<Método auxiliar que calcula la inversa de una Transformación elemental>>
    <<Potencia de una ~T~>>
    <<Transformación elemental espejo de una ~T~>>
    <<Sustitución de variables simbólicas en una Transformación elemental>>
    <<Métodos de la clase ~T~ para que actúe como si fuera una list de Python>>
    <<Representación de la clase ~T~>>

#+END_SRC


* Las clases ~SubEspacio~ y  ~EAfin~

** La clase ~SubEspacio~ (de \R[m])

El conjunto de vectores \Vect{x} que resuelven el sistema
\SEL{A}{x}{0} es un subespacio de \R[n]; y el conjunto de vectores
\Vect{x} que resuelven el sistema \SEL{A}{x}{b} con
$\Vect{b}\ne\Vect{0}$ es un espacio afín de \R[n]. En este capítulo
vamos a definir objetos que representen estos subconjuntos de \R[n].

\section{La clase ~SubEspacio~ (de \R[m])} La clase ~SubEspacio~ se
puede instanciar tanto con un ~Sistema~ de ~Vectores~ como con una
~Matrix~.

En el primer caso, dado un ~Sistema~ de vectores, por ejemplo
\begin{displaymath}
  S=
  \left[
    \begin{pmatrix}0\\1\\0\end{pmatrix};\;
    \begin{pmatrix}2\\1\\3\end{pmatrix};\;
    \begin{pmatrix}2\\10\\3\end{pmatrix}
  \right],
\end{displaymath}
=SubEspacio( S )= corresponde al conjunto de combinaciones lineales de
los ~Vectores~ de dicho ~Sistema~, representado por las siguientes
ecuaciones /paramétricas/:
\begin{displaymath}
  \left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^2,\; \boldsymbol{v}= \begin{bmatrix}0&2\\1&0\\0&3\end{bmatrix}\boldsymbol{p}\right. \right\}\; 
\end{displaymath}
donde el vector \Vect{p} es el vector de parámetros.  En el segundo
caso, dada una ~Matrix~, por ejemplo
\begin{displaymath}
  \;\Mat{M}=\begin{bmatrix}-3&0&2\\6&0&-4\end{bmatrix},\;
\end{displaymath}
=SubEspacio( M )= corresponde al conjunto de ~Vectores~ que son
solución al sistema de ecuaciones
\begin{math}
  \;\MV{M}{v}=\Vect{0};\;
\end{math}
y que se puede representar con el sistema de ecuaciones /cartesianas/:
\begin{displaymath}
  \left\{
    \boldsymbol{v}\in\mathbb{R}^3\
    \left|
      \ \begin{bmatrix}-3&0&2\end{bmatrix}\boldsymbol{v}=\boldsymbol{0}
    \right\}
  \right.
\end{displaymath}
En ambos ejemplos corresponden al mismo subespacio de \R[3]; y, de
hecho, la librería muestra ambos tipos de representación para cada
~SubEspacio~: las ecuaciones paramétricas a la izquierda y las
cartesianas a la derecha.
\begin{displaymath}
  \left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^2,\; \boldsymbol{v}= \begin{bmatrix}0&2\\1&0\\0&3\end{bmatrix}\boldsymbol{p}\right. \right\}\; = \;\left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \begin{bmatrix}-3&0&2\end{bmatrix}\boldsymbol{v}=\boldsymbol{0}\right.\right\}
\end{displaymath}
~SubEspacio~ tiene varios atributos.
- ~dim~: dimensión del subespacio. En el ejemplo =dim=2=.
- ~Rn~: indica el espacio vectorial \R[n] al que pertenece
  =SubEspacio(S)=. En el ejemplo anterior =Rn=3= puesto que es un
  subespacio de \R[3].
- ~base~: una base del subespacio (un ~Sistema~ de ~Vectores~ de
  ~Rn~). Cuando ~dim==0~ base es un ~Sistema~ vacío.
- ~sgen~: Un ~Sistema~ de ~Vectores~ generador del subespacio. En
  particular será el sistema de vectores correspondiente a la ~Matrix~
  de coeficientes empleada en la representación con ecuaciones
  paramétricas. En el ejemplo Cuando ~dim==0~, ~sgen~ contiene un
  vector nulo de ~Rm~ componentes.
  \begin{displaymath}
    \left[\begin{pmatrix}0\\1\\0\end{pmatrix};\;\begin{pmatrix}2\\0\\3\end{pmatrix};\right]
  \end{displaymath}
- ~cart~: ~Matrix~ de coeficientes empleada en la representación con
  las ecuaciones cartesianas. En el ejemplo
  \begin{displaymath}
    \begin{bmatrix}
      -3 & 0 & 2
    \end{bmatrix}.
  \end{displaymath}

*** Implementación de ~SubEspacio~

La implementación requiere encontrar un ~Sistema~ base del
~SubEspacio~ columna de una ~Matrix~ ~A~. Lo haremos pre-escalonando
una ~Matrix~ ~A~ con ~elim(0)~ (así evitamos las fracciones en la medida
de lo posible). También necesitaremos encontrar un sistema generador
del un espacio nulo de ~A~. Lo haremos con el método auxiliar
~SGenENulo~.

#+name: Inicialización de la clase ~SubEspacio~
#+BEGIN_SRC python :noweb no-export
def __init__(self, data, sust=[], Rn=[]):
    """Inicializa un SubEspacio de Rn"""
    <<Método auxiliar ~sistema_generador_del_espacio_nulo_de~ una ~Matrix~>>
    if not isinstance(data, Sistema):
        raise ValueError(' Argumento debe ser un Sistema o Matrix ')
    
    if not data:
        if not Rn:
            raise ValueError(' Si el sistema es vacio, es necesario indicar el espacio Rn ')
        else:
            self.Rn = Rn
            self.__dict__ = SubEspacio(Sistema([self.vector_nulo()])).__dict__.copy()
        
    elif isinstance(data, Matrix):
        A         = data
        self.Rn   = Rn if Rn else A.n
        self.sgen = sistema_generador_del_espacio_nulo_de(A, sust, Rn)
        self.dim  = 0 if self.sgen.es_nulo() else len(self.sgen)
        self.base = self.sgen if self.dim else Sistema([])
        self.cart = SubEspacio(self.sgen, sust, self.Rn).cart

    else:
        if isinstance(data|1, BlockM):
            self.Rn = ((data|1).m, (data|1).n)
        elif isinstance(data|1, Sistema):
            self.Rn =  (data|1).n
            
        try:
            A = Matrix(data).subs(sust)
        except:
            A = BlockM([data]).subs(sust)
        self.base = Sistema([data.K()|j for j,v in enumerate(A.elim(0), 1) if v.no_es_nulo()])
        self.dim  = len(self.base)
        self.sgen = self.base if self.base else Sistema([ self.vector_nulo() ])
        
        if isinstance(self.Rn, int):
            self.cart = ~Matrix(sistema_generador_del_espacio_nulo_de(~A, sust))
        elif isinstance(self.Rn, tuple):
            self.cart = SubEspacio(Sistema([m.vec() for m in self.sgen]), Rn=self.Rn).cart
    
#+END_SRC

Las columnas de ~E~ correspondientes a los elementos nulos de ~K~ son
una base del espacio nulo.

#+name: Método auxiliar ~sistema_generador_del_espacio_nulo_de~ una ~Matrix~
#+BEGIN_SRC python

def sistema_generador_del_espacio_nulo_de(A, sust=[], Rn=[]):
    """Encuentra un sistema generador del Espacio Nulo de A"""
    K = A.K(0, sust);
    E = I(A.n) & T(K.pasos[1])
    lista = [ v.reshape(Rn) for j, v in enumerate(E,1) if (K|j).es_nulo(sust) ]
    return Sistema(lista) if lista else Sistema([self.vector_nulo()])

#+END_SRC

#+name: Método auxiliar para establecer el vector nulo del subespacio
#+BEGIN_SRC python

def vector_nulo(self):
    return M0(self.Rn[0],self.Rn[1]) if isinstance(self.Rn, tuple) else V0(self.Rn)

#+END_SRC


*** Métodos de la clase ~SubEspacio~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos de la clase ~SubEspacio~
       :END:

Definimos un método que nos indique si es cierto que un ~SubEspacio~
está contenido en otro (~contenido_en~). Si ~A~ y ~B~ son
~SubEspacios~, la siguiente expresión
\begin{center}
  \Verb/A.contenido_en(B)/
\end{center}
nos dirá si es cierto que ~A~ es un ~SubEspacio~ de ~B~.

Para comprobar si un ~SubEspacio~ ~A~ está contenido en un
~SubEspacio~ ~B~, basta verificar si todos los vectores del sistema
generador de ~A~ son solución de las ecuaciones cartesianas de ~B~. Si
~B~ es un ~EAfin~, entonces ~B.v~ debe ser nulo y ~A~ debe estar
contenido en ~B.S~.

#+BEGIN_SRC python

def contenido_en(self, other):
    """Indica si este SubEspacio está contenido en other"""
    self.verificacion(other)
    if isinstance(other, SubEspacio):
        if isinstance(self.sgen|1, Vector):
            return all ([ (other.cart*v).es_nulo() for v in self.sgen ])
        elif isinstance(self.sgen|1, Matrix):
            return all ([ (other.cart*v.vec()).es_nulo() for v in self.sgen ])
        
    elif isinstance(other, EAfin):
        return other.v.es_nulo() and self.contenido_en(other.S)

#+END_SRC

También definimos dos métodos (mágicos) que nos indican
- si dos ~SubEspacios~ son iguales (~__eq__~), es decir, que ~A~ esta
  contenido en ~B~ y viceversa; o
- si son distintos (~__ne__~), es decir, que no son iguales.

Así podemos usar las siguientes expresiones booleanas
\begin{center}
\Verb/A == B/
\quad y \quad
\Verb/A != B/
\end{center}

#+BEGIN_SRC python

def __eq__(self, other):
    """Indica si un subespacio de Rn es igual a otro"""
    self.verificacion(other)
    return self.contenido_en(other) and other.contenido_en(self)

def __ne__(self, other):
    """Indica si un subespacio de Rn es distinto de otro"""
    self.verificacion(other)
    return not (self == other)

#+END_SRC

Para que estos tres métodos funcionen es necesario un método auxiliar
que realice la ~verificacion~ de que los dos argumentos son
~SubEspacios~ o ~EAfines~ del mismo espacio vectorial \R[m] (como este
método tampoco es mágico, se invoca con ~self.verificacion()~).

#+BEGIN_SRC python

def verificacion(self,other):
    if not isinstance(other, (SubEspacio, EAfin)) or  not self.Rn == other.Rn: 
        raise \
         ValueError('Ambos argumentos deben ser subconjuntos de en un mismo espacio')

#+END_SRC

El método suma ~A + B~ arroja la suma de dos ~SubEspacios~ de \R[m]
(el es subespacio generado por la concatenación de los respectivos
sistemas generadores).

#+BEGIN_SRC python

def __add__(self, other):
    """Devuelve la suma de subespacios de Rn"""
    self.verificacion(other)
    return SubEspacio(self.sgen.concatena(other.sgen))

#+END_SRC

y definimos otro método que nos devuelva la intersección: ~A & B~. 
# Para ello apilamos las matrices de las ecuaciones cartesianas en una
# sola ~Matrix~ y obtenemos el ~SubEspacio~ correspondiente. 
Si ~other~ es un ~EAfin~ llamamos al método de la intersección entre
un ~EAfin~ y un ~SubEspacio~.

#+BEGIN_SRC python

def __and__(self, other):
    """Devuelve la intersección de subespacios"""
    self.verificacion(other)
    
    if isinstance(other, SubEspacio):
        A  = self.base
        B  = other.base
        AB = A.concatena(B)
        X  = slice(1,self.dim)|Matrix(AB.espacio_nulo().base)
        return SubEspacio(A*X)
    
    elif  isinstance(other, EAfin):
        return other & self

#+END_SRC

# return SubEspacio( self.cart.apila(other.cart), Rn=self.Rn )

Con =~A= obtenemos el complemento ortogonal (el ~SubEspacio~ generado
por las filas de ~self.cart~)

#+BEGIN_SRC python

def __invert__(self):
    """Devuelve el complemento ortogonal"""
    if isinstance(self.sgen|1, Vector):
        return SubEspacio( Sistema( ~(self.cart) ) )
    
    elif isinstance(self.sgen|1, Matrix):
        return SubEspacio(Sistema([v.reshape(self.Rn) for v in ~(self.cart)]))
    
#+END_SRC

\noindent Finalmente definimos un método para saber si un ~Vector x~
pertenece a un ~SubEspacio A~ (basta verificar si ~x~ es solución del
sistema de ecuaciones cartesianas). Obtenemos la respuesta con
\begin{center}
  \Verb/ x in A /
\end{center}

#+BEGIN_SRC python

def __contains__(self, other):
    """Indica si un Vector pertenece a un SubEspacio"""

    if isinstance(self.sgen|1, Vector):
        if not isinstance(other, Vector) or other.n != self.Rn:
            raise ValueError\
                ('El Vector no tiene el número adecuado de componentes')
        return self.cart*other == V0(self.cart.m)
    
    elif isinstance(self.sgen|1, Matrix):
        if not isinstance(other, Matrix) or (other.n,other.m) != self.Rn:
            raise ValueError\
                ('El Vector no tiene el número adecuado de componentes')        
        return self.cart*other.vec() == V0(self.cart.m)
    

#+END_SRC

*** Métodos de representación de la clase ~SubEspacio~

#+name: Métodos de representación de la clase ~SubEspacio~
#+BEGIN_SRC python :noweb no-export

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def EcParametricas(self, d=0):
    """Representación paramétrica del SubEspacio"""
    if d: display(Math(self.EcParametricas()))
    return EAfin(self.sgen, self.vector_nulo()).EcParametricas()

def EcCartesianas(self, d=0):
    """Representación cartesiana del SubEspacio"""
    if d: display(Math(self.EcCartesianas()))
    return EAfin(self.sgen, self.vector_nulo()).EcCartesianas()
    
def latex(self):
    """ Construye el comando LaTeX para un SubEspacio de Rn"""
    return EAfin(self.sgen, self.vector_nulo()).latex()       

#+END_SRC


*** La clase ~SubEspacio~ completa

#+name: Definición de la clase ~SubEspacio~
#+BEGIN_SRC python :noweb no-export

class SubEspacio:
    <<Inicialización de la clase ~SubEspacio~>>
    <<Método auxiliar para establecer el vector nulo del subespacio>>
    <<Métodos de la clase ~SubEspacio~>>
    <<Métodos de representación de la clase ~SubEspacio~>>

#+END_SRC


** La clase ~EAfin~ (de \R[m])

El conjunto de soluciones de un sistema de ecuaciones homogéneo
\SEL{A}{x}{0} forma un subespacio (que llamamos espacio nulo
\nulls{A}), pero el conjunto de soluciones de \SEL{A}{x}{b} cuando
$\Vect{b}\ne\Vect{0}$ es un \emph{espacio afín}.


*** Implementación de ~EAfin~

Vamos a crear la clase ~EAfin~. La definiremos como un par
$(\EV{S},\Vect{v})$ cuyo primer elemento, \EV{S}, sea un ~SubEspacio~
(el conjunto de soluciones a \SEL{A}{x}{0}) y cuyo segundo elemento,
\Vect{v}, sea un vector del espacio afín (una solución particular de
\SEL{A}{x}{b}). En el atributo ~S~ guardaremos el ~SubEspacio~ y en el
atributo ~v~ un ~Vector~. Así, pues, para instanciar un ~EAfin~
usaremos dos argumentos: el primero será un ~Sistema~ formado por
~Vectores~ (típicamente una ~Matrix~) con la que formar el
~SubEspacio~, y el segundo será un ~Vector~.


Cuando $\Vect{v}\in\EV{S}$, el espacio afín es un subespacio (que por
tanto contiene al vector nulo). Así que si $\Vect{v}\in\EV{S}$ en el
atributo ~v~ guardaremos el vector nulo. Así, si consideramos el
sistema ``ampliado'' que contiene los vectores del sistema generador
de ~S~ primero, y ~v~ como último vector ~v~, y aplicamos el método de
eliminación de izquierda a derecha; el último vector tras la
eliminación pertenece al espacio afín, y será cero si
$\Vect{v}\in\EV{S}$. Si ~vi~ es cero (su valor por defecto), en
~self.v~ se guardará el vector resultante tras la eliminación, en caso
contrario se guardará el vector indicado (~vi~) como argumento.

#+name: Inicialización de la clase ~EAfin~
#+BEGIN_SRC python

def __init__(self, data, v, vi=0):
    """Inicializa un Espacio Afín de Rn"""
    self.S  = data if isinstance(data, SubEspacio) else SubEspacio(data)
    self.Rn = self.S.Rn
    
    if isinstance(self.Rn, int):
        if not isinstance(v, Vector) or v.n != self.Rn:
            raise ValueError('v y SubEspacio deben estar en el mismo espacio vectorial')
        
    elif isinstance(self.Rn, tuple):
        if not isinstance(v, Matrix) or (v.m,v.n) != self.Rn:
            raise ValueError('v y SubEspacio deben estar en el mismo espacio vectorial')
        
    self.v  = v if vi else (self.S.sgen.concatena(Sistema([v]))).elim(1)|0
    
#+END_SRC


*** Métodos de la clase ~EAfin~
       :PROPERTIES:
       :header-args+: :noweb-ref Métodos de la clase ~EAfin~
       :END:

Un vector \Vect{x} pertenece al espacio afín \EV{S} si verifica las
ecuaciones cartesianas, cuya matriz de coeficientes es ~self.S.cart~,
y cuyo vector del lado derecho es ~(self.S.cart)*self.v~. Así pues

#+BEGIN_SRC python

def __contains__(self, other):
    """Indica si un Vector pertenece a un EAfin"""
    if isinstance(self.S.sgen|1, Vector):
        if not isinstance(other, Vector) or other.n != self.Rn:
            raise ValueError\
                ('El Vector no tiene el número adecuado de componentes')
        return self.S.cart*other == (self.S.cart)*self.v
    
    elif isinstance(self.S.sgen|1, Matrix):
        if not isinstance(other, Matrix) or (other.n,other.m) != self.Rn:
            raise ValueError\
                ('La matrix no tiene el orden adecuado')        
        return self.S.cart*other.vec() == self.S.cart*self.v.vec()

#+END_SRC


#+BEGIN_SRC python

def contenido_en(self, other):
    """Indica si este EAfin está contenido en other"""
    self.verificacion(other)
    
    if isinstance(other, SubEspacio):
        return self.v in other and self.S.contenido_en(other)
    
    elif isinstance(other, EAfin):
         return self.v in other and self.S.contenido_en(other.S)

#+END_SRC


#+BEGIN_SRC python

def __eq__(self, other):
    """Indica si un EAfin de Rn es igual a other"""
    self.verificacion(other)
    return self.contenido_en(other) and other.contenido_en(self)

def __ne__(self, other):
    """Indica si un subespacio de Rn es distinto de other"""
    return not (self == other)

#+END_SRC


#+BEGIN_SRC python

def verificacion(self,other):
    if not isinstance(other, (SubEspacio, EAfin)) or  not self.Rn == other.Rn: 
        raise ValueError('Ambos argumentos deben ser subconjuntos de en un mismo espacio')

#+END_SRC

La intersección es el conjunto de soluciones a ambos sistemas de
ecuaciones cartesianas. El modo más sencillo es unificar ambos
sistemas en uno solo: apilando las matrices de coeficientes por un
lado y concatenando los vectores del lado derecho por el otro.

#+BEGIN_SRC python

def __and__(self, other):
    """Devuelve la intersección de este EAfin con other"""
    self.verificacion(other)
    if isinstance(other, EAfin):
        M = self.S.cart.apila( other.S.cart )
        if isinstance(self.S.sgen|1, Vector):
            w = (self.S.cart*self.v).concatena( other.S.cart*other.v )
        elif isinstance(self.S.sgen|1, Matrix):
            w = (self.S.cart*self.v.vec()).concatena( other.S.cart*other.v.vec() )
    elif isinstance(other, SubEspacio):
        M = self.S.cart.apila( other.cart )
        if isinstance(self.S.sgen|1, Vector):
            w = (self.S.cart*self.v).concatena( V0(other.cart.m) )                                                      
        elif isinstance(self.S.sgen|1, Matrix):
            w = (self.S.cart*self.v.vec()).concatena( V0(other.cart.m) )
            
    return SEL(M,w).eafin

#+END_SRC

#    try:
#        S=SEL(M,w)
#    except:
#        print('Intersección vacía')
#        return Sistema([])
#    else:
#        return S

Con =~A= obtendremos el mayor ~SubEspacio~ perpendicular a ~A~.

#+BEGIN_SRC python

def __invert__(self):
    """Devuelve el mayor SubEspacio perpendicular a self"""
    return SubEspacio( Sistema([v.reshape(self.Rn) for v in ~(self.S.cart)]))

#+END_SRC


*** Métodos de representación de la clase ~EAfin~

#+name: Métodos de representación de la clase ~EAfin~
#+BEGIN_SRC python

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def EcParametricas(self, d=0):
    """Representación paramétrica de EAfin"""
    punto = latex(self.v) + '+' if (self.v != 0*self.v) else ''
    if d: display(Math(self.EcParametricas()))
    if isinstance(self.S.Rn,int):
        return r'\left\{ \boldsymbol{v}\in\mathbb{R}^' \
            + latex(self.S.Rn)  \
            + r'\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^' \
            + latex(max(self.S.dim,1)) \
            + r',\; \boldsymbol{v}= ' \
            + punto \
            + latex(Matrix(self.S.sgen)) \
            + r'\boldsymbol{p}\right. \right\}' 
    else:
        return r'\left\{ \pmb{\mathsf{M}}\in\mathbb{R}^{' \
            + latex(self.S.Rn[0]) + r'\times' + latex(self.S.Rn[1]) + '}' \
            + r'\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^' \
            + latex(max(self.S.dim,1)) \
            + r',\; \mathsf{\pmb{M}}= ' \
            + punto \
            + latex(self.S.sgen) \
            + r'\boldsymbol{p}\right. \right\}' 
                    
def EcCartesianas(self, d=0):
    """Representación cartesiana de EAfin"""
    if d: display(Math(self.EcCartesianas()))
    if isinstance(self.S.Rn,int):
        return r'\left\{ \boldsymbol{v}\in\mathbb{R}^' \
            + latex(self.S.Rn) \
            + r'\ \left|\ ' \
            + latex(self.S.cart) \
            + r'\boldsymbol{v}=' \
            + latex(self.S.cart*self.v) \
            + r'\right.\right\}' 
    else:
        return r'\left\{ \mathsf{\pmb{M}}\in\mathbb{R}^{' \
            + latex(self.S.Rn[0]) + r'\times' + latex(self.S.Rn[1]) + '}' \
            + r'\ \left|\ ' \
            + latex(self.S.cart) \
            + r'vec(\mathsf{\pmb{M}})=' \
            + latex(self.S.cart*self.v.vec()) \
            + r'\right.\right\}' 
    
def latex(self):
    """ Construye el comando LaTeX para un EAfin de Rn"""
    return self.EcParametricas() + '\\; = \\;' + self.EcCartesianas()
        
#+END_SRC


*** La clase ~EAfin~ completa

#+name: Definición de la clase ~EAfin~
#+BEGIN_SRC python :noweb no-export

class EAfin:
    <<Inicialización de la clase ~EAfin~>>
    <<Métodos de la clase ~EAfin~>>
    <<Métodos de representación de la clase ~EAfin~>>
    
#+END_SRC


* Las clases ~Homogenea~ y  ~SEL~

** Resolución de sistemas de ecuaciones homogéneos. La clase  ~Homogenea~ 

El siguiente código devuelve el conjunto de soluciones de un sistema homogéneo \SEL{A}{x}{0}. Descripción de los atributos:
- ~sgen~ es un sistema generador del espacio nulo \nulls{A}.
- ~determinado~ indica si es cierto que el sistema es determinado (una única solución)
- ~tex~ es la cadena de texto \LaTeX que representa los pasos dados
  para resolver el sistema.

*** Implementación de la clase ~Homogenea~

#+name: Resolución de un sistema de ecuaciones homogéneo
#+BEGIN_SRC python :noweb no-export

class Homogenea:
    def __init__(self, sistema, rep=0, sust=[], repsust=0):
        """Resuelve un Sistema de Ecuaciones Lineales Homogéneo
        
        y muestra los pasos para encontrarlo"""
        try:
            A = Matrix(sistema).subs(sust)
        except:
            A = BlockM([sistema]).subs(sust)

        MA = A.apila(I(A.n),1)
        MA.corteElementos.update({sistema.n+A.m})

        K    = A.K(0, sust)  
        E    = I(A.n) & T(K.pasos[1])
        
        self.base        = Sistema([ v for j, v in enumerate(E,1) if (K|j).es_nulo(sust) ])
        self.sgen        = self.base if self.base else Sistema([ V0(sistema.n) ])
        self.determinado = (len(self.base) == 0)
        self.pasos       = K.pasos; 
        self.TrF         = K.TrF 
        self.TrC         = K.TrC

        self.enulo       = SubEspacio(self.sgen)
        
        if repsust:
            self.tex         = rprElim( A.apila( I(A.n) ,1 ) , self.pasos, [], sust)
        else:
            self.tex         = rprElim( A.apila( I(A.n) ,1 ) , self.pasos)
            
        if rep:
            display(Math(self.tex))
            
    <<Métodos de representación de la clase ~Homogenea~>>   
    
#+END_SRC

La base la constituyen los vectores ~v~ de ~E~ que corresponden a los
vectores nulos de ~K~:

# #+name: Cálculo de una ~base~ del espacio nulo de ~A~
# #+BEGIN_SRC python
# K     = A.K(0, sust)  
# E     = I(A.n) & T(K.pasos[1])
# base  = [ v.subs(sust) for j, v in enumerate(E, 1) if (K|j).es_nulo(sust) ]
# #+END_SRC


*** Métodos de representación de la clase ~Homogenea~

#+name: Métodos de representación de la clase ~Homogenea~
#+BEGIN_SRC python

def __repr__(self):
    """Muestra el Espacio Nulo de una matriz en su representación Python"""
    return 'Combinaciones lineales de (' + repr(self.sgen) + ')'

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para la solución de un Sistema Homogéneo"""
    if self.determinado:
        return '\\left\\{\ ' + latex(self.sgen|1) + '\ \\right\\}'
    else:
        return '\\mathcal{L}\\left(\ ' + latex(self.sgen) + '\ \\right)' 

#+END_SRC


** Resolución de sistemas de ecuaciones lineales. La clase  ~SEL~ 

*** Implementación
**** Texto de ayuda

#+name: Texto de ayuda de la clase ~SEL~
#+BEGIN_SRC python
"""Resuelve un Sistema de Ecuaciones Lineales

mediante eliminación con el sistema ampliado y muestra los pasos
dados

"""
#+END_SRC
   
#+name: Resolución de un Sistema de Ecuaciones Lineales
#+BEGIN_SRC python :noweb no-export
class SEL:
    def __init__(self, sistema, b, rep=0, sust=[], repsust=0):
        <<Texto de ayuda de la clase ~SEL~>>
        try:
            A = Matrix(sistema.amplia(-b)).subs(sust).ccol({sistema.n})
        except:
            A = BlockM([sistema.amplia(-b)]).subs(sust).ccol({sistema.n})
            
        MA = A.apila(I(A.n),1)
        MA.corteElementos.update({sistema.n+A.m})
        operaciones = A.elim(0,False,sust).pasos[1]
        
        <<Aplicamos los ~pasos~ de eliminación sobre la matriz ampliada y obtenemos la solución>>
        
    <<Métodos de representación de la clase ~SEL~>>
    
#+END_SRC

Aplicamos los pasos sobre toda la matriz ampliada (más bien ``super
ampliada'', pues tiene una matriz identidad por debajo). Si el último
elemento de la última columna es nulo debajo vemos la solución.

#+name: Aplicamos los ~pasos~ de eliminación sobre la matriz ampliada y obtenemos la solución
#+BEGIN_SRC python

E         = I(sistema.n) & T(operaciones)

testigo   = 0| (I(A.n) & T(operaciones)) |0
Normaliza = T([]) if testigo==1 else T([( fracc(1,testigo), A.n )])
pasos     = [[], operaciones+[Normaliza] ] if Normaliza else [[], operaciones]

K         = A & T(operaciones)

self.base        = Sistema([ v for j, v in enumerate(E,1) if (K|j).es_nulo(sust) ])
self.sgen        = self.base if self.base else Sistema([ V0(sistema.n) ])
self.determinado = (len(self.base) == 0)
self.pasos       = pasos 
self.TrF         = T(self.pasos[0]) 
self.TrC         = T(self.pasos[1])

if (K|0).no_es_nulo():
    self.solP  = set()
    self.eafin = set()
else:
    self.solP  = (I(sistema.n).amplia(V0(sistema.n)) & T(pasos[1]))|0 
    self.eafin = EAfin(self.sgen, self.solP, 1)

if repsust:
    self.tex     = rprElim( MA, self.pasos, [], sust )
else:
    self.tex     = rprElim( MA, self.pasos)

if rep:
    display(Math(self.tex))           

#+END_SRC

*** Métodos de representación de la clase ~SEL~

#+name: Métodos de representación de la clase ~SEL~
#+BEGIN_SRC python

def __repr__(self):
    """Muestra el Espacio Nulo de una matriz en su representación Python"""
    return repr(self.solP) + ' + Combinaciones lineales de (' + repr(self.sgen) + ')'

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para la solución de un Sistema Homogéneo"""
    if self.determinado and self.solP:
        return '\\left\\{\ ' + latex(self.solP) + '\ \\right\\}'
    else:
        return self.eafin.EcParametricas() if self.solP else '\\emptyset' #latex(set())

#+END_SRC


* La clase ~Determinante~. Cálculo del determinante por eliminación Gaussiana

**** Método de inicialización

#+name: Definición de la clase Determinante
#+BEGIN_SRC python :noweb no-export
class Determinante:
   """Determinante de una Matrix mediante eliminación Gaussiana por columnas
   
   La representación muestra los pasos dados
   
   """
   def __init__(self, data, disp=0, sust=[]):
      <<Cálculo del determinante>>
      
      A  = Matrix(data.subs(sust))
      
      if not A.es_cuadrada():  raise ValueError('Matrix no cuadrada')
      
      self.tex, self.valor, self.pasos = calculoDet( A.subs(sust) )
      
      if disp:
         display(Math(self.tex))

   <<Métodos de representación de la clase Determinante>>
         
#+END_SRC

#+name: Cálculo del determinante
#+BEGIN_SRC python

def calculoDet(A, sust=[]):
    
    producto  = lambda x: 1 if not x else x[0] * producto(x[1:])
    
    def productos_realizados(operaciones):
        P = [ producto([-1 if isinstance(abv,set) else abv[0] \
                        for op in paso for abv in filter( lambda x: len(x)==2, op.abreviaturas)]) for paso in operaciones]
        return P
    
    operacionesEnColumnas = (A.L(0,sust).pasos[1])
    operacionesEnFilas    = [T((fracc(1,d),A.n+1)) for d in productos_realizados(operacionesEnColumnas)]
    pasos                 = [operacionesEnFilas, operacionesEnColumnas]
    
    matrixExtendida       = T(operacionesEnFilas) & A.extDiag(I(1),1) & T(operacionesEnColumnas)
    
    determinante          = sympy.sympify( producto( matrixExtendida.diag() ) ).simplify()
    
    tex                   = rprElimFyC( A.extDiag(I(1),1), pasos)
    
    return [tex, determinante, pasos]
    
#+END_SRC

#+name: Métodos de representación de la clase Determinante
#+BEGIN_SRC python

def __repr__(self):
   """Muestra un Sistema en su representación Python"""
   return 'Valor del determinante: ' + repr (self.valor)

def _repr_html_(self):
   """Construye la representación para el entorno Jupyter Notebook"""
   return html(self.latex())

def latex(self):
   """Construye el comando LaTeX para representar un Sistema"""
   return latex(self.valor)

#+END_SRC


* Las clases ~DiagonalizaS~, ~DiagonalizaO~ y  ~DiagonalizaC~
       :PROPERTIES:
       :header-args+: :noweb-ref Definición de las subclases DiagonalizaX
       :END:

Es una forma alternativa de llamar al método ~.diagonalizaS()~,
#+BEGIN_SRC python :noweb no-export

class DiagonalizaS(Matrix):
    def __init__(self, sistema, espectro, rep=0, repType=0):
        <<Texto de ayuda para la clase DiagonalizaS>>
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
        A = Matrix(sistema)
        D = A.diagonalizaS(espectro)
        
        if rep:
            nan   = sympy.symbols('\ ')
            dummyMatrix = M1(A.n)*nan
            if repType==1:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimCF(A.apila(I(A.n),1), D.pasos)
            elif repType==2:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimCF(A.apila(I(A.n),1).concatena(I(A.m).apila(dummyMatrix,1),1), D.pasos)
            elif repType==3:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimFyC(A.apila(I(A.n),1), D.pasos)
            elif repType==4:
                nan   = sympy.symbols('\ ')
                D.tex = rprElimFyC(A.apila(I(A.n),1).concatena(I(A.m).apila(dummyMatrix,1),1), D.pasos)
                
            display(Math(D.tex))
            
        self.__dict__.update(D.__dict__)
        self.__class__ = type(sistema)

#+END_SRC

Es una forma alternativa de llamar al método ~.diagonalizaO()~,
#+BEGIN_SRC python :noweb no-export

class DiagonalizaO(Matrix):
    def __init__(self, sistema, espectro):
        <<Texto de ayuda para la clase DiagonalizaO>>
        A = Matrix(sistema)
        D = A.diagonalizaO(espectro)
            
        self.__dict__.update(D.__dict__)
        self.__class__ = type(sistema)

#+END_SRC

  
* Librería completa

Finalmente creamos la librería =nacal.py= concatenando los trozos de
código que se describen en este fichero de documentación.

Importamos el módulo [[https://www.sympy.org/en/index.html][Sympy]] con el código:
\begin{center}
~import sympy~
\end{center}
Así podremos usar números racionales e irracionales (incluso el cuerpo
de polinomios). 

Como queremos que la librería emplee números racionales siempre que
sea posible, definimos tres métodos generales: ~fracc(a/b)~ es la
fracción $\frac{a}{b}$; ~numer(a,b)~; y ~denom(a,b)~ (véase la página
siguiente). Para usar el número racional $\frac{1}{3}$ escribiremos
~fracc(1,3)~, y para usar un número irracional como $\sqrt{2}$
escribimos ~sympy.sqrt(2)~. 

El módulo [[https://www.sympy.org/en/index.html][Sympy]] se ocupa de que Jupyter represente adecuadamente estos
objetos (incluso simplificando expresiones, de manera que si
escribimos el número irracional ~fracc(2,sympy.sqrt(2))~, es decir
$\frac{2}{\sqrt{2}}$, Jupyter lo simplificara representándolo como
$\sqrt{2}$).

Para poder trabajar con los Notebooks en Emacs importamos los métodos
=display=, =Math= y =display_png= del módulo =IPython.display=.

Para generar las imágenes =png= con las expresiones en \LaTeX{} en un
directorio temporal importamos =tempfile=
#+name: Librería completa

También importamos el método =join= del módulo =os.path=.
#+BEGIN_SRC python :noweb tangle :tangle AlgLin.py
# coding=utf8
import sympy
from IPython.display import display, Math, display_png
import tempfile
from os.path import join           

<<Consideracion de qué es un número>>
<<Métodos para usar coeficientes racionales cuando sea posible>>
<<Método html general>>
<<Método latex general>>
<<Pinta un objeto en Jupyter>>
<<Método auxiliar CreaLista que devuelve listas>>
<<Método auxiliar CreaSistema que devuelve sistemas>>
<<Métodos primer_no_nulo y ultimo_no_nulo de un Sistema>>
<<Otros métodos auxilares>>
<<Cribado de secuencias de transformaciones>>
<<Representación de un proceso de eliminación rprElim>>
<<Representación de un proceso de eliminación rprElimFyC>>
<<Representación de un proceso de eliminación rprElimCF>>
<<Representación de un proceso de eliminación dispElim, dispElimFyC y dispElimCF>>

<<Definición de la clase Sistema>>
<<Consideracion de qué es una secuencia>>
<<Definición de la subclase BlockV>>
<<Definición de la subclase Vector>>
<<Definición de las subclases V0 y V1>>
<<Definición de la subclase BlockM>>
<<Definición de la subclase Matrix>>
<<Definición de las subclases M0, M1 e I>>

<<Definición de la clase T>>
<<Definición de las subclases ElimX>>
<<Definición de las subclases InvMatX>>

<<Definición de la clase ~SubEspacio~>>
<<Definición de la clase ~EAfin~>>

<<Resolución de un sistema de ecuaciones homogéneo>>
<<Resolución de un Sistema de Ecuaciones Lineales>>

<<Definición de la clase Determinante>>
<<Definición de las subclases DiagonalizaX>>
#+END_SRC


** Métodos generales

*** Números

Consideraremos como números los enteros, los números de coma flotante,
los números complejos, y toda la familia de objetos de tipo [[https://docs.sympy.org/latest/modules/core.html#sympy.core.basic.Basic][=Basic=]]
del módulo [[https://docs.sympy.org/latest/index.html][Sympy]], lo que nos permite trabajar con números racionales,
muchos números reales y con expresiones simbólicas.
#+name: Consideracion de qué es un número
#+BEGIN_SRC python
NumberTypes = (int, float, complex, sympy.Basic)
es_numero   = lambda x: isinstance(x, NumberTypes) and not isinstance(x, bool)
#+END_SRC

*** Números racionales

#+name: Métodos para usar coeficientes racionales cuando sea posible
#+BEGIN_SRC python

def fracc(a,b):
    """Transforma la fracción a/b en un número racional si ello es posible"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return sympy.Rational(a, b)
    else:
        return a/b
    
def numer(a,b):
    """Devuelve el numerador de a/b si la fracción es un número racional,
       si no devuelve a/b"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return fracc(a,b).p
    else:
        return a/b 

def denom(a,b):
    """Devuelve el denominador de a/b si la fracción es un número
       racional, si no devuelve 1"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return fracc(a,b).q
    else:
        return 1

#+END_SRC

*** Ristras

Según el diccionario de la Real Academia Española una [[https://dle.rae.es/ristra][/ristra/]] es un
/conjunto de ciertas cosas colocadas unas tras otras/; por ello,
denominamos genéricamente ``ristra'' a cualquier objeto de tipo
=list=, =tuple= o =Sistema=.

#+name: Consideracion de qué es una secuencia
#+BEGIN_SRC python
RistraTypes = (tuple, list, Sistema)
es_ristra  = lambda x: isinstance(x, RistraTypes) 

def es_ristra_de_numeros(arg):
    return all( [es_numero(elemento) for elemento in arg] ) if es_ristra(arg) else None

#+END_SRC
*** Métodos de representación para el entorno Jupyter

El método =html=, escribe el inicio y el final de un párrafo en html y
en medio del párrafo escribirá la cadena =TeX=; que contendrá el
código \LaTeX{} de las expresiones matemáticas que queremos que se
muestren en pantalla cuando usamos [[https://jupyter.org/][Jupyter Notebook]]. En el navegador,
la librería [[https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Typesetting%20Equations.html][MathJax]] de Javascript se encargará de convertir la
expresión \LaTeX{} en la grafía correspondiente.

#+name: Método html general
#+BEGIN_SRC python

def html(TeX):
    """ Plantilla HTML para insertar comandos LaTeX """
    return "<p style=\"text-align:center;\">$" + TeX + "$</p>"
    
#+END_SRC

El método =latex= general, intentará llamar al método =latex=
particular del objeto que se quiere representar (para todos los
objetos de esta librería se define su método de representación). Si el
objeto no tiene definido el método =latex=, entonces se emplea el
método ~sympy.latex()~ del módulo [[https://www.sympy.org/en/index.html][Sympy]]. Así,
#+BEGIN_SRC jupyter-python :results none
Sistema([ sympy.Rational(1.5, 3), fracc(2.4, 1.2), fracc(2, sympy.sqrt(2)) ]) 
#+END_SRC
donde las componentes se han escrito explícitamente como 
\begin{displaymath}
\frac{1.5}{3},\quad
\frac{2.4}{1.2},\quad\text{y}\quad
\frac{2}{\sqrt{2}},\quad
\end{displaymath}
será representado como
#+BEGIN_SRC jupyter-python  :exports results  
dmath( Sistema([ sympy.Rational(1.5, 3), fracc(2.4, 1.2), fracc(2, sympy.sqrt(2)) ])  )
#+END_SRC

#+RESULTS:
:RESULTS:
$$\left[ \begin{array}{ccc}\frac{1}{2};& 2;& \sqrt{2};\end{array} \right]$$
:END:

#+name: Método latex general
#+BEGIN_SRC python

def latex(a):
    """Método latex general"""
    try:
        return a.latex()
    except:
        return sympy.latex(a)
    
#+END_SRC

# Con el método =simplifica= se devuelven las expresiones
# simplificadas. Si el objeto es una tupla, lista o =Sistema=, se
# devuelve un objeto del mismo tipo, pero cuyos elementos han sido
# simplificados. Si =self= es otro tipo de objeto, entonces se
# ``sympifica'' con ~sympy.sympify(self)~, es decir, se transforma en un
# objeto del módulo [[https://www.sympy.org/en/index.html][Sympy]] para así poder ser simplificado con el método
# ~sympy.simpify()~.

Para visualizar un objeto en su formato \LaTeX{} definimos el método ~pinta~.

#+name: Pinta un objeto en Jupyter
#+BEGIN_SRC python

def pinta(data):
    """Muestra en Jupyter la representación latex de data"""
    display(Math(latex(data)))

#+END_SRC

Por ejemplo, compárese lo que devuelve ~pinta~
#+BEGIN_SRC jupyter-python :results output replace :results raw
pinta( Vector([sympy.sqrt(2), 0, fracc(3, 4) ]) )
#+END_SRC

#+RESULTS:
$\displaystyle \begin{pmatrix}\sqrt{2}\\ 0\\ \frac{3}{4}\end{pmatrix}$

con lo que devuelve ~print~
#+BEGIN_SRC jupyter-python :results output replace  :results raw
print( Vector([sympy.sqrt(2), 0, fracc(3, 4) ]) ) 
#+END_SRC

#+RESULTS:
Vector([sqrt(2), 0, 3/4])

*** Métodos ~CreaLista~ y ~CreaSistema~

#+name: Método auxiliar CreaLista que devuelve listas
#+BEGIN_SRC python

def CreaLista(t):
    """Devuelve t si t es una lista; si no devuelve la lista [t]"""
    return t if isinstance(t, list) else [t]

#+END_SRC

#+name: Método auxiliar CreaSistema que devuelve sistemas
#+BEGIN_SRC python

def CreaSistema(t):
    """Devuelve t si t es un Sistema; si no devuelve un Sistema que contiene t"""
    return t if isinstance(t, Sistema) else Sistema(CreaLista(t))

#+END_SRC

*** Métodos ~primer_no_nulo~ y ~ultimo_no_nulo~ de un Sistema

#+name: Métodos primer_no_nulo y ultimo_no_nulo de un Sistema
#+BEGIN_SRC python

def primer_no_nulo(s):
    """Primer elemento no nulo en un sistema de sistemas de números"""
    c = [] if es_numero(s) else s.primer_no_nulo()
    return c + primer_no_nulo(CreaSistema(s)|c[0]) if c!=[] else []

def ultimo_no_nulo(s):
    """Primer elemento no nulo en un sistema de sistemas de números"""
    c = [] if es_numero(s) else s.ultimo_no_nulo()
    return c + ultimo_no_nulo(CreaSistema(s)|c[0]) if c!=[] else []

def elementoPivote(s):
    """Primer elemento no nulo"""
    if es_numero(s):
        return s
    elif CreaSistema(s).elementoPivote():
        return elementoPivote(CreaSistema(s).extractor(CreaSistema(s).primer_no_nulo()))
    else:
        None

def elementoAntiPivote(s):
    """Último elemento no nulo"""
    if es_numero(s):
        return s
    elif CreaSistema(s).elementoAntiPivote():
        return elementoAntiPivote(CreaSistema(s).extractor(CreaSistema(s).ultimo_no_nulo()))
    else:
        None

    #+END_SRC

*** Otros métodos auxilares
       :PROPERTIES:
       :header-args+: :noweb-ref Otros métodos auxilares
       :END:

#+BEGIN_SRC python

def particion(s,n):
    """ genera la lista de particionamiento a partir de un conjunto y un número
    >>> particion({1,3,5},7)

    [[1], [2, 3], [4, 5], [6, 7]]
    """
    s = {e for e in s if e<=n}
    p = sorted(list(s | set([0,n])))
    return [ list(range(p[k]+1,p[k+1]+1)) for k in range(len(p)-1) ]
    
#+END_SRC

*** Cribado de secuencias de transformaciones

En el proceso de eliminación, muchas trasformaciones elementales
realmente son identidades (sumar 0 veces otro vector y multiplicar un
vector por 1).

A la hora de representar los pasos de eliminación, normalmente es
mejor omitir estos pasos innecesarios. Definimos un procedimiento
general que quita de una lista de abreviaturas aquellas que son
innecesarias en la representación. Si como argumento se le da una
lista de abreviaturas, devuelve una lista filtrada. Si como argumento
se le da una \texttt{T}ransformación, devuelve una
\texttt{T}ransformación cuya lista de abreviaturas está filtrada.

#+name: Cribado de secuencias de transformaciones
#+BEGIN_SRC python

def filtradopasos(pasos):
    abv = pasos.abreviaturas if isinstance(pasos,T) else pasos
           
    p = [T([j for j in T([abv[i]]).abreviaturas if (isinstance(j,set) and len(j)>1)\
               or (isinstance(j,tuple) and len(j)==3 and j[0]!=0)       \
               or (isinstance(j,tuple) and len(j)==2 and j[0]!=1) ])    \
                                             for i in range(0,len(abv)) ]

    abv = [ t for t in p if t.abreviaturas] # quitamos abreviaturas vacías de la lista
    
    return T(abv) if isinstance(pasos,T) else abv

#+END_SRC


*** COMMENT Simplificación de expresiones simbólicas               :noexport:

#+name: Simplificación de expresiones simbólicas
#+BEGIN_SRC python

def simplifica(self):
    """Devuelve las expresiones simplificadas"""
    if isinstance(self, (list, tuple)):
        return type(self)([ simplifica(e) for e in self ])
    if isinstance(self, Sistema):
        simplifica(self.lista)
        return self
    else:
        return (sympy.sympify(self)).simplify()
    
def simplify(self):
    """Devuelve las expresiones simplificadas"""
    if isinstance(self, (list, tuple)):
        return type(self)([ simplify(e) for e in self ])
    if isinstance(self, Sistema):
        simplify(self.lista)
        return self
    else:
        return (sympy.sympify(self)).simplify()
    
def factor(self):
    """Devuelve las expresiones factorizadas"""
    if isinstance(self, (list, tuple)):
        return type(self)([ factor(e) for e in self ])
    if isinstance(self, Sistema):
        factor(self.lista)
        return self
    else:
        return sympy.factor(self)

#+END_SRC

*** COMMENT Otros trozos de código antiguo descartados             :noexport:

#+BEGIN_SRC python
def latex(self):
    """ Construye el comando LaTeX para representar un Vector"""
    if self.rpr == 'fila' or self.n==1:    
        return r'\begin{pmatrix}' + \
               ',& '.join([latex(e) for e in self]) + \
               r',\end{pmatrix}' 
    else:
        return r'\begin{pmatrix}' + \
               r'\\ '.join([latex(e) for e in self]) + \
               r'\end{pmatrix}'
               
#+END_SRC

#+BEGIN_SRC python
def __str__(self):
    """ Muestra el vector en su representación Python """
    pc = ',' if len(self.lista) else ''
    return '(' + ', '.join( str (e) for e in self ) + pc + ')'
#+END_SRC


#+BEGIN_SRC python

def __invert__(self):
        """
        Devuelve la traspuesta de una matriz.

        Ejemplo:
        >>> ~Matrix([ [1,2,3] ])

        Matrix([ Vector([1, 2, 3]) ])
        """
        M = BlockM([ BlockV([ columna|i for columna in self ]) for i in range(1,self.m+1) ])
        M.corteElementos, M.posicionDivisiones = self.posicionDivisiones, self.corteElementos
        return M

#+END_SRC


#+name: Se guardan los atributos .tex y .pasos y se representan los pasos si se pide
#+BEGIN_SRC python

pasosPrevios = data.pasos if hasattr(data, 'pasos') and data.pasos else [[],[]]
TexPasosPrev = data.tex   if hasattr(data, 'tex')   and data.tex   else []
if repsust:
    self.tex = rprElim(data.subs(sust), pasos, TexPasosPrev, sust)
else:
    self.tex = rprElim(data.subs(sust), pasos, TexPasosPrev)
pasos[0] = pasos[0] + pasosPrevios[0] 
pasos[1] = pasosPrevios[1] + pasos[1]
self.pasos = pasos 
self.TrF = T(pasos[0])
self.TrC = T(pasos[1])
if rep:
    display(Math(self.tex))                                                               

#+END_SRC



****** COMMENT para borrar
#+BEGIN_SRC python
class Eliminacion(Sistema):
    def __init__(self, sistema, TrC=[T([])], TrF=[T([])], rpr='columna'):
        super().__init__(sistema)
        self = sistema.fullcopy()
        self.TrC = TrC
        self.TrF = TrF
        #self.pasos = [self.TrF, self.TrC]
        self.rpr   = rpr
        #super(self.__class__ ,self).__init__(sistema)
        #self.__class__ = type(sistema)

        #super(self.__class__ ,self).__init__(sistema)
        #return type(sistema)(self.sis())
    
    # def __repr__(self):
    #     """ Muestra los pasos de eliminación en su representación Python """
    #     return repr(Sistema([T(self.TrF),T(self.TrC)]))
    # 
    # def _repr_html_(self):
    #     """ Construye la representación para el entorno Jupyter Notebook """
    #     return html(self.latex())
    # 
    # def latex(self):
    #     """ Muestra pasos de eliminación en su representación Python """
    #     return latex(Sistema([T(self.TrF, rpr=self.rpr), T(self.TrC, rpr=self.rpr)]))
        #return latex(T(self.pasos, rpr=self.rpr))
        
#+END_SRC

#+BEGIN_SRC python :noweb no-export
class ElimHaciaAdelante(Eliminacion):
    def __init__(self, sistema, rep=False, sust=[], repsust=False, rpr='v', tipo=0): 
        """Versión pre-escalonada de un sistema por eliminacion Derecha-Izquierda"""
        if not sistema.es_de_composicion_y_longitud_uniforme():
            raise ValueError('Los elementos del sistema deben ser del mismo tipo y longitud')        
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
        <<Dos tipos de operaciones en la reducción. Solo Tipo I o evitando fracciones con tipos I y II>>                
        if tipo in {2,3,6,7,12,13,16,17}:
            componentesAEliminar = lambda x: x != indice
        else:
            componentesAEliminar = lambda x: x > indice

        if tipo in {4,5,6,7,14,15,16,16} and sistema.es_arreglo_rectangular():
            A = ~sistema.fullcopy().subs(sust);
        else:
            A = sistema.fullcopy().subs(sust);
        
        transformaciones = [];
        rango  = 0;
        for indice, elemento in enumerate(A,1):
            coordenadas = primer_no_nulo(elemento);
            pivote      = A.extractor([indice]+coordenadas) if coordenadas else []
            if pivote:
                rango += 1
                op = []
                for posicion in filter(componentesAEliminar, range(1,len(A)+1)):
                    valorAeliminar = A.extractor([posicion]+coordenadas)
                    op = op + operaciones(pivote, indice, valorAeliminar, posicion)
                Tr = T(op)    
                transformaciones += [Tr]  if Tr.abreviaturas else []
                A & Tr
                A = A.subs(sust);

        print(transformaciones)
        if tipo in {4,5,6,7,14,15,16,16}:
            #TrI = filtradopasos(transformaciones)
            TrI = filtradopasos(list(reversed([ ~t for t in transformaciones])))
            TrD = [] #[T([])]
            if sistema.es_arreglo_rectangular():
                A = ~A
        else:
            TrD = filtradopasos(transformaciones)
            TrI = [] # [T([])]
            
        self.rpr = rpr

        #self.TrC = transformaciones
        #self.TrF = [T([])]
        #pasos = [[T([])], transformaciones]

        pasos = [TrI,TrD]
        
        #A.tex, A.pasos, A.TrC, A.TrI = rprPasosElim(sistema, TrD, TrI, rep, sust, repsust)
        A.tex, A.pasos, A.TrF, A.TrC = texYpasos(sistema, rep, sust, repsust)
        #data = sistema.fullcopy()
        #pasos = [[], transformaciones]
        #pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        #K = A.fullcopy()
        #K.tex, K.pasos, K.TrF, K.TrC = texYpasos(data, rep, sust, repsust)
        #K.rango = rango
        return A
    
    def rangoSistema(self):
        return rango
    
def rprPasosElim(sistema, TrD=[T([])], TrI=[T([])], rep=False, sust=[], repsust=False):
    pasos = [TrI,TrD]
    pasosPrevios = sistema.pasos if hasattr(sistema, 'pasos') and sistema.pasos else [[],[]]
    TexPasosPrev = sistema.tex   if hasattr(sistema, 'tex')   and sistema.tex   else []
    if repsust:
        tex = rprElim(sistema, pasos, TexPasosPrev, sust)
    else:
        tex = rprElim(sistema, pasos, TexPasosPrev)
    pasos[0] = TrI + pasosPrevios[0] 
    pasos[1] = pasosPrevios[1] + TrD
    
    TrD = T(pasos[1])
    TrI = T(pasos[0])
    
    if rep:
        display(Math(tex))
    
    return [tex, pasos, TrD, TrI]
#+END_SRC
   
#+BEGIN_SRC python :noweb no-export
class ElimHaciaDetras(Eliminacion):
    def __init__(self, sistema, rep=False, sust=[], repsust=False, rpr='v'): 
        """Versión pre-escalonada de un sistema por eliminacion Derecha-Izquierda"""
        if not sistema.es_de_composicion_y_longitud_uniforme():
            raise ValueError('Los elementos del sistema deben ser del mismo tipo y longitud')
        
        <<Método que define los atributos .tex y .pasos y representa los pasos si se pide>>
        celim = lambda x: x < indice
        A = sistema.fullcopy().subs(sust);       
        
        transformaciones = [];
        rango  = 0;

        #for indice, elemento in reversed(list(enumerate(A,1))):
        #    coordenadas = ultimo_no_nulo(elemento);
        #    pivote      = A.extractor([indice]+coordenadas)
        #    if pivote:
        #        rango += 1
        #        op = []
        #        for j in filter(celim, range(1,len(A)+1)):
        #            aEliminar = A.extractor([j]+coordenadas)
        #            op = op + [( denom(aEliminar, pivote),         j), \
        #                       (-numer(aEliminar, pivote), indice, j)  ]
        #        Tr = T(op)    
        #        transformaciones += [Tr]  if Tr.abreviaturas else []
        #        A & Tr
        #        A = A.subs(sust);

        #self.pasos = transformaciones

        self.pasos = A.EliminacionDerechaIzquierda(rep,sust,repsust).pasos

        self.rpr = rpr
        
        data = sistema.fullcopy()
        #pasos = [[], transformaciones]
        #pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        #K = A.fullcopy()
        #K.tex, K.pasos, K.TrF, K.TrC = texYpasos(data, rep, sust, repsust)
        #K.rango = rango
        #return K
    def rangoSistema(self):
        return rango

    
#+END_SRC

*** COMMENT  Literate programming con noweb                       :noexport:
  :PROPERTIES:  
  :UNNUMBERED: t  
  :END:  

Este documento está escrito usando
\href{https://en.wikipedia.org/wiki/Noweb}{noweb}. Es una herramienta
que permite escribir a la vez tanto código como su documentación. El
código se escribe a trozos o ``chunks'' como por ejemplo este:

#+name: Chunk de ejemplo que define la lista ~a~
#+BEGIN_SRC python :noweb tangle 
a = ["Matemáticas II es mi asignatura preferida", "Python mola", 1492, "Noweb"]
#+END_SRC
y este otro chunk:
#+name: Segundo chunk de ejemplo que cambia el último elemento de la lista ~a~
#+BEGIN_SRC python :noweb tangle 
a[-1] = 10
#+END_SRC
Cada chunk recibe un nombre (que yo uso para describir lo que hace el
código dentro del chunk). Lo maravilloso de este modo de
programar es que dentro de un chunk se pueden insertar otros
chunks. Así, podemos programar el siguiente guión de Python
(~EjemploLiterateProgramming.py~) que enumera los elementos de
una tupla y después hace unas sumas:
#+name: EjemploLiterateProgramming.py 
#+BEGIN_SRC python :noweb tangle :tangle EjemploLiterateProgramming.py
<<Chunk de ejemplo que define la lista ~a~>>
<<Segundo chunk de ejemplo que cambia el último elemento de la lista ~a~>>

for indice, item in enumerate(a, 1):
    print (indice, item)

<<Chunk final que indica qué tipo de objeto es ~a~ y hace unas sumas>>

#+END_SRC
Este modo de escribir el código permite destacar unas partes y pasar
por alto otras.  Por ejemplo, del chunk del recuadro de arriba me
interesa que se vea el código del /bucle que permite enumerar los
elementos de una lista/. Lo demás es accesorio y se puede consultar en
los correspondientes chunks. Como el nombre de dichos chunks es
auto-explicativo, mirando el recuadro anterior es fácil hacerse una
idea de que hace el programa =EjemploLiterateProgramming.py=' en su
conjunto.

# Fíjese que el número al final del nombre de cada chunk corresponde a
# la página donde se puede consultar su código. Por ejemplo, el último
# chunk de este ejemplo se encuentra en la
# Página~\pageref{subsec:ultimoChunkEjemploLiterateProgramming} de este
# documento. 

El código completo del ejemplo usado para explicar cómo funciona el
``Literate Programming'' queda así:

# \begin{codigo}[nobreak=true]
# \verbatiminput{nacal/EjemploLiterateProgramming.py}
# \end{codigo}


#+begin_export latex
\newpage 
#+end_export


#+BEGIN_SRC python

posicionXPivote = lambda componente: primer_no_nulo(componente)
recorrido        = lambda    sistema: enumerate(CreaSistema(sistema),1)
mitad            = lambda   M, rango: M|slice(None,rango)
otraMitad        = lambda   M, rango: M|slice(rango+1,None)
pegaMitades      = lambda  una, otra: una.concatena(otra)
destino          = lambda   M, r, rg: r+rg
destinoLocal     = lambda   M, r    : r
origen           = lambda      cp,rg: cp[0]+rg
origenLocal      = lambda      cp   : cp[0]


#posicionXPivote = lambda componente: ultimo_no_nulo(componente)
#recorrido        = lambda    sistema: reversed(list(enumerate(CreaSistema(sistema),1)))
#mitad            = lambda   M, rango: M|slice((M.n)-rango+1,None)
#otraMitad        = lambda   M, rango: M|slice(None,(M.n)-rango)
#pegaMitades      = lambda  una, otra: otra.concatena(una)
#destino          = lambda   M, r, rg: (M.n)-r-rg+1
#destinoLocal     = lambda   M, r    : (M.n)-r+1
#origen           = lambda      cp,rg: cp[0]+rg
#origenLocal      = lambda      cp   : cp[0]


def escalona(M, pasos = [], rg=0):
    def columna_a_mover(fila):
        Ind_columna = posicionXPivote(fila)
        return Ind_columna if Ind_columna and i<= posicionXPivote(M|Ind_columna[0])[0] else []
    
    #def columna_a_mover(fila):
    #    Ind_columna = posicionXPivote(fila)
    #    return Ind_columna if Ind_columna and i>= posicionXPivote(M|Ind_columna[0])[0] else []
        
    r = 0
    for i,_ in recorrido(M|1):
        cp = columna_a_mover(i|M)
        if cp:
            r += 1
            pasos.append(filtradopasos(T({destino(M,r,rg),origen(cp,rg)})))
            M & T({destinoLocal(M,r),origenLocal(cp)})
            
        elif CreaSistema(i|otraMitad(M,r)).no_es_nulo():
            rg += 1
            otraMitadEscalonada, pasos = escalona(otraMitad(M,r), pasos, rg)
            M = pegaMitades(mitad(M,r), otraMitadEscalonada)
            
    return M, filtradopasos(pasos)

#+END_SRC



