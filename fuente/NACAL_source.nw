% -*- mode: Noweb; noweb-code-mode: python-mode -*-
\documentclass[10pt,a4paper]{report}
%\documentclass[10pt,a4paper]{book}

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\renewcommand{\chaptername}{Capítulo}
\renewcommand*\contentsname{Índice}
% \usepackage[spanish]{babel}
%\unaccentedoperators
\usepackage[pdftex]{graphicx}
\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{noweb}
\noweboptions{longchunks,longxref}
%\noweboptions{longxref}
\usepackage[colorlinks=true,linkcolor=OliveGreen,urlcolor=blue!25!black!45!red]{hyperref}

%\pagestyle{noweb}
%\noweboptions{longchunks,smallcode,longxref}
%\noweboptions{longchunks,smallcode}

\usepackage{amsfonts,amssymb,amsmath,amsthm,amscd,amsopn}
\newtheorem{lem}{Lemma}

\usepackage{fancyvrb} 

% \usepackage{attachfile} \attachfilesetup{color = .3 0 1, mimetype= text/plain}

% \usepackage[a4paper,hscale=0.8,vscale=0.88,tmargin=2.5cm]{geometry}
\usepackage[cm,headings]{fullpage}
\usepackage{verbatim}
\usepackage{paralist}
\usepackage{booktabs}

\usepackage{relsize}
\usepackage{tikz}

\usepackage[framemethod=tikz]{mdframed}
\mdfsetup{skipabove=12pt,skipbelow=-3pt}

\def\notmat2{Notación en Mates 2}
\tikzset{titregris/.style =
       {draw=blue!30!black!70!green, thick, fill=white, shading = exersicetitle, %
        text=blue!30!black!50!green, rectangle, rounded corners, right,minimum height=.7cm}}
\pgfdeclarehorizontalshading{exersicebackground}{100bp}
              {color(0bp)=(gray!5); color(100bp)=(gray!5)}
%              {color(0bp)=(green!40); color(100bp)=(black!5)}
\pgfdeclarehorizontalshading{exersicetitle}{100bp}
              {color(100bp)=(black!5);color(0bp)=(gray!40)}
%              {color(0bp)=(red!40);color(100bp)=(black!5)}

\pgfdeclarehorizontalshading{not2background}{100bp}
              {color(0bp)=(green!5); color(100bp)=(green!5)}
%              {color(0bp)=(green!40); color(100bp)=(black!5)}

\makeatletter
\def\mdf@@exercisepoints{}%new mdframed key:
\define@key{mdf}{exercisepoints}{%
     \def\mdf@@exercisepoints{#1}
}

\mdfdefinestyle{codestyle}{%
  outerlinewidth=3em,%                %% PONER A CERO EN LA VERSIÓN FINAL
  outerlinecolor=white,%
  leftmargin=-1em,rightmargin=-1em,%
  middlelinewidth=1.2pt,roundcorner=4pt,linecolor=gray,
  apptotikzsetting={\tikzset{mdfbackground/.append style ={%
                                shading = exersicebackground}}},
  innertopmargin=0.5\baselineskip,
  %skipabove={\dimexpr0.5\baselineskip+\topskip\relax},
  skipabove=2pt,skipbelow=-2pt,
  %skipabove={\dimexpr-9.4\baselineskip+\topskip\relax},
  %skipbelow={-1em},
  needspace=0\baselineskip,
  frametitlefont=\sffamily\bfseries,
  fontcolor=blue,
  settings={\global},
  % singleextra={%
  %       \node[titregris,xshift=1cm] at (P-|O) %
  %           {\mdf@frametitlefont{\notmat2}\hbox{}};
  %       {}%
  %       {}%
  %   },
}
\makeatother

\newenvironment{codigo}[1][]{ %
  \begin{mdframed}[style=codestyle,#1]
    % [roundcorner=10pt,fontcolor=gray] %[linecolor=blue,middlelinewidth=2]
    % [default] [roundcorner=10pt,ntheorem=true] %frametitle=Variantes,
    %\begin{quotation}
      % \footnotesize
      \small \sf
      %\noindent 
      }
      {
    %\end{quotation}
  \end{mdframed}%\vspace{5pt}
}

\makeatletter
\mdfdefinestyle{exercisestyle}{%
  outerlinewidth=1em,outerlinecolor=white,%
  leftmargin=-1em,rightmargin=-1em,%
  middlelinewidth=1.2pt,roundcorner=5pt,linecolor=blue!30!black!50!green,
  apptotikzsetting={\tikzset{mdfbackground/.append style ={%
                                shading = not2background}}},
  innertopmargin=1.2\baselineskip,
  skipabove={\dimexpr0.5\baselineskip+\topskip\relax},
  skipbelow={-1em},
  needspace=3\baselineskip,
  frametitlefont=\sffamily\bfseries,
  fontcolor=black,
  settings={\global},
  singleextra={%
        \node[titregris,xshift=1cm] at (P-|O) %
            {\mdf@frametitlefont{\notmat2}\hbox{}};
        {}%
        {}%
    },
}
\makeatother

\newenvironment{NotMat2}{ %
  \begin{mdframed}[style=exercisestyle,nobreak=true]%[roundcorner=10pt,fontcolor=gray] %[linecolor=blue,middlelinewidth=2] %[default] [roundcorner=10pt,ntheorem=true] %frametitle=Variantes,
    \begin{quotation}
      %\footnotesize
      \noindent
      %\textsl{Variantes}:
      %\begin{itemize}
      }
      { %
      %\end{itemize}
    \end{quotation}
  \end{mdframed}}

\def\TutJupyter{Tutorial previo en un Jupyter notebook}
\tikzset{tittut/.style =                                %% TITULO RECUADRADO                                        
       {draw=black, thick, fill=white, 
        text=black, rectangle, rounded corners, right,minimum height=.7cm}}
\makeatletter
\mdfdefinestyle{notebookstyle}{%
  outerlinewidth=1em,outerlinecolor=white,%
  leftmargin=-1em,rightmargin=-1em,
  middlelinewidth=2, roundcorner=4pt, linecolor=gray, %blue!30!black!50!green,
  % apptotikzsetting={\tikzset{mdfbackground/.append style ={%
  %                               shading = exersicebackground}}},
  innertopmargin=1.2\baselineskip,
  %skipabove={\dimexpr0.1\baselineskip+\topskip\relax},
  %skipbelow={-1em},
  needspace=3\baselineskip,
  frametitlefont=\sffamily\bfseries,
  fontcolor=black,
  settings={\global},
  singleextra={%
        \node[tittut,xshift=1cm] at (P-|O) %
            {\mdf@frametitlefont{\TutJupyter}\hbox{}};
        {}%
        {}%
    },
}
\makeatother

\newenvironment{notebook}{ %
  \begin{mdframed}[style=notebookstyle]%[roundcorner=4pt,fontcolor=blue,linecolor=gray,middlelinewidth=2,frametitle=Tutorial previo en un notebook,nobreak=true] %[linecolor=blue,middlelinewidth=2] %[default] [roundcorner=10pt,ntheorem=true] %frametitle=Variantes,
    \begin{quotation}
      % \small
      % \noindent
    }
    { 
    \end{quotation}
  \end{mdframed}}

\def\Jupyter{Notebooks de Jupyter que muestran el uso de la librería \texttt{nacal}}
\tikzset{tittut/.style =                                %% TITULO RECUADRADO                                        
       {draw=black, thick, fill=white, 
        text=black, rectangle, rounded corners, right,minimum height=.7cm}}
\makeatletter
\mdfdefinestyle{Notebookstyle}{%
  outerlinewidth=1em,outerlinecolor=white,%
  leftmargin=-1em,rightmargin=-1em,
  middlelinewidth=2, roundcorner=4pt, linecolor=gray, %blue!30!black!50!green,
  % apptotikzsetting={\tikzset{mdfbackground/.append style ={%
  %                               shading = exersicebackground}}},
  innertopmargin=1.2\baselineskip,
  %skipabove={\dimexpr0.1\baselineskip+\topskip\relax},
  %skipbelow={-1em},
  needspace=3\baselineskip,
  frametitlefont=\sffamily\bfseries,
  fontcolor=black,
  settings={\global},
  singleextra={%
        \node[tittut,xshift=1cm] at (P-|O) %
            {\mdf@frametitlefont{\Jupyter}\hbox{}};
        {}%
        {}%
    },
}
\makeatother
\newenvironment{Notebook}{ %
  \begin{mdframed}[style=Notebookstyle]%[roundcorner=4pt,fontcolor=blue,linecolor=gray,middlelinewidth=2,frametitle=Tutorial previo en un notebook,nobreak=true] %[linecolor=blue,middlelinewidth=2] %[default] [roundcorner=10pt,ntheorem=true] %frametitle=Variantes,
    \begin{quotation}
      % \small
      % \noindent
    }
    { 
    \end{quotation}
  \end{mdframed}}


\input{00Notacion.tex}
\newcommand{\abs}[1]{\left| #1 \right|}
%\newcommand{\cls}[2]{\overline{#1}_{#2}}
\newcommand{\Rr}{\mathbb R}
\newcommand{\Qq}{\mathbb Q}
%\newcommand{\Zz}{\mathbb Z}
%\newcommand{\Nn}{\mathbb N}

\newcommand{\Kk}{\mathbb K}

\usepackage{array}

\usepackage{amsthm}
\newtheorem{defn}{Definition}[section]
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]

\definecolor{azul}{rgb}{0,0,0.82} % blue 4 de xfig
\definecolor{rojo2}{rgb}{0.56,0,0.56} % red2 de xfig
\definecolor{naranja}{rgb}{1,0.5,0.2} % red2 de xfig
\definecolor{notacion}{rgb}{0,0.488,0} % green 69 de xfig
\definecolor{AZUL}{rgb}{0,0,0.82} % blue 4 de xfig
\definecolor{ROJO2}{rgb}{0.56,0,0.56} % red2 de xfig
\definecolor{NARANJA}{rgb}{1,0.5,0.2} % red2 de xfig
\definecolor{NOTACION}{rgb}{0,0.488,0} % green 69 de xfig

\newcommand{\HLa}[1]{\textcolor{blue}{{#1}}}
\newcommand{\HLb}[1]{\textcolor{naranja}{{#1}}}
\newcommand{\HLc}[1]{\textcolor{rojo2}{{#1}}}
\newcommand{\HLd}[1]{\textcolor{purple}{{#1}}}
\newcommand{\HLr}[1]{\textcolor{red}{{#1}}}
\newcommand{\HLg}[1]{\textcolor{blue!30!black!50!green}{{#1}}}
\newcommand{\HLt}[1]{\textcolor{teal}{{#1}}}
\newcommand{\HLo}[1]{\textcolor{orange}{{#1}}}
\newcommand{\HLp}[1]{\textcolor{OliveGreen}{{#1}}}
\newcommand{\HLol}[1]{\textcolor{olive}{{#1}}}
\newcommand{\HLv}[1]{\textcolor{violet}{{#1}}}
\newcommand{\HLm}[1]{\textcolor{brown}{{#1}}}

\newcommand{\subindex}[1]{\{#1\}}


\newtheorem{teorema}{Teorema}
\newtheorem{corolario}[teorema]{Corolario}
\newtheorem{lema}[teorema]{Lema}
\theoremstyle{definition}
\newtheorem{definicion}[teorema]{Definición}
\newtheorem{notacion}[teorema]{Notación}
\newtheorem{ejemplo}[teorema]{Ejemplo}
\newtheorem{ejemplos}[teorema]{Ejemplos}
\newtheorem{contraejemplo}[teorema]{Contrajemplo}
\theoremstyle{remark}
\newtheorem{observacion}[teorema]{Observación}
\newtheorem{observaciones}[teorema]{Observaciones}

%\newcommand{\trs}[1]{\prescript{\mathfrak{t}}{}{#1}}
%\newcommand{\abs}[1]{\left| #1 \right|}
%\newcommand{\cls}[2]{\overline{#1}_{#2}}
%\newcommand{\Rr}{\mathbb R}
%\newcommand{\Qq}{\mathbb Q}
%\newcommand{\Zz}{\mathbb Z}
\newcommand{\Nn}{\mathbb N}

% \newcommand{\Kk}{\mathbb K}
%\newcommand{\domvarphi}{\dom(\varphi)}

%\DeclareMathOperator{\mcd}{mcd}
%\DeclareMathOperator{\mcm}{mcm}
%\DeclareMathOperator{\codeg}{codeg}
%\DeclareMathOperator{\fraci}{Frac}
%\DeclareMathOperator{\modu}{mod}

%%%\newcommand{\mat}[1]{\mathbf{#1}} 
\newcommand{\blockmat}[1]{\boxed{\mathbf{#1}}}
%\newcommand{\prt}[1]{\stackrel{#1}{\Box}}
\newcommand{\cor}[2]{\underset{#2}{(#1)}}
\newcommand{\sel}[1]{\underset{#1}{\ast}}
\newcommand{\e}[2]{\vec{e}_{#1}^{#2}}
\newcommand{\vecnul}[1]{\vec{0}^{#1}}

%\newcommand{\trasE}[1]{\underset{#1}{\intercal}}
%\renewcommand{\pe}[2]{[{#1}\rightleftharpoons{#2}]}
%\renewcommand{\pr}[2]{[({#2})\cdot {#1}]}
%\renewcommand{\su}[3]{[{#1} + ({#3})\cdot {#2}]}
%\newcommand{\pr}[2]{[{#1}\gets ({#2})\cdot {#1}]}
%\newcommand{\su}[3]{[{#1}\gets {#1} + ({#3})\cdot {#2}]}

%\newcommand{\trasE}[1]{\underset{#1}{\pmb{\tau}}}
\newcommand{\trasE}[1]{\TrE{#1}}
%\renewcommand{\pe}[2]{[\pmb{#1}\rightleftharpoons\pmb{#2}]}
%\renewcommand{\pr}[2]{[\pmb{#2}\cdot {#1}]}
%\renewcommand{\su}[3]{[\pmb{#1} + {#3}\cdot \pmb{#2}]}

\title{\mbox{Notación Asociativa para un Curso de Álgebra Lineal (NACAL)}\\
  {\footnotesize (Versión: \input{version.txt})}\\
  {\footnotesize \url{https://github.com/mbujosab/nacallib}}}
\author{Marcos Bujosa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\tableofcontents

\cleardoublepage
\phantomsection
\section*{Declaración de intenciones}
\thispagestyle{empty}
\addcontentsline{toc}{section}{Declaración de intenciones}
Uno de los objetivos que me he propuesto para el curso Matemáticas II
(Álgebra Lineal) es mostrar que escribir matemáticas y usar un
lenguaje de programación son prácticamente la misma cosa. Este modo de
proceder debería ser un ejercicio muy didáctico ya que:
\begin{quotation}
  \noindent
  \emph{Un PC es muy torpe y se limita a ejecutar literalmente
    lo que se le indica (un PC no interpreta interpolando para
    intentar dar sentido a lo que se le dice... eso lo hacemos las
    personas, pero no los ordenadores).}
  \par
  
  \emph{Así, este ejercicio impone una disciplina a la que en general
    no estamos acostumbrados: \emph{el ordenador hará lo que queremos
      solo si las expresiones tienen sentido e indican correctamente
      lo que queremos.} Si el ordenador no hace lo que queremos, será
    porque que no hemos escrito las ordenes de manera correcta (lo que
    supone que también hemos escrito incorrectamente las expresiones
    matemáticas).}
\end{quotation}


Con esta idea en mente:
\begin{enumerate}
\item La notación empleada pretende ser operativa; es decir, su uso es
  directamente traducible en operaciones a realizar por un
  ordenador. Para lograr una mayor simplificación, la notación explota
  de manera intensiva la asociatividad.

\item Muchas de las demostraciones de las notas de clase son
  algorítmicas. En particular las relacionadas con la eliminación
  Gaussiana. De esta manera, las demostraciones describen literalmente
  la programación de los correspondientes algoritmos.
\end{enumerate}

\subsubsection*{Una librería de Python específica para la asignatura}
Aunque Python dispone de librerías para operar con vectores y
matrices, \emph{nosotros escribiremos nuestra propia librería}. Así
lograremos que la notación de las notas de clase y las expresiones
empleadas en la librería de Python se parezcan lo más posible.
\begin{center}
  \HLa {\textsc{Este documento describe tanto el uso de la librería
      como su código; pero tenga en cuenta que esto no es un
      \href{https://docs.python.org/es/3/tutorial/index.html}{tutorial
        de Python}.}}
\end{center}
No obstante, he escrito unos notebooks de Jupyter que ofrecen unas
breves nociones de programación en Python (aunque muy
incompletas). Tenga en cuenta que hay muchos cursos y material
disponible en la web para aprender Python y que mi labor es enseñar
Álgebra Lineal (no Python).  \bigskip

Para subrayar el paralelismo entre las definiciones dadas en las
\href{https://github.com/mbujosab/CursoDeAlgebraLineal/blob/master/ES-Mat2-print.pdf}
{notas de la asignatura} y los objetos (o [[Clases]]) definidos en la
librería, las partes auxiliares del código se relegan al
final\footnote{aquellas que tienen que ver con la comprobación de que
  los inputs de las funciones son adecuados, con otras formas
  alternativas de instanciar clases, con la representación de objetos
  en Jupyter usando código \LaTeX, etc.}  (véase la sección
\emph{Literate programming} en la
Página~\pageref{sec:LiterateProgramming}). Destacar las partes
centrales del código permitirá apreciar cómo las definiciones de las
notas de la asignatura son implementadas de manera literal en la
librería de Python.  \bigskip

\begin{notebook}
  \begin{center}
    Antes de seguir, repase el Notebook
    %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F01_ListasYTuplas.ipynb}{\textbf{``Listas y tuplas''}}
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F01_ListasYTuplas.ipynb}{\textbf{``Listas y tuplas''}}
      en la carpeta
     % \href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F}{``TutorialPython''}
      \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F}{``TutorialPython''}
      en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython}
      %\url{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master}
      %\url{https://notebooks.gesis.org/binder/jupyter/user/mbujosab-nacallib-dwb8caok/tree/doc/Notebooks/TutorialPython}
  \end{center}
\end{notebook}
\bigskip

Y recuerde que \textbf{¡hacer matemáticas y programar son
  prácticamente la misma cosa!}
\vspace{1cm}

\begin{flushright}
  Marcos Bujosa\qquad\mbox{\qquad}
\end{flushright}

\thispagestyle{empty}

\cleardoublepage
\thispagestyle{empty}

\chapter[Código principal de la librería]{Código principal. La clase \texttt{Sistema}.
  Las subclases \texttt{Vector} y \texttt{Matrix}, y la clase \texttt{T}}
\label{part:CodigoPrincipal}
\begin{notebook}
  \begin{center}
    Antes de seguir, mírese el Notebook referente a
    %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F02_Clases.ipynb}{\textbf{``Clases''}}
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F02_Clases.ipynb}{\textbf{``Clases''}}
      en la carpeta
      %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F}{``TutorialPython''}
      \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F}{``TutorialPython''}
      en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython}
      %\url{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master}
      %\url{https://gesis.mybinder.org/binder/v2/gh/mbujosab/nacallib/0fe80d75a75956153b969bc5a5770e4e72a1619a}
      %\url{https://notebooks.gesis.org/binder/jupyter/user/mbujosab-nacallib-dwb8caok/tree/doc/Notebooks/TutorialPython}
  \end{center}
\end{notebook}
Con lo visto en el Notebook anterior, definimos una \emph{clase} para
los \emph{sistemas} (listas ordenadas) con el nombre de
[[Sistema]]. También definiremos una subclase para los \emph{vectores}
y otra para las \emph{matrices}. Además definiremos una clase para las
\emph{transformaciones elementales} y otra para las \emph{matrices por
  bloques} (o matrices particionadas)~\footnote{Más delante
  definiremos nuevas clases para los subespacios vectoriales, los
  espacios afines, etc.}.  Cada vez que definamos una nueva clase,
especificaremos su modo de representación para que los Notebooks de
Jupyter muestren representaciones semejantes a las empleadas en las
notas de la asignatura.

\section{La clase \texttt{Sistema}}

En las notas de la asignatura se dice que
\begin{center}
  Un \HLa{\emph{sistema}} es una ``lista'' de objetos.
\end{center}
Aunque Python ya posee ``listas'', vamos a crear nuestra propia clase
denominada \texttt{[[Sistema]]}. En las notas de la asignatura los
sistemas genéricos se muestran entre \emph{corchetes} y con los
elementos de la lista \emph{separados por ``;''}.~\footnote{Aunque los
  vectores y las matrices también son sistemas, emplean
  representaciones particulares.}  Así,
\begin{center}
  \texttt{[[Sistema( [ Vector([1,2,3]), I(2), 1492, T({1,2}) ] )]]}
\end{center}
será representado en los Notebooks de Jupyter como:
\begin{displaymath}
  \left[\begin{pmatrix}1\\2\\3\end{pmatrix};\;\begin{bmatrix}1&0\\0&1\end{bmatrix};\;1492;\;
      \underset{\left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]}{\mathbf{\tau}}\right]
  %\left[\underset{\left[\left(5\right)\mathbf{4}\right]}{\mathbf{\tau}};\;\underset{\left[\left(2\right)\mathbf{3}\right]}{\mathbf{\tau}};\;\underset{\left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]}{\mathbf{\tau}}\right]
\end{displaymath}
La clase [[Sistema]] solo posee un atributo llamado [[lista]], que es
una [[list]] de Python con la lista de objetos que componen el
[[Sistema]]. Además, \emph{los elementos del [[Sistema]] serán
  mostrados con su propia representación especial en los notebooks de
  Jupyter} (como en el ejemplo anterior donde vemos un vector de
\R[3], la matriz identidad 2 por 2, un número y una transformación
intercambio entre los vectores 1 y 2).

Los \texttt{[[Sistema]]}s y las [[list]]as de Python se diferencian en
dos cosas: la representación de los objetos contenidos en las listas,
y en el modo de concatenar las listas: las [[list]]as de Python se
concatenan con ``+'' y los [[Sistema]]s con el método
[[concatena()]]. Así reservamos el símbolo ``+'' para sumar
[[Sistema]]s tal como se hace en Álgebra Lineal. Con ello buscamos que
lo que veamos y escribamos en un Notebook de Jupyter sea lo más
parecido posible a lo que vemos y escribimos en la asignatura de
Álgebra Lineal.

El texto de ayuda de la clase [[Sistema]] es auto-explicativo y será
lo que Python nos muestre cuando tecleemos \texttt{help([[Sistema]])}:
\begin{codigo}
<<Texto de ayuda de la clase [[Sistema]]>>=
"""Clase Sistema

Un Sistema es una lista ordenada de objetos. Los Sistemas se instancian
con una lista, tupla u otro Sistema. 

Parámetros:
    data (list, tuple, Sistema): lista, tupla o Sistema de objetos.

Atributos:
    lista (list): lista de objetos.

Ejemplos:
>>> # Crea un nuevo Sistema a partir de una lista, tupla o Sistema

>>> Sistema( [ 10, 'hola', T({1,2}) ]  )           # con lista
>>> Sistema( ( 10, 'hola', T({1,2}) )  )           # con tupla
>>> Sistema( Sistema( [ 10, 'hola', T({1,2}) ] ) ) # con Sistema

[10; 'hola'; T({1, 2})]
"""
@
\end{codigo}


\subsubsection{Implementación de los sistemas (o listas ordenadas) en la clase \texttt{Sistema}}
\paragraph{Método de inicialización} Comenzamos la clase con el método
de inicio: \verb/def __init__(self, ... )/.
\begin{itemize}
\item [[data]] es el único argumento (o parámetro) de la clase
  [[Sistema]]. Puede ser una lista, tupla o [[Sistema]].
  
\item Añadimos un breve texto de ayuda sobre el método \Verb/__init__/
  que Python mostrará con: \Verb/help Sistema.__init__/
  
\item Cuando [[data]] es una lista, tupla o [[Sistema]], el atributo
  {\tt self.lista} guarda una copia de la lista, o la tupla convertida
  en lista, o una copia del atributo [[lista]] del [[Sistema]] dado.

\item Cuando [[data]] no es una lista, tupla, o [[Sistema]] se
  devuelve un mensaje de error.
\end{itemize}
\begin{codigo}[nobreak=true] 
<<Inicialización de la clase [[Sistema]]>>=
def __init__(self, data):
    """Inicializa un Sistema con una lista, tupla o Sistema"""                        
    if isinstance(data, (list, tuple, Sistema)):
                        
        self.lista = list(data)
                        
    else:
        raise ValueError(' El argumento debe ser una lista, tupla, o Sistema.')

@
\end{codigo}
Un [[Sistema]] será como una [[list]] de Python (salvo por la
representación y el modo de concatenar).

Para que un [[Sistema]] sea iterable necesitamos los procedimientos
``mágicos'' [[__getitem__]], que permite seleccionar componentes del
sistema, y [[__setitem__]], que permite modificar componentes del
[[Sistema]]~\footnote{¡Recuerde que los índices de las listas
  comienzan en [[0]]! Mantendremos este ``pythonesco'' modo de indexar
  los [[Sistema]]s, aunque luego añadiremos un modo de seleccionar
  componentes similar al empleado en las notas de la asignatura
  empleando el operador selector ``[[|]]''.}.
\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[Sistema]] para que actúe como si fuera una [[list]] de Python>>=  
def __getitem__(self,i):
    """ Devuelve el i-ésimo coeficiente del Sistema """
    return self.lista[i]

def __setitem__(self,i,value):
    """ Modifica el i-ésimo coeficiente del Sistema """
    self.lista[i]=value
        
@
\end{codigo}
Con [[len]] contamos el número de elementos del [[Sistema]]. Con
[[copy]] podemos hacer una copia, por ejemplo [[Z=Y.copy()]] hace una
copia del [[Sistema]] \SV{Y} (aunque lograremos el mismo resultado con
[[Z=Sistema(Y)]]). Por otra parte, comprobaremos si dos [[Sistema]]s
son iguales con ``[[==]]'', y si son distintos con ``[[!=]]''. Por
último, con el método [[reversed]] obtenemos el [[Sistema]] cuyos
elementos aparecen en el orden inverso.
\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[Sistema]] para que actúe como si fuera una [[list]] de Python>>=         
def __len__(self):
    """Número de elementos del Sistema """
    return len(self.lista)

def copy(self):
    """ Copia la lista de otro Sistema"""
    return type(self)(self.lista.copy())
        
def __eq__(self, other):
    """Indica si es cierto que dos Sistemas son iguales"""
    return self.lista == other.lista

def __ne__(self, other):
    """Indica si es cierto que dos Sistemas son distintos"""
    return self.lista != other.lista

def __reversed__(self):
    """Devuelve el reverso de un Sistema"""
    return type(self)(list(reversed(self.lista)))
    
@
\end{codigo}
Por último (y a diferencia de las [[list]] de Python) concatenamos dos
[[Sistema]]s con el método [[concatena()]]. Así, \Verb/A.concatena(B)/
añade al final de la [[lista]] del sistema \SV{A} los elementos de la
[[lista]] del sistema \SV{B}.
\begin{codigo}
<<Método de la clase [[Sistema]] para concatenar dos [[Sistema]]s>>=  
def concatena(self,other):
    """ Concatena dos Sistemas """
    if not isinstance(other, Sistema):
        raise ValueError('Un Sistema solo se puede concatenar a otro Sistema')
    return type(self)(self.lista + other.lista)

@ %def concatena
\end{codigo}
\dots de este modo reservamos el símbolo ``+'' para las sumas elemento
a elemento entre dos sistemas (por ejemplo para sumar dos [[Vector]]es).

\paragraph{La clase \texttt{Sistema}} junto con el listado de sus
métodos aparece en el siguiente recuadro:
\begin{codigo}[nobreak=true] 
<<Definición de la clase [[Sistema]]>>=
class Sistema:
    <<Texto de ayuda de la clase [[Sistema]]>>
    <<Inicialización de la clase [[Sistema]]>>
    <<Métodos de la clase [[Sistema]] para que actúe como si fuera una [[list]] de Python>>
    <<Método de la clase [[Sistema]] para concatenar dos [[Sistema]]s>>
    <<Método para recuperar el [[Sistema]] de cualquier subclase de [[Sistema]]>>
    <<Operador selector por la derecha para la clase [[Sistema]]>>
    <<Suma y resta de [[Sistema]]s>>
    <<Opuesto de un [[Sistema]]>>
    <<Producto de un [[Sistema]] por un escalar a su izquierda>>
    <<Producto de un [[Sistema]] por un escalar, un [[Vector]] o una [[Matrix]] a su derecha>>
    <<Transformaciones elementales de los elementos de un [[Sistema]]>>
    <<Métodos de representación de la clase [[Sistema]]>>
    <<Comprobación de que todos los elementos de un [[Sistema]] son del mismo tipo>>
    <<Comprobación de que un [[Sistema]] es nulo>>
    <<Junta una lista de [[Sistema]]s en un único [[Sistema]]>>
    <<Sustitución de un símbolo por un valor en un [[Sistema]]>>
@ %def Sistema
\end{codigo}
\subsubsection*{Resumen}
\label{resumen:Vector}
Los [[Sistema]]s almacenan una lista de objetos en su atributo
[[lista]]. Los sistemas se comportan como las [[list]] de Python salvo
por su representación y el modo de concatenar.
\medskip

El resto de métodos de la clase [[Sistema]] se describen en secciones
posteriores (detrás del nombre de cada ``trozo de código'' aparece el
número de página donde encontrarlo).

\newpage
\subsection{La subclase \texttt{Vector}}
En las notas de la asignatura se dice que
\begin{center}
  Un \HLa{\emph{vector}} de \R[n] es un ``sistema'' de $n$ números reales;
\end{center}
y dicho sistema se muestra entre paréntesis, bien en forma de fila:
\begin{displaymath}
  \;\Vect{v}=(v_1,\ldots,v_n),\;
\end{displaymath}
o bien en forma de columna:
\begin{displaymath}
 \quad \Vect{v}=\begin{pmatrix}v_1\\ \vdots \\ v_n\end{pmatrix}.
\end{displaymath}

Así pues, vamos a definir una nueva clase de objeto en Python: la
clase [[Vector]] será una subclase de [[Sistema]]. De esta manera la
subclase [[Vector]] hereda todas las propiedades de la clase \emph{madre}
[[Sistema]].  La [[<<Representación de la clase [[Vector]]>>]] se
redefine más adelante, así los [[Vector]]es no serán representados
como [[Sistema]]s genéricos, sino a la manera de los vectores.

El texto de ayuda de la clase [[Vector]] es auto-explicativo; y Python
nos lo mostrará cuando tecleemos \texttt{help([[Vector]])}:
\begin{codigo}
<<Texto de ayuda de la clase [[Vector]]>>=
"""Clase Vector(Sistema)

Vector es un Sistema de números u objetos de la librería Sympy. Se puede
instanciar con una lista, tupla o Sistema. Si se instancia con un Vector
se crea una copia del mismo. El atributo 'rpr' indica al entorno Jupyter 
si el vector debe ser escrito como fila o como columna.

Parámetros:
    sis (list, tuple, Sistema, Vector) : Lista, tupla o Sistema de 
        objetos de tipo int, float o sympy.Basic, o bien otro Vector.
    rpr (str) : Representación en Jupyter ('columna' por defecto).
    	Si rpr='fila' el vector se representa en forma de fila. 

Atributos:
    n     (int)    : número de elementos de la lista.
    rpr   (str)    : modo de representación en Jupyter.

Atributos heredados de la clase Sistema:
    lista (list)   : list con los elementos.

Ejemplos:
>>> # Instanciación a partir de una lista, tupla o Sistema de números
>>> Vector( [1,2,3] )           # con lista
>>> Vector( (1,2,3) )           # con tupla
>>> Vector( Sistema( [1,2,3] ) )# con Sistema
>>> Vector( Vector ( [1,2,3] ) )# a partir de otro Vector

Vector([1,2,3])
"""        
@
\end{codigo}
\subsubsection{Implementación de los vectores en la clase \texttt{Vector}}
\paragraph{Método de inicialización:}  \verb/def __init__(self, data, rpr='columna')/.
\begin{itemize}
\item La clase [[Vector]] emplea dos argumentos. El primero ([[data]])
  es una lista, tupla o [[Sistema]] de objetos tipo [[int]], [[float]]
  o [[sympy.Basic]]. El segundo argumento ([[rpr]]) es opcional e
  indica si queremos que el entorno
  \href{https://jupyter.org/}{Jupyter Notebook} represente el vector
  en forma horizontal o en vertical. Si no se indica nada, se asumirá
  que la representación del vector es en vertical
  (\verb/rpr='columna'/). Cuando [[data]] es un [[Vector]] (es decir,
  un [[Sistema]] de números) se obtiene una copia.
  \medskip
  
\item Añadimos un breve texto de ayuda sobre el método \Verb/__init__/
  que Python mostrará con: \Verb/help Vector.__init__/\medskip

\item Con \Verb/super().__init__(data) / la subclase [[Vector]] hereda
  los métodos y atributos de la clase \emph{madre} [[Sistema]] (por
  tanto, [[Vector]] tendrá un atributo [[lista]], así como todos los
  métodos definidos para la clase [[Sistema]]).

\item Se verifica que los elementos del atributo [[lista]] son de tipo
  [[int]], [[float]] o [[sympy.Basic]].
  
\item Se definen dos atributos para la subclase clase [[Vector]]: los
  atributos\; [[rpr]]\; y \;[[n]].
  \begin{itemize}
  \item {\tt self.rpr} indica si el vector ha de ser representado como
    fila o como columna en el entorno
    \href{https://jupyter.org/}{Jupyter}.
  \item {\tt self.n} es el número de elementos de la lista del
    [[Sistema]].
  \end{itemize}
  \HLa{\textbf{\emph{¡Ya tenemos traducido al lenguaje Python la
        definición de vector de \R[n]!}}}
\end{itemize}
% La descripción de los atributos aparece más abajo.\medskip


\begin{codigo}[nobreak=true]
<<Inicialización de la clase [[Vector]]>>=
def __init__(self, data, rpr='columna'):
    """Inicializa Vector con una lista, tupla o Sistema"""
                        
    super().__init__(data)
                        
    <<Verificación de que todos los elementos de la [[lista]] son números o de tipo [[sympy.Basic]]>>
                        
    self.rpr  =  rpr    
    self.n    =  len(self)

@ 
\end{codigo}

Los vectores de \R[n] son sistemas de $n$ números reales. Con el
siguiente código verificamos que los componentes del [[Vector]] son
enteros o números de coma flotante; pero también cualquier objeto de
la librería \href{https://www.sympy.org/en/index.html}{Sympy}\;
([[sympy.Basic]]). Así es posible incluir números racionales
[[sympy.Rational]], números irracionales como $\sqrt{2}$, o incluso
variables simbólicas o polinomios. Al ampliar el tipo de objetos que
pueden aparecer en la [[lista]] de los [[Vector]]es, ya no nos
limitamos a implementar vectores de \R[n]; a cambio podremos extender
las aplicaciones de la librería.
\begin{codigo}
<<Verificación de que todos los elementos de la [[lista]] son números o de tipo [[sympy.Basic]]>>=
if not all( [isinstance(e, (int, float, sympy.Basic)) for e in self] ):
    raise ValueError('no todos los elementos son números o parámetros!')
    
@ 
\end{codigo}
\paragraph{La subclase \texttt{Vector}} junto con el listado de sus
métodos aparece en el siguiente recuadro:
\begin{codigo}%[nobreak=true] 
<<Definición de la clase [[Vector]]>>=
class Vector(Sistema):
    <<Texto de ayuda de la clase [[Vector]]>>
    <<Inicialización de la clase [[Vector]]>>
    <<Operador selector por la izquierda para la clase [[Vector]]>>
    <<Transformaciones elementales por la izquierda de un [[Vector]]>>
    <<Creación de una [[Matrix]] diagonal a partir de un [[Vector]]>>
    <<Normalización de un [[Vector]]>>
    <<Representación de la clase [[Vector]]>>
    
@ %def Vector 
\end{codigo}
En esta sección hemos visto el texto de ayuda y el método de
inicialización de la subclase [[Vector]]. El resto de métodos
específicos de la subclase [[Vector]] se describen en secciones
posteriores (detrás del nombre de cada trozo de código aparece el
número de página donde encontrarlo).
\subsubsection*{Resumen}
\label{resumen:Vector}
Los \textbf{vectores} son una subclase de la clase \emph{``padre''}
[[Sistema]]. Como [[Sistema]]s almacenan una lista de números en su
atributo [[lista]]. Además, heredan los métodos definidos en la clase
[[Sistema]]. Aquellos métodos de la clase [[Sistema]] que no son
adecuados para la subclase [[Vector]] han de ser redefinidos dentro de
la subclase (por ejemplo, el método de
[[<<Representación de la clase [[Vector]]>>]]).

La subclase [[Vector]] es un [[Sistema]] con algunos atributos
propios: [[self.rpr]] indica el modo de representación en el entorno
Jupyter; y [[self.n]] muestra el número de elementos de la [[lista]].

\begin{enumerate}
\item Cuando se instancia un [[Vector]] con otro [[Vector]], se
  obtiene una copia del [[Vector]].
\item Asociados a los [[Vector]]es hay una serie de métodos que se
  describirán más adelante.
\end{enumerate}

\clearpage
\subsection{La subclase clase \texttt{Matrix}}
En las notas de la asignatura usamos la siguiente definición:
\begin{center}
  Llamamos \HLa{\emph{matriz}} de $\R[m \times n]$ a un ``sistema'' de
  $n$ vectores de \R[m].
\end{center}
Al representar las matrices, mostramos la lista de vectores entre
corchetes y sin signos de puntuación:
\begin{displaymath}
  \Mat{A}=[\Vect[1]{v}\;\Vect[2]{v}\;\ldots\Vect[n]{v}],
  \quad\text{donde las $n$ columnas}\;\Vect[i]{v}\;\text{son vectores de }\R[m].
\end{displaymath}
Vamos a crear una nueva subclase de [[Sistema]] que denominaremos
[[Matrix]]. El atributo [[lista]] de [[Matrix]] será la lista de
[[Vector]]es (todos con el mismo número de componentes) que
constituyen las ``columnas'' de la matriz.\\
%Más adelante se definirá el método de representación propio de las matrices.

El texto de ayuda de la clase [[Matrix]] es auto-explicativo; y Python
lo mostrará si se teclea \texttt{help([[Matrix]])}.

\begin{codigo}%[nobreak=true]
<<Texto de ayuda de la clase [[Matrix]]>>=
"""Clase Matrix

Es un Sistema de Vectores con el mismo número de componentes. Una Matrix
se puede construir con: 1) una lista, tupla o Sistema de Vectores con el
mismo número de componentes (serán las columnas); 2) una lista, tupla o 
Sistema de listas, tuplas o Sistemas con el mismo número de componentes 
(serán las filas de la matriz); 3) una Matrix (se obtendrá una copia); 
4) una BlockM (se obtendrá la Matrix que resulta de unir los bloques).

Parámetros:
    data (list, tuple, Sistema, Matrix, BlockM): Lista, tupla o Sistema 
    de Vectores (columnas con mismo núm. de componentes); o de listas,
    tuplas o Sistemas (filas de misma longitud); o una Matrix o BlockM.

Atributos:
    m     (int)    : número de filas de la matriz
    n     (int)    : número de columnas de la matriz

Ejemplos:
>>> # Crear una Matrix a partir de una lista de Vectores:
>>> a = Vector( [1,2] ); b = Vector( [1,0] ); c = Vector( [9,2] )
>>> Matrix( [a,b,c] )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crear una Matrix a partir de una lista de listas de números
>>> A = Matrix( [ [1,1,9], [2,0,2] ] )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crea una Matrix a partir de otra Matrix
>>> Matrix( A )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ])
>>> # Crea una Matrix a partir de una BlockM
>>> Matrix( {1}|A|{2} )

Matrix([ Vector([1, 2]); Vector([1, 0]); Vector([9, 2]) ]) """
@
\end{codigo}
\subsubsection{Implementación de las matrices en la clase \texttt{Matrix}}
\paragraph{Método de inicialización:} \verb/def __init__(self, sis)/.
\begin{itemize}
\item \Verb/Matrix/ se instancia con el argumento [[data]]; que puede
  ser \emph{una lista, tupla o [[Sistema]]}:
  \begin{itemize}
  \item de [[Vector]]es con el mismo número de componentes (serán las
    columnas de la matriz)
  \item o de listas, tuplas o [[Sistemas]] de la misma longitud (serán
    las filas). Los elementos han de ser de tipo [[int]], [[float]] o
    [[sympy.Basic]] (como en el caso de los [[Vector]]es).
  \end{itemize}
  o bien [[data]] puede ser otra [[Matrix]]; o una [[BlockM]].
  
\item Añadimos un breve texto de ayuda del método \Verb/__init__/
  
\item Con \Verb/super().__init__(self.sis)/ se heredan los atributos y
  métodos de la clase [[Sistema]] (en particular el atributo
  [[self.lista]] en el que guardaremos la lista de [[Vector]]es).

\item La variable [[lista]] es igual al atributo [[lista]] del
  [[Sistema]] generado con [[data]].

\item Cuando el primer elemento de [[lista]] es un [[Vector]], se
  comprueba si también el resto de elementos son [[Vector]]es con el
  mismo número de componentes. Si es así, en el atributo
  [[self.lista]] se guarda la lista de [[Vector]]es (que serán las
  columnas de la matriz). Así, cuando [[data]] es una [[Matrix]] se
  obtiene una copia.
  
\item Cuando el primer elemento de [[lista]] NO es un [[Vector]], la
  correspondiente [[self.lista]] de [[Vector]]es (columnas) se genera
  de manera diferente según qué tipo de objeto es [[data]]:
  \begin{itemize}
%  \item cuando \Verb/lista/ solo contiene [[Vector]]es con el mismo
%    número de componentes, entonces [[self.sis]] es el [[Sistema]]
%    compuesto por dicha lista de [[Vector]]es.  (Esto pasa cuando
%    [[data]] es una lista, tupla o [[Sistema]] de [[Vector]]es con el
%    mismo número de componentes, o bien cuando [[data]] es una
%    [[Matrix]])
  \item cuando los elementos de [[data]] son \texttt{list}as,
    \texttt{tupla}s o [[Sistema]]s de la misma longitud: se entiende
    que [[data]] es la ``lista de filas'' de la matriz. Entonces se
    reconstruye la [[self.lista]] de columnas correspondiente.
  \item cuando \Verb/data/ es una \texttt{BlockM}: se obtiene la
    [[Matrix]] resultante de eliminar la partición.
  \end{itemize}
  El trozo de código [[<<Creación del atributo [[lista]] cuando no tenemos una [[lista]] de [[Vector]]es>>]] %
  muestra cómo.
  
\item Por conveniencia definimos dos atributos adicionales:
  \verb/self.m/ muestra el número de filas de la matriz (longitud del
  primer elemento del sistema); y \verb/self.n/ muestra el número de
  columnas (longitud del propio sistema).
\end{itemize}
\dots \HLa{\textbf{\emph{¡Ya tenemos traducido al lenguaje Python la
      definición de matriz!}}}
\begin{codigo}[nobreak=true]
<<Inicialización de la clase [[Matrix]]>>=
def __init__(self, data):
    """Inicializa una Matrix"""
    super().__init__(data)
    
    lista = Sistema(data).lista
    
    if isinstance(lista[0], Vector):
        <<Verificación de que todas las columnas de la matriz tienen la misma longitud>>
        self.lista   = lista.copy()
        
    <<Creación del atributo [[lista]] cuando no tenemos una [[lista]] de [[Vector]]es>>
    
    self.m  =  len(self|1)
    self.n  =  len(self)
    
@
\end{codigo}
\paragraph{La clase \texttt{Matrix}} junto con el listado de sus
métodos aparece en el siguiente recuadro:
\begin{codigo}
<<Definición de la clase [[Matrix]]>>=
class Matrix(Sistema):
    <<Texto de ayuda de la clase [[Matrix]]>>
    <<Inicialización de la clase [[Matrix]]>>
    <<Operador selector por la derecha para la clase [[Matrix]]>>
    <<Operador transposición para la clase [[Matrix]]>>
    <<Operador selector por la izquierda para la clase [[Matrix]]>>
    <<Transformaciones elementales de las filas de una [[Matrix]]>>
    <<Métodos útiles para la clase [[Matrix]]>>
    <<Comprobación de que una [[Matrix]] es singular>>
    <<Métodos de [[Matrix]] que usan la eliminación>>
    <<Potencia de una [[Matrix]]>>
    <<Método Gram-Schmidt para ortogonalizar un sistema de Vectores>>
    <<Representación de la clase [[Matrix]]>>
    
@ %def Matrix
%    ##Suma de [[Matrix]]>>
%    ##Opuesto de una [[Matrix]]>>
%    ##Producto de una [[Matrix]] por un escalar a su izquierda>>
%    ##Definición de la igualdad entre dos [[Matrix]]>>
%    ##Reverso de una [[Matrix]]>>
\end{codigo}
En esta sección hemos visto el texto de ayuda y el método de
inicialización de la subclase [[Matrix]]. El resto de métodos
específicos de la subclase [[Matrix]] se describen en secciones
posteriores.

\subsubsection*{Resumen}
\label{resumen:Matrix}
Las \textbf{matrices} son una subclase de la clase \emph{``padre''}
[[Sistema]]. Como [[Sistema]]s almacenan una lista de [[Vector]]es en
su atributo [[lista]], además de heredar los métodos definidos en la
clase [[Sistema]]. Aquellos métodos definidos para la clase
[[Sistema]] que no son adecuados para la subclase [[Matrix]] han de
ser redefinidos (por ejemplo, el método de
[[<<Representación de la clase [[Matrix]]>>]]).

La subclase [[Matrix]] es un [[Sistema]] con dos atributos propios:
[[self.m]] es el número de filas de [[Matrix]]; y [[self.n]] el número
de columnas.

\begin{enumerate}
\item Cuando se instancia con una lista, tupla o [[Sistema]] de
  [[Vector]]es, el atributo [[self.lista]] almacena dicha lista de
  [[Vector]]es. \emph{Ésta es la forma de crear una matriz a partir de
    sus columnas.} Consecuentemente, si se instancia una [[Matrix]]
  con otra [[Matrix]] se obtiene una copia.
\item Por comodidad, también \HLa{es posible instanciar con una lista,
  tupla o [[Sistema]] de listas, tuplas o [[Sistema]]s que, en este
  caso, se interpreta como la lista de filas de la
  matriz}. Internamente se dan los pasos necesarios para almacenar la
  matriz en forma de [[Sistema]] de columnas. \HLa{(Esta forma de
    instanciar una [[Matrix]] se usará para programar la
    \textbf{transposición} en la Página~\pageref{sec:transposicion})}.
\item Cuando se instancia con una [[BlockM]] se obtiene la
  [[Matrix]] resultante de unificar los bloques en una sola matriz.
\item Asociados a las [[Matrix]] hay una serie de métodos específicos
  que veremos más adelante.
\end{enumerate}

%Por tanto,
%\begin{itemize}
%\item [[Vector]] guarda un sistema de números como una [[list]] es su
%  atributo [[self.lista]] (y como un [[Sistema]] en su atributo
%  [[self.sis]])
%\item [[Matrix]] guarda un sistema de [[Vector]]es como una [[list]]
%  es su atributo [[self.lista]] (y como un [[Sistema]] en su atributo
%  [[self.sis]]); así pues:
%\end{itemize}

\noindent
\textbf{¡Hemos implementado en Python los vectores y matrices tal y
  como se definen en las notas de la asignatura!}  \medskip

\dots vayamos con el operador selector\dots que más adelante nos
permitirá definir las operaciones de suma, producto, etc\dots


\clearpage

\section{Operadores selectores}
\begin{NotMat2}
  \begin{itemize}
  \item Si $\Vect{v}=(v_1,\ldots,v_n)$ entonces $\elemL{\Vect{v}}{i}=\elemR{\Vect{v}}{i}=v_i$ para todo $i \in\{1,\dots,n\}$.
  \item Si
    \begin{math}
      \Mat{A}=
      \begin{bmatrix}
        a_{11}&\cdots&a_{1m}\\
        \vdots &&\vdots\\
        a_{n1}&\cdots&a_{nm}
      \end{bmatrix}
    \end{math}
    entonces
    \begin{math}
      \begin{cases}
        \VectC[j]{A}=
        \begin{pmatrix}
          a_{1j}\\ \vdots \\ a_{nj}
        \end{pmatrix}
        \;\text{para todo}\; j\in\{1,\ldots,m\} \\
        \VectF[i]{A}= (a_{i1},\ldots,a_{im})
        \;\text{para todo}\;
        i\in\{1,\ldots,n\}
      \end{cases}.
    \end{math}
  \end{itemize}
\end{NotMat2}
Pero
puestos a seleccionar,\dots aprovechemos la notación para seleccionar más
de un elemento:
\begin{NotMat2}
  \begin{itemize}
  \item $\elemL{\Vect{v}}{(i_1,\ldots, i_r)}=\Big(\Vect{v}_{i_1},\ldots, \Vect{v}_{i_r}\Big)=\elemR{\Vect{v}}{(i_1,\ldots, i_r)}$
    \hfill (es un vector formado por elementos de \Vect{v})
  \item $\VectF[(i_1,\ldots, i_r)]{A}=\Big[\VectF[i_1]{A}\ \ldots\ \VectF[i_r]{A}\Big]^\T$ 
    \hfill (es una matriz cuyas filas son filas de \Mat{A})
  \item $\VectC[(j_1,\ldots, j_r)]{A}=\Big[\VectC[j_1]{A}\ \ldots\ \VectC[j_r]{A}\Big]$ 
    \hfill (es una matriz formada por columnas de \Mat{A})
  \end{itemize}
\end{NotMat2}
Pues bien, queremos manejar una notación similar en Python; así que
debemos definir un operador selector. Nos conviene hacerlo con un
método de Python asociado un símbolo.
\begin{notebook}
  \begin{center}
    Si no recuerda a qué me refiero con ``símbolos asociados a
    métodos'', repase la sección
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F02_Clases.ipynb#Métodos-especiales-con-símbolos-asociados}
      {``Métodos especiales con símbolos asociados''} del Notebook
    %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F02_Clases.ipynb#Métodos-especiales-con-símbolos-asociados}
    %  {``Métodos especiales con símbolos asociados''} del Notebook
    {\textbf{``Clases''}}
      en la carpeta
      %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F}{``TutorialPython''}
      \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F}{``TutorialPython''}
        en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython}
        %\url{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master}
        %\url{https://notebooks.gesis.org/binder/jupyter/user/mbujosab-nacallib-dwb8caok/tree/doc/Notebooks/TutorialPython}
  \end{center}
\end{notebook}
Como los métodos \Verb/__or__/ y \Verb/__ror__/ tienen asociados la
barra vertical a derecha e izquierda, usaremos el convenio:
\begin{displaymath}
  \begin{array}{|ll|rr|}
    \hline
    \text{Mates II}&\text{Python} & \text{Mates II}&\text{Python}\\
    \hline\hline
    \elemR{\Vect{v}}{i} & \text{{\tt v|i}}\vphantom{\Big)} & %\\ \hline
    \elemL{\Vect{v}}{i} & \text{{\tt i|v}}\vphantom{\Big)}\\ \hline
    \VectC[j]{A} & \text{{\tt A|j}}\vphantom{\Big)} & %\\ \hline
    \VectF[i]{A} & \text{{\tt i|A}}\vphantom{\Big)}\\      
    \hline
  \end{array}
\end{displaymath}
Recuerde que en Python los índices de objetos iterables comienzan en
cero, pero en la notación empleada en Matemáticas 2 el índice del
primer elemento es 1.
%\begin{displaymath}
%  \begin{array}{|c|c|}
%    \hline
%    \text{Mates II}&\text{Python}\\
%    \hline\hline
%    \elemR{\Vect{v}}{i} & \text{{\tt v|i}}\vphantom{\Big)}\\ \hline
%    \elemL{\Vect{v}}{i} & \text{{\tt i|v}}\vphantom{\Big)}\\ \hline
%    \VectC[j]{A} & \text{{\tt A|j}}\vphantom{\Big)}\\ \hline
%    \VectF[i]{A} & \text{{\tt i|A}}\vphantom{\Big)}\\      
%    \hline
%  \end{array}
%\end{displaymath}

%\pagebreak[4]
\subsection{Operador selector por la derecha para la clase \texttt{Sistema}.}
Tal como se hace en el Tema 2 de las notas de la asignatura,
seleccionaremos elementos de un [[Sistema]] con el operador
``\Verb/|/'' actuando por la derecha (¡ojo, para la clase genérica
[[Sistema]] solo lo hacemos por la derecha!).

\begin{codigo}
<<Texto de ayuda para el operador selector por la derecha para la clase [[Sistema]]>>=
"""
Extrae el j-ésimo componente del Sistema; o crea un Sistema con los
elementos indicados (los índices comienzan por el número 1)

Parámetros:
    j (int, list, tuple, slice): Índice (o lista de índices) del 
          elementos (o elementos) a seleccionar

Resultado:
          ?: Si j es int, devuelve el elemento j-ésimo del Sistema.
    Sistema: Si j es list, tuple o slice devuelve el Sistema formado por
          los elementos indicados en la lista, tupla o slice de índices.

Ejemplos:
>>> # Extrae el j-ésimo elemento del Sistema 
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | 2

Vector([0, 2])
>>> # Sistema formado por los elementos indicados en la lista (o tupla)
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | [2,1]
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | (2,1)

[Vector([0, 2]); Vector([1, 0])]
>>> # Sistema formado por los elementos indicados en el slice
>>> Sistema([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | slice(1,3,2)

[Vector([1, 0]), Vector([3, 0])] """
@
\end{codigo}

\subsubsection[Implementación]{Implementación del operador selector por la derecha para la clase \texttt{Sistema}.}
Cuando el argumento \texttt{j} es un número entero (\texttt{int}),
seleccionamos el elemento [[j]]ésimo del atributo [[lista]]
(como en Python los índices de objetos iterables comienzan en cero,
para seleccionar el elemento $j$ésimo de \texttt{lista}, escribimos
\texttt{lista[j-1]}; así \texttt{a|1} selecciona el primer elemento
del atributo [[lista]], es decir [[a.lista[0]]]).  %\medskip

Luego usamos el método (\verb/self|a/) (siendo [[a]] un [[int]]) para
definir el operador cuando \texttt{j} es una lista o tupla
[[(list,tuple)]] de índices y generar así un sistema con las
componentes indicadas. El sistema obtenido será del mismo tipo que
[[self]], es decir, o un [[Sistema]], o un [[Vector]], o etc.\dots
dependiendo de a qué objeto se aplica el selector.

Cuando el argumento \texttt{j} es del tipo [[slice(start,stop,step)]],
se seleccionan varios componentes, comenzando por aquél cuyo índice es
[[start]], y seleccionando de [[step]] en [[step]] componentes hasta
llegar al de índice [[stop]]. Dicho sistema será del mismo tipo que
[[self]]. Si el primer argumento de [[slice]] es [[None]] se
seleccionan los componentes empezando por el primero. Si el segundo
argumento de [[slice]] es [[None]] se recorren todos los índices hasta
llegar al último componente. Si se omite el tercer argumento de
[[slice]] (o si el tercer argumento es [[None]]) entonces [[step]] es
igual a uno. Así, [[slice(None,None)]] selecciona todos los
componentes; [[slice(2,None,2)]] selecciona los componentes pares
hasta el final; y [[slice(4,11,3)]] selecciona un componente de cada
tres comenzando por el cuarto y hasta llegar al undécimo (es decir,
los índices 4, 7 y 10).
\begin{codigo}[nobreak=true] 
<<Operador selector por la derecha para la clase [[Sistema]]>>=  
def __or__(self,j):
    <<Texto de ayuda para el operador selector por la derecha para la clase [[Sistema]]>>
    <<Operador selector por la derecha cuando el argumento es entero, lista o slice>>

@  
\end{codigo}
Recuerde que el operador selector por la derecha funcionará de la
misma manera para la clase \emph{``padre''} [[Sistema]] como para
cualquiera de sus subclases (siempre y cuando dicho método no sea
redefinido dentro de la subclase).
\begin{codigo}[nobreak=true] 
<<Operador selector por la derecha cuando el argumento es entero, lista o slice>>=
if isinstance(j, int):
    return self[j-1]
    
elif isinstance(j, (list,tuple) ):
    return type(self) ([ self|a for a in j ])

elif isinstance(j, slice):
    start = None if j.start is None else j.start-1 
    stop  = None if j.stop  is None else (j.stop if j.stop>0 else j.stop-1)
    step  = j.step  or 1
    return type(self) (self[slice(start,stop,step)])
@
\end{codigo}
@

\subsection{Operador selector por la izquierda para la clase \texttt{Vector}.}
En las notas de la asignatura hemos admitido la selección de elementos
de un vector por la izquierda,
$\;\elemL{\Vect{v}}{i}=\elemR{\Vect{v}}{i}$.\; Así que aquí haremos lo
mismo; y además ahora es muy sencillo\dots\; Como el selector por la
izquierda hace lo mismo que el selector por la derecha, basta con
llamar al selector por la derecha:\; \verb/self|i/
\begin{codigo}[nobreak=true] 
<<Operador selector por la izquierda para la clase [[Vector]]>>=
def __ror__(self,i):
    """Hace exactamente lo mismo que el método __or__ por la derecha."""
    return self | i
    
@ 
\end{codigo}

%\pagebreak[4]

\subsection{Operador selector por la derecha para la clase \texttt{Matrix}.}
Necesitamos reescribir el método de selección por la derecha para
[[Matrix]] ya que también emplearemos el operador \Verb/__or__/ para
particionar matrices. Es decir, con la clase [[Matrix]] usaremos el
selector ``[[|]]'' tanto para seleccionar columnas como para obtener
una matriz particionada por columnas (matriz por bloques, [[BlockM]])
si el argumento del operador es un conjunto ([[set]]). El siguiente
texto de ayuda es auto-explicativo:
\begin{codigo}
<<Texto de ayuda para el operador selector por la derecha para la clase [[Matrix]]>>=
"""
Extrae la i-ésima columna de Matrix; o crea una Matrix con las columnas
indicadas; o crea una BlockM particionando una Matrix por las
columnas indicadas (los índices comienzan por la posición 1)

Parámetros:
    j (int, list, tuple, slice): Índice (o lista de índices) de la 
          columna (o columnas) a seleccionar
      (set): Conjunto de índices de las columnas por donde particionar

Resultado:
    Vector: Cuando j es int, devuelve la columna j-ésima de Matrix.
    Matrix: Cuando j es list, tuple o slice, devuelve la Matrix formada 
        por las columnas indicadas en la lista o tupla de índices.
    BlockM: Si j es un set, devuelve la BlockM resultante de particionar
        la matriz a la derecha de las columnas indicadas en el conjunto

Ejemplos:
>>> # Extrae la j-ésima columna la matriz 
>>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | 2

Vector([0, 2])
>>> # Matrix formada por Vectores columna indicados en la lista (o tupla)
>>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | [2,1]
>>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | (2,1)

Matrix( [Vector([0, 2]); Vector([1, 0])] )
>>> # BlockM correspondiente a la partición por la segunda columna
>>> Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) | {2}

BlockM([SisMat([Matrix([Vector([1, 0]), Vector([0, 2])])]), 
        SisMat([Matrix([Vector([3, 0])])])])
"""
@
\end{codigo}
\paragraph{Implementación del operador selector por la derecha para la clase \texttt{Matrix}.}
Cuando el argumento es un entero, una lista o un slice todo es
exactamente igual en la clase genérica [[Sistema]]. El modo de
particionar una [[Matrix]] cuando el argumento es un conjunto
([[set]]) se verá en la sección de la clase [[BlockM]].
%(\emph{aunque la partición en bloques de columnas de matrices se verá
%  más adelante, en la sección de la clase [[BlockM]]}).
\begin{codigo}[nobreak=true] 
<<Operador selector por la derecha para la clase [[Matrix]]>>=  
def __or__(self,j):
    <<Texto de ayuda para el operador selector por la derecha para la clase [[Matrix]]>>
    <<Operador selector por la derecha cuando el argumento es entero, lista o slice>>
    <<Partición de una matriz por columnas de bloques>> 
@
\end{codigo}
@

\subsection{Operador transposición de una \texttt{Matrix}.}
\label{sec:transposicion}
Implementar el operador selector por la izquierda para la clase
[[Matrix]] es algo más complicado; pues en este caso no es lo mismo
operar por la derecha que por la izquierda de una matriz. Vamos a
definir primero el operador transposición, que usaremos después para
implementar el operador selector por la izquierda (selección de filas
mediante la selección de las columnas de la transpuesta).\smallskip
\begin{NotMat2}
  Denotamos la \emph{transpuesta} de \Mat{A} con:\quad \MatT{A};\quad que
  es la matriz tal que
  \begin{math}
    \quad\VectTC[j]{A}=\VectF[j]{A};\qquad j=1:n. 
  \end{math}
\end{NotMat2}

\begin{codigo}[nobreak=true] 
<<Texto de ayuda para el operador transposición de la clase [[Matrix]]>>=
"""
Devuelve la traspuesta de una matriz.

Ejemplo:
>>> ~Matrix([ [1,2,3] ])

Matrix([ Vector([1, 2, 3]) ])
"""
@
%~Matrix([Vector([1]), Vector([2]), Vector([3])])
\end{codigo}
\subsubsection[Implementación]{Implementación del operador transposición.}
Desgraciadamente Python no dispone del símbolo ``${\ }^\T$''. Así que
hemos de usar un símbolo distinto para indicar transposición. Y además
no tenemos muchas opciones ya que el conjunto de símbolos asociados a
métodos especiales es muy limitado.
\begin{notebook}
  \begin{center}
    Si no recuerda a qué me refiero con ``símbolos asociados a
    métodos'', repase la sección
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F02_Clases.ipynb#Métodos-especiales-con-símbolos-asociados}
      {``Métodos especiales con símbolos asociados''} del Notebook
    %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F02_Clases.ipynb#Métodos-especiales-con-símbolos-asociados}
    %  {``Métodos especiales con símbolos asociados''} del Notebook
    {\textbf{``Clases''}}
      en la carpeta
      %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F}{``TutorialPython''}
      \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FTutorialPython%2F}{``TutorialPython''}
        en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks/TutorialPython}
        %\url{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master}
        %\url{https://notebooks.gesis.org/binder/jupyter/user/mbujosab-nacallib-dwb8caok/tree/doc/Notebooks/TutorialPython}
  \end{center}
\end{notebook}
Para implementar la transposición haremos uso del método
\verb/__invert__/ que tiene asociado el símbolo del la tilde
``\verb/~/''. Desgraciadamente deberemos colocar el símbolo a la
izquierda de la matriz, por lo que son dos las diferencias respecto a
la natación usada en las notas de la asignatura: el símbolo en sí, y
su posición respecto de la matriz:
\begin{displaymath}
  \begin{array}{|c|c|}
    \hline
    \text{Mates II}&\text{Python}\\
    \hline\hline
    \MatT{A} & \verb/~A/\\      
    \hline
  \end{array}
\end{displaymath}
Ahora recuerde que con la segunda forma de instanciar una [[Matrix]]
(véase el resumen de la página~\pageref{resumen:Matrix}) creamos una
matriz a partir de la lista de sus filas. Aprovechando esta forma de
instanciar podemos construir fácilmente el operador
trasposición. Basta instanciar [[Matrix]] con los atributos [[lista]]
de los $n$ [[Vector]]es columna.  \\ (Recuerde que
\verb/range(1,self.m+1)/ recorre los números: $1,2,\ldots,m$).
\begin{codigo}[nobreak=true] 
<<Operador transposición para la clase [[Matrix]]>>=  
def __invert__(self):
    <<Texto de ayuda para el operador transposición de la clase [[Matrix]]>>
    return Matrix ([ c.lista for c in self ])
    
@ 
\end{codigo}

%\clearpage
%\pagebreak[4]

\subsection{Operador selector por la izquierda para la clase \texttt{Matrix}.}
%El siguiente recuadro muestra el texto de ayuda del operador Selector por la izquierda para la clase \texttt{Matrix}.
\begin{codigo}
<<Texto de ayuda para el operador selector por la izquierda para la clase [[Matrix]]>>=
"""Operador selector por la izquierda

Extrae la i-ésima fila de Matrix; o crea una Matrix con las filas 
indicadas; o crea una BlockM particionando una Matrix por las filas
indicadas (los índices comienzan por la posición 1)

Parámetros:
    i (int, list, tuple): Índice (o índices) de las filas a seleccionar
      (set): Conjunto de índices de las filas por donde particionar

Resultado:
    Vector: Cuando i es int, devuelve la fila i-ésima de Matrix.
    Matrix: Cuando i es list o tuple, devuelve la Matrix cuyas filas son
        las indicadas en la lista de índices.
    BlockM: Cuando i es un set, particiona la matriz por debajo de las 
        filas indicadas en el conjunto.

Ejemplos:
>>> # Extrae la j-ésima fila de la matriz 
>>> 2 | Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])])

Vector([0, 2, 0])
>>> # Matrix formada por Vectores fila indicados en la lista (o tupla)
>>> [1,1] | Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])]) 
>>> (1,1) | Matrix([Vector([1,0]), Vector([0,2]), Vector([3,0])])

Matrix([Vector([1, 1]), Vector([0, 0]), Vector([3, 3])])
>>> # BlockM correspondiente a la partición por la primera fila
>>> {1} | Matrix([Vector([1,0]), Vector([0,2])])

BlockM([ SisMat([Matrix([Vector([1]), Vector([0])]), 
                 Matrix([Vector([0]), Vector([2])])]) ])
"""
@
\end{codigo}
\subsubsection[Implementación]{Implementación del operador por la izquierda para la clase \texttt{Matrix}.}
Es inmediato implementar el selector por la izquierda (selección de
filas) con el operador selector de columnas y la transposición:
\begin{center}
  \verb/(~self)|i/
\end{center}
(para recordar que se ha obtenido una fila de la matriz,
representaremos el [[Vector]] en
horizontal:\;\texttt{rpr='fila'}) \medskip

%Una vez definido el operador por la izquierda cuando [[i]] es un
%entero, podemos usar repetidas veces la operación \texttt{(a|self)}
%para crear una [[Matrix]] con las filas indicadas en una lista o tupla
%de índices.  \\
(\emph{la partición en bloques de filas de matrices se
  verá en la sección de la clase [[BlockM]]}).
\begin{codigo}[nobreak=true] 
<<Operador selector por la izquierda para la clase [[Matrix]]>>=  
def __ror__(self,i):
    <<Texto de ayuda para el operador selector por la izquierda para la clase [[Matrix]]>>
    if isinstance(i,int):
        return  Vector( (~self)|i , rpr='fila' )

    elif isinstance(i, (list,tuple,slice)):        
        return ~Matrix( (~self)|i ) 
    
    <<Partición de una matriz por filas de bloques>>

@ 
\end{codigo}
\subsubsection*{Resumen}
\label{resumen:OperadorSelector}
\textbf{¡Ahora también hemos implementado en Python el operador
  ``\texttt{|}'' (por la derecha y por la izquierda) tal y
  como se define en las notas de la asignatura!}  \bigskip

Ya estamos listos para definir el resto de operaciones con vectores y
matrices\dots

% En las notas de la asignatura, y usando los vectores, matrices y el operador
% ``$|$'', hemos definido el resto de operaciones. Aquí haremos lo
% mismo, comenzando en la siguiente sección por las operaciones de suma
% y producto tanto con matrices como con vectores.

\clearpage
\section{Operaciones con \texttt{Sistemas}}

%\subsection{Suma y productos entre vectores}

Con la definición de la clase [[Sistema]] y el operador selector
``\texttt{|}'' por la derecha, ya podemos definir las operaciones de
suma de dos sistemas y de producto de un sistema por un
escalar. Fíjese que las definiciones de las operaciones en Python
(usando el operador ``\texttt{|}'') son idénticas a las empleadas en
las notas de la asignatura:
\subsection{Suma de \texttt{Sistemas}}
En las notas de la asignatura hemos definido la suma de dos vectores de \R[n] como el vector tal que
\begin{displaymath}
  \fbox{\begin{math} \elemR{(\Vect{a}+\Vect{b})}{i}=\eleVR{a}{i}+\eleVR{b}{i} \end{math}}
  \quad\text{para}\quad i=1:n
\end{displaymath}
y la suma de matrices como la matriz tal que
\begin{displaymath}
  \fbox{\begin{math} \elemRP{\Mat{A}+\Mat{B}}{j}=\VectC[j]{A}+\VectC[j]{B} \vphantom{\Big(} \end{math}}
  \quad\text{para}\quad i=1:n.
\end{displaymath}
Ambas son casos particulares de sumas elemento a elemento entre dos
[[Sistema]]s \SV{A} y \SV{B}, de $n$ elementos cada uno:
\begin{displaymath}
  \fbox{\begin{math} \elemRP{\SV{a}+\SV{b}}{i}=\elemR{\SV{a}}{i}+\elemR{\SV{b}}{i} \end{math}}
  \quad\text{para}\quad i=1:n.
\end{displaymath}
Usando el operador selector podemos ``literalmente'' transcribir esta definición
\begin{center}
  \Verb/ Sistema ([ (self|i) + (other|i) for i in range(1,len(self)+1) ]) /
\end{center}
donde \texttt{self} es el sistema \SV{A}, \texttt{other} es el sistema
\SV{B}, y \;\Verb/range(1,self.n+1)/\; es el rango de valores: $1:n$.
\medskip

Hay que tener en cuenta que cuando el [[Sistema]] es un [[Vector]] el
resultado es un [[Vector]] y cuando el [[Sistema]] es una [[Matrix]]
el resultado es una [[Matrix]]. Es decir, el código debe devolver un
objeto del mismo tipo que [[self]]. Esto lo logramos sustituyendo
``\texttt{Sistema}'' por ``[[type(self)]]''. Así, la implementación
final es:
\begin{center}
  \Verb/ type(self) ([ (self|i) + (other|i) for i in range(1,len(self)+1) ]) /
\end{center}
\medskip

Por último, nótese que para que la implementación funcione es
necesario que los elementos \;\elemR{\SV{a}}{i}\; y
\;\elemR{\SV{b}}{i}\; sean sumables, es decir, es necesario que la
operación
\begin{center}
  \Verb/ (self|i) + (other|i) /
\end{center}
esté definida para cada [[i]].

\begin{codigo}[nobreak=true] 
<<Texto de ayuda para el operador suma en la clase [[Sistema]]>>=
"""Devuelve el Sistema resultante de sumar dos Sistemas

Parámetros: 
    other (Sistema): Otro sistema del mismo tipo y misma longitud

Ejemplos:
>>> Sistema([10, 20, 30]) + Sistema([-1, 1, 1])

Sistema([9, 21, 31]) 
>>> Vector([10, 20, 30]) + Vector([-1, 1, 1])

Vector([9, 21, 31]) 
>>> Matrix([[1,5],[5,1]]) + Matrix([[1,0],[0,1]]) 

Matrix([Vector([2, 5]); Vector([5, 2])]) """
@
\end{codigo}
De manera análoga definimos diferencia entre sistemas.
%, que emplearemos para calcular la diferencia de vectores y la diferencia de matrices.
\begin{codigo}[nobreak=true] 
<<Texto de ayuda para el operador resta en la clase [[Sistema]]>>=
"""Devuelve el Sistema resultante de restar dos Sistemas

Parámetros: 
    other (Sistema): Otro sistema del mismo tipo y misma longitud

Ejemplos:
>>> Sistema([10, 20, 30]) - Sistema([1, 1, -1])

Sistema([9, 19, 31])
>>> Vector([10, 20, 30]) - Vector([1, 1, -1])

Vector([9, 19, 31])
>>> Matrix([[1,5],[5,1]]) - Matrix([[1,0],[0,1]]) 

Matrix([Vector([0, 5]); Vector([5, 0])]) 
"""
@
\end{codigo}
\subsubsection{Implementación}
\begin{codigo}[nobreak=true] 
<<Suma y resta de [[Sistema]]s>>=
def __add__(self, other):
    <<Texto de ayuda para el operador suma en la clase [[Sistema]]>>
    if not type(self)==type(other) or not len(self)==len(other):
        raise ValueError ('Solo se suman Sistemas del mismo tipo y misma longitud')

    return type(self) ([ (self|i) + (other|i) for i in range(1,len(self)+1) ])
            
def __sub__(self, other):
    <<Texto de ayuda para el operador resta en la clase [[Sistema]]>>    
    if not type(self)==type(other) or not len(self)==len(other):
        raise ValueError ('Solo se restan Sistemas del mismo tipo y misma longitud')

    return type(self) ([ (self|i) - (other|i) for i in range(1,len(self)+1) ])
            
@ 
\end{codigo}


\subsection{Producto de un \texttt{Sistema} por un escalar a su izquierda}
El producto de un sistema \SV{a} por un escalar $x$ a su izquierda es
el \emph{sistema}
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\SV{a}}{i}=x \elemRPE{\SV{a}}{i}
  \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
cuya transcripción literal sería
\begin{center}
  \Verb/ Sistema ( [ x*(self|i) for i in range(1,len(self)+1) ] ) /
\end{center}
donde \texttt{x} es un número (\texttt{int}, \texttt{float}) o un
objeto de la librería Sympy (\texttt{sympy.Basic}) y donde
\texttt{self} es \SV{A}.

Como casos particulares tenemos el producto de un \emph{vector}
\Vect{a} por un escalar $x$ a su izquierda, que es el \emph{vector}:
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\Vect{a}}{i}=x \eleVRPE{a}{i}
  \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
Y el producto de una \emph{matriz} \Mat{A} por un escalar $x$ a su
izquierda, que es la \emph{matriz}:
\begin{displaymath}
  \fbox{\begin{math} 
      \elemRP{x\Mat{A}}{j}=x\VectCPE[j]{A}
    \end{math}}\quad\text{para}\quad i=1:n.
\end{displaymath}
Como en los casos particulares se obtienen \emph{sistemas} de tipos
particulares (\emph{vectores} en el primer caso y \emph{matrices} en
el segundo), debemos sustituir \Verb/Sistema/ por \Verb/type(self)/
para obtener sistemas del mismo tipo que [[self]]:
\begin{center}
  \Verb/ type(self) ( [ x*(self|i) for i in range(1,len(self)+1) ] ) /
\end{center}
\begin{codigo}
<<Texto de ayuda para el operador producto por la izquierda en la clase [[Sistema]]>>=
"""Multiplica un Sistema por un número a su izquierda

Parámetros:
    x (int, float o sympy.Basic): Escalar por el que se multiplica
Resultado:
    Sistema resultante de multiplicar cada componente por x
Ejemplo:
>>> 3 * Sistema([10, 20, 30]) 

Sistema([30, 60, 90]) 
"""
@ 
\end{codigo}
\subsubsection{Implementación}
\begin{codigo}%[nobreak=true] 
<<Producto de un [[Sistema]] por un escalar a su izquierda>>=
def __rmul__(self, x):
    <<Texto de ayuda para el operador producto por la izquierda en la clase [[Sistema]]>>
    if isinstance(x, (int, float, sympy.Basic)):
        return type(self)( [ x*(self|i) for i in range(1,len(self)+1) ] )
        
@   
% return type(self)([ x*e for e in self ])
\end{codigo}

También nos viene viene bien manejar el opuesto de un [[Sistema]]:
$\;-\SV{A}=-1(\SV{A}).$
\begin{codigo}[nobreak=true] 
<<Opuesto de un [[Sistema]]>>=
def __neg__(self):
    """Devuelve el opuesto de un Sistema"""
    return -1*self

@ 
\end{codigo}

\subsection{Producto de un \texttt{Sistema} por un escalar, un \texttt{Vector} o una \texttt{Matrix} a su derecha}
\begin{itemize}
\item En las notas de la asignatura se acepta que el producto de un
  [[Sistema]] por un escalar es conmutativo. Por tanto,
  \begin{displaymath}
    \fbox{\begin{math} 
        \SV{A}x=x\SV{A}
      \end{math}}
  \end{displaymath}
  cuya transcripción será
  \begin{center}
    \Verb/ x * self /
  \end{center}
  donde \texttt{self} es el [[Sistema]] y \texttt{x} es un número
  entero, u objeto de la librería Sympy (\texttt{int, float,
    sympy.Basic}).
\item El producto de \SV{A}, de [[n]] componentes, por un vector
  \Vect{x} de \R[n] a su derecha se define como
  \begin{displaymath}
    \fbox{$\SV{A}\Vect{x}\;=\;\elemRPE{\SV{A}}{1}x_1+\cdots+\elemRPE{\SV{A}}{n}x_n\;=\;\sum_{j=1}^n\elemRPE{\SV{A}}{j}x_j$}
    %\fbox{$\SV{A}\Vect{x}\;=\;\elemRPE{\SV{A}}{1}\elemRPE{\Vect{x}}{1}+\cdots+\elemRPE{\SV{A}}{n}\elemRPE{\Vect{x}}{n}\;=\;\sum_{j=1}^n\elemRPE{\SV{A}}{j}\elemRPE{\Vect{x}}{j}$}
    \qquad\text{para}\; j=1:n.
  \end{displaymath}
  cuya transcripción será
  \begin{center}
    \Verb/ sum([ (self|j)*(x|j) for j in range(1,x.n+1) ]) /
  \end{center}
  donde \texttt{self} es un [[Sistema]] y \texttt{x} es un
  ([[Vector]]).

  Fíjese que el \emph{producto punto} (o producto escalar usual en
  \R[n]) de dos vectores \Vect{a} y \Vect{x} en $\R[n]$ es un caso
  particular en el que el sistema $\SV{A}$ es un vector $\Vect{a}$.
\item El producto del sistema \SV{A} de [[p]] componentes por una
  matriz \Matdim{x}{p}{n} de \R[n] a su derecha se define como el
  sistema tal que
  \begin{displaymath}
    \fbox{$\elemR{(\SV{A}\Mat{X})}{j}=\SV{A}(\VectC[j]{X})$}
    \qquad\text{para}\; j=1:n.
  \end{displaymath}
  cuya transcripción será
  \begin{center}
    \Verb/ type(self) ( [ self*(x|j) for j in range(1,x.n+1)] ) /
  \end{center}
  donde \texttt{self} es el [[Sistema]] y \texttt{x} es una
  [[Matrix]].

  Fíjese que el \emph{producto de matrices} es un caso particular en
  el que el sistema $\SV{A}$ es una matriz $\Mat{A}$.

  Además, sabemos por las notas de la asignatura que en el caso
  particular de que el sistema $\SV{A}$ sea un vector, el resultado es
  una combinación lineal de las filas de la matriz \Mat{X} (es decir,
  el resultado es un vector). Para recordar que el vector resultante
  es una combinación lineal de las filas, lo representaremos en forma
  de fila.
\end{itemize}
\begin{codigo}[nobreak=true] 
<<Texto de ayuda para el operador producto por la derecha en la clase [[Sistema]]>>=
"""Multiplica un Sistema por un número, Vector o una Matrix a su derecha

Parámetros:
    x (int, float o sympy.Basic): Escalar por el que se multiplica
      (Vector): con tantos componentes como el Sistema
      (Matrix): con tantas filas como componentes tiene el Sistema

Resultado:
    Sistema del mismo tipo: Si x es int, float o sympy.Basic, devuelve 
       el Sistema que resulta de multiplicar cada componente por x
    Objeto del mismo tipo de los componentes del Sistema: Si x es Vector,
       devuelve una combinación lineal de los componentes del Sistema, 
       donde los componentes de x son los coeficientes de la combinación.
    Sistema del mismo tipo: Si x es Matrix, devuelve un Sistema cuyas 
       componentes son combinación lineal de las componentes originales.
       
Ejemplos:
>>> # Producto por un número
>>> Vector([10, 20, 30]) * 3

Vector([30, 60, 90])
>>> Matrix([[1,2],[3,4]]) * 10

Matrix([[10,20],[30,40]])
>>> # Producto por un Vector
>>> Vector([10, 20, 30]) * Vector([1, 1, 1])

60
>>> Matrix([Vector([1, 3]), Vector([2, 4])]) * Vector([1, 1])

Vector([3, 7])
>>> # Producto por una Matrix
>>> Vector([1,1,1])*Matrix( ( [1,1,1], [2,4,8], [3,-1,0] ) )

Vector([6, 4, 9])
>>> Matrix([Vector([1, 3]), Vector([2, 4])]) * Matrix([Vector([1,1])]))

Matrix([Vector([3, 7])])
"""
@  
\end{codigo}

%\pagebreak[4]
\subsubsection{Implementación}
Al implementar [[Sistema]] por [[Vector]] usamos la función
[[sum]]. La función [[sum]] de Python tiene dos argumentos: el primero
es la lista de objetos a sumar, y el segundo es el primer objeto de la
suma (por defecto es el \emph{número} ``$0$''). Como sumar el número
cero a un elemento del [[Sistema]] puede no tener sentido, haremos el
siguiente truco: el primer objeto de la suma será el primer elemento
de la lista multiplicado por el numero cero.

\begin{codigo}[nobreak=true] 
<<Producto de un [[Sistema]] por un escalar, un [[Vector]] o una [[Matrix]] a su derecha>>=
def __mul__(self,x):
    <<Texto de ayuda para el operador producto por la derecha en la clase [[Sistema]]>>
    if isinstance(x, (int, float, sympy.Basic)):
        return x*self

    elif isinstance(x, Vector):
        if len(self) != x.n:    raise ValueError('Sistema y Vector incompatibles')
        return sum([(self|j)*(x|j) for j in range(1,len(self)+1)], 0*self|1)

    elif isinstance(x, Matrix):
        if len(self) != x.m:      raise ValueError('Sistema y Matrix incompatibles')
        if isinstance(self, Vector):
            return Vector( [ self*(x|j) for j in range(1,(x.n)+1)], rpr='fila' )
        else:
            return type(self) ( [ self*(x|j) for j in range(1,(x.n)+1)] )

@
\end{codigo}


\clearpage

\section{La clase transformación elemental \texttt{T}}

\begin{NotMat2}
  Si $\mat{A}$ es una matriz, consideramos las siguientes transformaciones:
  \begin{description}
  \item[Tipo I:]\; \TESF{\lambda}{i}{j}{\Mat{A}} suma $\lambda$ veces la fila $i$
    a la fila $j$ ($i\ne j$);\hfill
    \TESC{\lambda}{i}{j}{\Mat{A}} lo mismo con las columnas.
  \item[Tipo II:]\; \TEPF{\lambda}{i}{\Mat{A}} multiplica la fila $i$
    por $\lambda\ne0$; \hfill y \TEPC{\lambda}{j}{\Mat{A}} multiplica la
    columna $j$ por $\lambda$.
  \item[Intercambio:]\; \TEIF{i}{j}{\Mat{A}} intercambia las filas $i$
    y $j$; \hfill y \TEIC{i}{j}{\Mat{A}} intercambia las columnas.
  \end{description}
\end{NotMat2}

\paragraph{Comentario sobre la notación.} Como una trasformación
elemental se puede lograr mediante un producto con una matriz
elemental, \HLa{\bf la notación empleada busca parecerse a la notación
  del producto matricial}:
\begin{quotation}
  Al poner la \HLa{\emph{abreviatura}} ``$\TrEE$'' de la
  transformación elemental a derecha es como si multiplicáramos la
  matriz \Matdim{A}{m}{n} por la derecha por la correspondiente matriz
  elemental
  \begin{displaymath}
    \STEC[\TrEE]{\Mat{A}}=\Mat{A}\STEC[\TrEE]{\Mat{I}}=\Mat{A}\Mat{E}\quad \text{donde} \quad
    \Mat{E}=\STEC[\TrEE]{\Mat{I}}\quad \text{y donde la matriz \Mat{I} es de orden $n$}.
  \end{displaymath}

  De manera similar, al poner la \HLa{\emph{abreviatura}} ``$\TrEE$''
  de la transformación elemental a izquierda, es como si
  multiplicáramos la matriz \Matdim{A}{m}{n} por la izquierda por la
  correspondiente matriz elemental
  \begin{displaymath}
    \STEF[\TrEE]{\Mat{A}}=\STEF[\TrEE]{\Mat{I}}\Mat{A}=\Mat{E}\Mat{A}\quad \text{donde} \quad
    \Mat{E}=\STEF[\TrEE]{\Mat{I}}\quad \text{y donde la matriz \Mat{I} es de orden $m$}.
  \end{displaymath}
\end{quotation}
Con ello se gana, entre otras cosas, que la notación sea
asociativa. Pero entonces\dots \HLa{¿qué ventaja tiene introducir en
  el discurso las transformaciones elementales en lugar de utilizar
  simplemente matrices elementales?}
\medskip

Fíjese que una matriz cuadrada es un objeto muy pesado\dots $n^2$
coeficientes para una matriz de orden $n$. Afortunadamente una matriz
elemental es casi una matriz identidad salvo por uno de sus elementos;
por tanto, para describir completamente una matriz elemental basta
indicar su orden $n$ y qué componente que no coincide con los de la
matriz $\Mat{I}$ de orden $n$.~\footnote{Fíjese que la notación usada
  en las notas de la asignatura para las matrices elementales \Mat{E},
  no las describe completamente (se deja al lector la deducción de
  cuál es el orden \Mat{E} adecuado para poder realizar el producto
  $\Mat{A}\Mat{E}$ o el producto \MN{E}{A})}
\begin{center}
  La ventaja es que \HLa{las transformaciones elementales omiten el orden $n$}.
\end{center}
Vamos a definir la siguiente traducción de esta notación a Python:
\begin{displaymath}
  \begin{array}{|ll||rr|}
    \hline
    \text{Mates II}&\text{Python} & \text{Mates II}&\text{Python}\\
    \hline\hline
    \TEIC{i}{j}{\Mat{A}}     & \text{{\tt A \& T( \{i,j\} ) }} &
    \TEIF{i}{j}{\Mat{A}}     & \text{{\tt T( \{i,j \} ) \& A}}\\ \hline
    \TEPC{a}{j}{\Mat{A}}     & \text{{\tt A \& T( (a,j) ) }} &
    \TEPF{a}{j}{\Mat{A}}     & \text{{\tt T( (a,j) ) \& A}}\\ \hline
    \TESC{a}{i}{j}{\Mat{A}}  & \text{{\tt A \& T( (a,i,j) ) }} &    
    \TESF{a}{i}{j}{\Mat{A}}  & \text{{\tt T( (a,i,j) ) \& A}}\\ \hline
  \end{array}
\end{displaymath}

Vemos que:
\begin{enumerate}
\item Representar el intercambio con un conjunto, permite admitir la repetición del
  índice $\{i,i\}=\{i\}$ como un caso especial en el que la matriz no cambia. Esto
  simplificará el método de Gauss.
\item Tanto para los pares [[(a,i)]] como para las ternas [[(a,i,j)]]:
  \begin{enumerate}
  \item La columna (fila) que cambia es la del índice que aparece en última posición.
  \item El escalar de la primera posición multiplica a la columna
    (fila) correspondiente al índice que le precede.
  \end{enumerate}
\end{enumerate}
@
Empleando listas de abreviaturas extendemos la notación para expresar
secuencias de transformaciones elementales, es decir,
\begin{math}
  \TrEE_{1}\cdots\TrEE_{k}.
\end{math}
Así logramos la siguiente equivalencia entre expresiones
\begin{displaymath}
  \text{\tt{T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}}
  \quad = \quad
  \text{\tt{T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] )}}
\end{displaymath}
De esta manera
\begin{eqnarray*}
  \STEC{\Mat{A}}:\qquad &
  \Mat{A} \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
  \;=\; \Mat{A} \text{\tt{ \& T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] )}}
  \\\\
  \SSTEF{k}{1}{\Mat{A}}:\qquad &
  \text{\tt{ T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{) \& }} \Mat{A}
  \;=\; \text{\tt{ T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] ) \& }} \Mat{A}.
\end{eqnarray*}
@
Así, usando abreviaturas y si \Mat{A} es de orden $m\times n$, el primer caso es equivalente a escribir el producto de matrices
\begin{displaymath}
  \STEC{\Mat{A}}\;=\;\Mat{A}\Mat[1]{E}\Mat[2]{E}\cdots\Mat[k]{E}
  \qquad
  \text{donde $\Mat[j]{E}=\STEC[\TrEE_j]{\Mat{I}}$ y donde \Mat{I} es de orden $n$};
\end{displaymath}
y el segundo caso es equivalente a escribir el producto de matrices
\begin{displaymath}
  \SSTEF{k}{1}{\Mat{A}}
  \;=\;
  \Mat[1]{E}\Mat[2]{E}\cdots\Mat[k]{E}\Mat{A}
  \qquad
  \text{donde $\Mat[i]{E}=\STEF[\TrEE_i]{\Mat{I}}$ y donde \Mat{I} es de orden $m$.}
\end{displaymath}
\dots ¡Pero gracias a las abreviaturas no hemos necesitado indicar el orden de las matrices elementales en ningún momento!

\begin{codigo}%[nobreak=true] 
<<Texto de ayuda de la clase [[T]] (Transformación Elemental)>>=
"""Clase T

T ("Transformación elemental") guarda en su atributo 't' una abreviatura
(o una secuencia de abreviaturas) de transformaciones elementales. El 
método __and__ actúa sobre otra T para crear una T que es composición de 
transformaciones elementales (una la lista de abreviaturas), o bien actúa 
sobre una Matrix (para transformar sus filas).

Atributos:
    t (set)  : {índice, índice}. Abrev. de un intercambio entre los 
      	         vectores correspondientes a dichos índices
      (tuple): (escalar, índice). Abrev. transf. Tipo II que multiplica
      	         el vector correspondiente al índice por el escalar
             : (escalar, índice1, índice2). Abrev. transformación Tipo I
	       	 que suma al vector correspondiente al índice2 el vector
		 correspondiente al índice1 multiplicado por el escalar
      (list) : Lista de conjuntos y tuplas. Secuencia de abrev. de
      	         transformaciones como las anteriores. 
      (T)    : Transformación elemental. Genera una T cuyo atributo t es
                 una copia del atributo t de la transformación dada 
      (list) : Lista de transformaciones elementales. Genera una T cuyo 
                 atributo es la concatenación de todas las abreviaturas
Ejemplos:
>>> # Intercambio entre vectores
>>> T( {1,2} )

>>> # Trasformación Tipo II (multiplica por 5 el segundo vector)
>>> T( (5,2) )

>>> # Trasformación Tipo I (resta el tercer vector al primero)
>>> T( (-1,3,1) )

>>> # Secuencia de las tres transformaciones anteriores
>>> T( [{1,2}, (5,2), (-1,3,1)] )

>>> # T de una T
>>> T( T( (5,2) ) )

T( (5,2) )

>>> # T de una lista de T's
>>> T( [T([(-8, 2), (2, 1, 2)]), T([(-8, 3), (3, 1, 3)]) ] )

T( [(-8, 2), (2, 1, 2), (-8, 3), (3, 1, 3)] )
"""
@
\end{codigo}

\subsection{Implementación}
Python ejecuta las órdenes de izquierda a derecha. Fijándonos en la
expresión
\begin{displaymath}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
\end{displaymath}
podríamos pensar que podemos implementar la transformación elemental
como un método de la clase [[Matrix]]. Así, al definir el método
\Verb/__and__/ por la derecha de la matriz podemos indicar que
\begin{math}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{)}}
\end{math}
es una nueva matriz con las columnas modificadas. Python no tiene
problema en ejecutar
\begin{math}
  \Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{)}} 
\end{math}
pues ejecutar de izquierda a derecha, es lo mismo que ejecutar
\begin{math}
  \Bigg[\Big[\big[\Mat{A}\ \text{\tt{ \& T(}}\ t_1 \text{\tt{)}}\big] \text{\tt{\& T(}}\ t_2\ \text{\tt{)}} \Big] \text{\tt{\&}} \cdots \Bigg]\text{\tt{\& T(}}\ t_k  \text{\tt{)}}
\end{math}
donde la expresión dentro de cada corchete es una [[Matrix]], por lo
que las operaciones están bien definidas. La dificultad aparece con
\begin{displaymath}
  \text{\tt{ T(}}\ t_1 \text{\tt{) \& T(}}\ t_2\ \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_k \text{\tt{) \& }} \Mat{A}
  %\text{\tt{T(}}\ t_k \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_2\ \text{\tt{) \& T(}}\ t_1 \text{\tt{) \& }}  \Mat{A}
\end{displaymath}
Lo primero que Python tratara de ejecutar es
\begin{math}
    \text{\tt{T(}}\ t_1\ \text{\tt{) \& T(}} \ t_2 \text{\tt{)}},
\end{math}
pero ni $\text{\tt{T(}}\ t_1 \text{\tt{)}}$ ni
$\text{\tt{T(}}\ t_2 \text{\tt{)}}$ son matrices, por lo que esto
no puede ser programado como un método de la clase [[Matrix]].
\smallskip

Así pues, definiremos una nueva clase que almacene las
\HLa{\emph{abreviaturas}} ``$t_i$'' %``$\TrEE$'' de las operaciones
elementales, de manera que podamos definir
\begin{math}
  \text{\tt{T(}}\ t_i\ \text{\tt{) \& T(}} \ t_j \text{\tt{)}},
\end{math}
como un método que ``compone'' dos transformaciones elementales para
formar una secuencia de abreviaturas (que en última instancia será una
secuencia de operaciones a ejecutar sobre una [[Matrix]]).  \smallskip

El nuevo objeto, [[T]] (``transformación elemental''), nos permitirá
encadenar transformaciones elementales (es decir, almacenar una lista
de abreviaturas). El siguiente código inicializa la clase. El atributo
[[t]] almacenará la abreviatura (o lista de abreviaturas) dada al
instanciar [[T]] o bien creará la lista de abreviaturas a partir de
otra [[T]] (o lista de [[T]]s) empleada para instanciar.
\begin{codigo}
<<Inicialización de la clase [[T]] (Transformación Elemental)>>=
def __init__(self, t, rpr='v'):
    """Inicializa una transformación elemental"""
    <<Método auxiliar [[CreaLista]] que devuelve listas de abreviaturas>>
    <<Creación del atributo [[t]] cuando se instancia con otra [[T]] o lista de [[T]]s>>
    else:
	self.t = t
    <<Verificación de que las abreviaturas corresponden a transformaciones elementales>>
    self.rpr = rpr

@
\end{codigo}
Un transformación elemental no puede multiplicar por cero, ni sumar a
un elemento un múltiplo de si mismo. Además, un intercambio solo tiene sentido
a lo sumo entre dos elementos.
\begin{codigo}
<<Verificación de que las abreviaturas corresponden a transformaciones elementales>>=
for j in CreaLista(self.t):
    if isinstance(j,tuple) and (len(j) == 2) and j[0]==0:
        raise ValueError('T( (0, i) ) no es una trasformación elemental')
    if isinstance(j,tuple) and (len(j) == 3) and (j[1] == j[2]):
        raise ValueError('T( (a, i, i) ) no es una trasformación elemental')
    if isinstance(j,set) and (len(j) > 2) or not j:
        raise ValueError \
	('El conjunto debe tener uno o dos índices para ser un intercambio')
@             
\end{codigo}

Con la composición de transformaciones elementales requeriremos operar
con listas de abreviaturas. El siguiente procedimiento \emph{crea la
  lista} [[[t]]] que contiene a [[t]] (cuando [[t]] no es una lista),
si [[t]] es una lista, el procedimiento no hace nada. Lo usaremos al
instanciar [[T]] con una lista de [[T]]s; y al componer
transformaciones elementales.
\begin{codigo}
<<Método auxiliar [[CreaLista]] que devuelve listas de abreviaturas>>=
def CreaLista(t):
    """Devuelve t si t es una lista; si no devuelve la lista [t]"""
    return t if isinstance(t, list) else [t]
    
@ %def CreaLista
\end{codigo}

%\pagebreak[4]

\subsubsection{Composición de \texttt{T}ransf. element. o llamada
  al método de transformación de filas de una \texttt{Matrix}}
\begin{codigo}
<<Texto de ayuda para la composición de Transformaciones Elementales [[T]]>>=
"""Composición de transformaciones elementales (o transformación filas)

Crea una T con una lista de abreviaturas de transformaciones elementales
(o llama al método que modifica las filas de una Matrix)

Parámetros:
    (T): Crea la abreviatura de la composición de transformaciones, es
         decir, una lista de abreviaturas
    (Matrix): Llama al método de la clase Matrix que modifica sus filas

Ejemplos:
>>> # Composición de dos Transformaciones elementales
>>> T( {1, 2} ) & T( (2, 4) )

T( [{1,2}, (2,4)] )

>>> # Composición de dos Transformaciones elementales
>>> T( {1, 2} ) & T( [(2, 4), (2, 1), {3, 1}] )

T( [{1, 2}, (2, 4), (2, 1), {3, 1}] )

>>> # Transformación de las filas de una Matrix
>>> T( [{1,2}, (4,2)] ) & A # multiplica por 4 la segunda fila de A y
                            # luego intercambia las dos primeras filas
"""        
@   
\end{codigo}
Describimos la composición de transformaciones
\begin{math}
  \text{\tt{T(}}t_1\text{\tt{) \& T(}}t_{2}\text{\tt{)}}
\end{math}
creando una lista de abreviaturas \texttt{[}$t_1,t_2$\texttt{]}
(mediante la concatenación de listas)\footnote{Recuerde que la suma de
  listas (\texttt{list + list}) concatena las listas}. Si [[other]] es
un [[Vector]] o una [[Matrix]], se llama al método \Verb/__rand__/ de
la clase [[other]]\; (que transformará los elementos del vector en el
primer caso, y las filas de la matriz en el segundo; y que veremos más
adelante).
\begin{codigo}[nobreak=true]
<<Composición de Transformaciones Elementales o aplicación sobre las filas de una [[Matrix]]>>=
def __and__(self, other):
    <<Texto de ayuda para la composición de Transformaciones Elementales [[T]]>>
    <<Método auxiliar [[CreaLista]] que devuelve listas de abreviaturas>>
    if isinstance(other, T):
        return T(CreaLista(self.t) + CreaLista(other.t), self.rpr)

    if isinstance(other, (Vector, Matrix)):
        return other.__rand__(self)

@ 
\end{codigo}

\subsection{Transposición de transformaciones elementales}

Puesto que
\begin{math}
  \;\SSTEC{1}{k}{\Mat{I}}=(\Mat{E}_1\dotsm\Mat{E}_k)\;
\end{math}
y puesto que el producto de matrices es asociativo, deducimos que la
transpuesta de \STEC[\TrEE_1\TrEE_2\cdots\TrEE_k]{\Mat{I}} es
\begin{displaymath}
  \big(\STEC[\TrEE_1\TrEE_2\cdots\TrEE_k]{\Mat{I}}\big)^\T
  \;=\;
  (\Mat{I}\Mat[1]{E}\dotsm\Mat[k]{E})^\T
  \;=\;
  \MatT[k]{E}\dotsm\MatT[1]{E}\Mat{I}
  \;=\;\STEF[\TrEE_k\cdots\TrEE_2\TrEE_1]{\Mat{I}}
\end{displaymath}
% \STEF[\TrEE_k\cdots\TrEE_2\TrEE_1]{\Mat{I}}\;
Nótese cómo al transponer no solo cambiamos de lado los subíndices,
sino también invertimos el orden de la secuencia de transformaciones
(de la misma manera que también cambia el orden en el que se
multiplican las matrices elementales).  Esto sugiere denotar a la
operación de invertir el orden de las transformaciones como una
transposición:
\begin{displaymath}
  (\TrEE_1\cdots\TrEE_k)^\T = \TrEE_k\cdots\TrEE_1;
\end{displaymath}
así
\begin{displaymath}
  \hphantom{\STEF[\TrEE_k\cdots\TrEE_1]{\MatT{A}}}\qquad\hphantom{=}\qquad
  \big(\STEC[\TrEE_1\cdots\TrEE_k]{\Mat{A}}\big)^\T=
  \STEF[(\TrEE_1\cdots\TrEE_k)^\T]{\MatT{A}} \qquad=\qquad
  \STEF[\TrEE_k\cdots\TrEE_1]{\MatT{A}}
\end{displaymath}
\HLa{¡Fíjese como efectivamente hemos logrado que la notación con abreviaturas se comporte como la notación matricial!}
\medskip

El siguiente procedimiento invierte el orden de la lista cuando [[t]]
es una lista de abreviaturas. Cuando [[t]] es una única abreviatura,
no hace nada.
\begin{codigo}
<<Operador transposición para la clase [[T]]>>=  
def __invert__(self):
    """Transpone la lista de abreviaturas (invierte su orden)"""
    return T( list(reversed(self.t)), self.rpr) if isinstance(self.t, list) else self
    
@ 
\end{codigo}

% #return T([ ~j if isinstance(j, T) else j for j in list(reversed(self.t)) ])

\subsection{Potencias e inversa de transformaciones elementales}
Cualquier matriz de la forma \STEC{\Mat{I}} o de la forma
\STEF{\Mat{I}} es invertible por ser producto de matrices elementales:
\begin{displaymath}
  \Big(\STEC{\Mat{I}}\Big)\Big(\STEC[\TrEE^{-1}_{k}\cdots\TrEE^{-1}_{1}]{\Mat{I}}\Big)=
  \Mat[1]{E}\cdots\Mat[k]{E}\cdot\InvMat[k]{E}\cdots\InvMat[1]{E}=
  \STEC[\TrEE_1\cdots\TrEE_k\cdot\TrEE^{-1}_{k}\cdots\TrEE^{-1}_{1}]{\Mat{I}}=
  \Mat{I};
\end{displaymath}
por lo que podemos denotar por $\Big(\TrEE_1\cdots\TrEE_k\Big)^{-1}$ a
la sucesión de transformaciones $\TrEE^{-1}_{k}\cdots\TrEE^{-1}_{1}$. De este modo
\begin{displaymath}
  \Big(\STEC{\Mat{I}}\Big)^{-1}=\STEC[(\TrEE_1\cdots\TrEE_k)^{-1}]{\Mat{I}}.
\end{displaymath}
El siguiente método devuelve la potencia [[n]]-ésima de una
transformación elemental. Si [[n]] es $-1$, calcula la inversa:
\begin{center}
\Verb/T([ (1, 2, 3), (fracc(1,3), 2), {1, 2} ]) **(-1)/
\end{center}
nos devuelve
\begin{center}
\Verb/T([ {1, 2}, (3, 2), (-1, 2, 3) ])/
\end{center}
Al implementar el método, definimos la potencia de manera recursiva
(con una función auxiliar [[lambda]]). Además, si [[n]] es cero,
devolveremos una transformación que no haga nada (identidad); por ejemplo
$\underset{\begin{subarray}{c}\left[\mathbf{1}\rightleftharpoons\mathbf{1}\right]\end{subarray}}{\TrEE}$.
\begin{codigo}
<<Potencia de una [[T]]>>=
def __pow__(self,n):
    """Calcula potencias de una T (incluida la inversa)"""
    <<Método auxiliar que calcula la inversa de una [[T]]ransformación elemental>>    
    if not isinstance(n,int):
        raise ValueError('La potencia no es un entero')

    potencia = lambda x, n: x if n==1 else x & potencia(x, n-1)
    t = potencia(self,abs(n)) if n!=0  else  T({1})
    
    return t if n>0 else Tinversa(t)
        
@ 
\end{codigo}

\begin{codigo}
<<Método auxiliar que calcula la inversa de una [[T]]ransformación elemental>>=
def Tinversa ( self ):
    """Calculo de la inversa de una transformación elemental"""
    <<Método auxiliar [[CreaLista]] que devuelve listas de abreviaturas>>

    listaT = [          j            if isinstance(j,set) else \
               ( -j[0], j[1],  j[2]) if len(j)==3         else \
               (fracc(1,j[0]), j[1])              for j in CreaLista(self.t) ]

    return ~T( listaT, self.rpr)

@ 
\end{codigo}

\subsection{Transformaciones elementales ``espejo''}
Al diagonalizar por semejanza, y aplicar transformaciones elementales
por la derecha, que es lo mismo que multiplicar por una matriz
invertible por la derecha, necesitaremos expresar la correspondiente
matriz inversa mediante una secuencia de transformaciones elementales
de la filas de la matriz identidad. Esto se logra con el método
[[espejo]].~\footnote{Al no encontrar ningún nombre en los manuales de
  Álgebra Lineal para este concepto, he adoptado este descriptivo
  nombre.}

\begin{codigo}
<<[[T]]ransformación elemental \emph{espejo} de una [[T]]>>=
def espejo ( self ):
    """Calculo de la transformación elemental espejo de otra"""
    <<Método auxiliar [[CreaLista]] que devuelve listas de abreviaturas>>
    return T([(j[0],j[2],j[1]) if len(j)==3 else j for j in CreaLista(self.t)],self.rpr)
    
@ 
\end{codigo}
@

\paragraph{La clase \texttt{T}} junto con el listado de sus métodos
aparece en el siguiente recuadro:
\begin{codigo}[nobreak=true]
<<Definición de la clase [[T]] (Transformación Elemental)>>=
class T:
    <<Texto de ayuda de la clase [[T]] (Transformación Elemental)>>
    <<Inicialización de la clase [[T]] (Transformación Elemental)>>
    <<Composición de Transformaciones Elementales o aplicación sobre las filas de una [[Matrix]]>>
    <<Operador transposición para la clase [[T]]>>
    <<Potencia de una [[T]]>>
    <<[[T]]ransformación elemental \emph{espejo} de una [[T]]>>
    <<Representación de la clase [[T]]>>
@ %def T
\end{codigo}

\pagebreak[4]

\section{Transformaciones elementales de un \texttt{Sistema}}
En el segundo Tema de las notas de la asignatura, se definen las
transformaciones elementales sobre [[Sistema]]s como una
generalización a las transformaciones elementales de las columnas de
una [[Matrix]]. Puesto que cada [[Matrix]] es un [[Sistema]] de
vectores, en la librería vamos a comenzar con las transformaciones
elementales de un [[Sistema]].

\begin{codigo}
<<Texto de ayuda de las transformaciones elementales de un [[Sistema]]>>=
"""Transforma los elementos de un Sistema S

Atributos:
    t (T): transformaciones a aplicar sobre un Sistema S
Ejemplos:
>>>  S & T({1,3})                # Intercambia los elementos 1º y 3º
>>>  S & T((5,1))                # Multiplica por 5 el primer elemento
>>>  S & T((5,2,1))              # Suma 5 veces el elem. 1º al elem. 2º
>>>  S & T([{1,3},(5,1),(5,2,1)])# Aplica la secuencia de transformac.
             # sobre los elementos de S y en el orden de la lista
"""
@
\end{codigo}
\paragraph{Implementación} de la aplicación de las transformaciones
elementales sobre los elementos de un [[Sistema]] (nótese que hemos
incluido el intercambio, aunque usted ya sabe que es una composición
de los otros dos tipos de transf.)
\begin{codigo}[nobreak=true]
<<Transformaciones elementales de los elementos de un [[Sistema]]>>=  
def __and__(self,t):
    <<Texto de ayuda de las transformaciones elementales de un [[Sistema]]>>
    if isinstance(t.t,set):
        self.lista = [ (self|max(t.t)) if k==min(t.t) else \
                       (self|min(t.t)) if k==max(t.t) else \
                       (self|k)                 for k in range(1,len(self)+1)].copy()

    elif isinstance(t.t,tuple) and (len(t.t) == 2):
	self.lista = [ (t.t[0])*(self|k)                  if k==t.t[1] else \
                       (self|k)                 for k in range(1,len(self)+1)].copy()

    elif isinstance(t.t,tuple) and (len(t.t) == 3):
        self.lista = [ (t.t[0])*(self|t.t[1]) + (self|k)  if k==t.t[2] else \
                       (self|k)                 for k in range(1,len(self)+1)].copy()
    
    elif isinstance(t.t,list):
        for k in t.t:          
            self & T(k)
    
    return self
        
@
%elif isinstance(t.t,list):
%    aux = lambda S, x: S if len(x)==0 else aux(S & T([x[0]]), x[1:])
%    aux(self,t.t)    
\end{codigo}

\begin{observacion}
  Al actuar sobre [[self.lista]], las transformaciones elementales
  modifican los [[Sistema]]s.
\end{observacion}

\subsection{Transformaciones elementales de las filas de una \texttt{Matrix}}
\begin{codigo}
<<Texto de ayuda de las transformaciones elementales de las filas de una [[Matrix]]>>=
"""Transforma las filas de una Matrix

Atributos:
    t (T): transformaciones a aplicar sobre las filas de Matrix

Ejemplos:
>>>  T({1,3})   & A               # Intercambia las filas 1 y 3
>>>  T((5,1))   & A               # Multiplica por 5 la fila 1
>>>  T((5,2,1)) & A               # Suma 5 veces la fila 2 a la fila 1
>>>  T([(5,2,1),(5,1),{1,3}]) & A # Aplica la secuencia de transformac.
            # sobre las filas de A y en el orden inverso al de la lista
"""
@
\end{codigo}

Para implementar las transformaciones elementales de las filas usamos
el truco de aplicar las operaciones sobre las columnas de la
transpuesta y de nuevo transponer el resultado: %
\Verb/~(~self & t)/.\; Pero hay que recordar que las transformaciones
más próximas a la matriz se ejecutan primero, puesto que
\begin{math}
  \;\SSTEF{k}{1}{\Mat{A}}
  \;=\;
  \Mat[1]{E}\Mat[2]{E}\cdots\Mat[k]{E}\Mat{A}.\;
\end{math}
Con la función
\texttt{reversed} aplicamos la sucesión de transformaciones en el
orden inverso a como aparecen en la lista:
\begin{displaymath}
  \text{\tt{T( [}} t_1 \text{\tt{,}} t_2 \text{\tt{,}} \ldots \text{\tt{,}} t_k \text{\tt{] ) \& }} \Mat{A}
  \quad=\quad
  \text{\tt{T(}}\ t_1 \text{\tt{) \&}} \cdots \text{\tt{\& T(}}\ t_{k-1}\ \text{\tt{) \& T(}}\ t_k \text{\tt{) \& }}  \Mat{A}
\end{displaymath}
@
\begin{codigo}
<<Transformaciones elementales de las filas de una [[Matrix]]>>=
def __rand__(self,t):
    <<Texto de ayuda de las transformaciones elementales de las filas de una [[Matrix]]>>
    
    if isinstance(t.t, (set, tuple) ):
        self.lista = (~(~self & t)).lista.copy()
    
    elif isinstance(t.t,list):
        for k in reversed(t.t):          
            T(k) & self
    
    return self 
    
@
\end{codigo}

\begin{observacion}
  Al actuar sobre [[self.lista]], las transformaciones elementales
  modifican la [[Matrix]].
\end{observacion}

\subsection{Transformaciones elementales por la izquierda de un \texttt{Vector}}
Hacen lo mismo que por la derecha (como ocurre con el operador selector)
\begin{codigo}
<<Transformaciones elementales por la izquierda de un [[Vector]]>>=
def __rand__(self,t):
    """Hace exactamente lo mismo que el método __and__ por la derecha."""
    return self & t
    
@
\end{codigo}

\begin{observacion}
  Las transformaciones elementales modifican el [[Vector]].
\end{observacion}

\clearpage

\section{Librería completa}

Finalmente creamos la librería \texttt{nacal.py} concatenando los
trozos de código que se describen en este fichero de documentación.
%(recuerde que el número que aparece detrás de nombre de cada trozo de
%código indica la página donde encontrar el código en este documento).
\medskip

Para que los [[Vector]]es funcionen como un espacio vectorial,
importamos la librería
\href{https://www.sympy.org/en/index.html}{Sympy} con el código:
\begin{center}
\verb/import sympy/
\end{center}
Así podremos usar números racionales e irracionales (incluso el cuerpo
de polinomios). Como queremos que la librería emplee números
racionales siempre que sea posible, definimos tres métodos auxiliares:
[[fracc(a/b)]] es la fracción $\frac{a}{b}$; [[numer(a,b)]]; y
[[denom(a,b)]] (véase la página siguiente). Para usar el número
racional $\frac{1}{3}$ escribiremos [[fracc(1,3))]], y para usar un
número irracional como $\sqrt{2}$ escribimos [[sympy.sqrt(2)]]. La
librería \href{https://www.sympy.org/en/index.html}{Sympy} ya se ocupa
de que Jupyter represente adecuadamente estos objetos (incluso
simplificando expresiones, de manera que si escribimos el número
irracional [[fracc(2,sympy.sqrt(2))]], es decir $\frac{2}{\sqrt{2}}$,
Jupyter lo simplificara, representándolo como $\sqrt{2}$).
\begin{codigo}
%#from fractions import Fraction
%##Pinta un objeto en Jupyter>>                      
<<nacal.py>>=
# coding=utf8
import sympy
from IPython.display import display, Math
<<Métodos auxiliares para usar coeficientes racionales cuando sea posible>>

<<Método html general>>
<<Método latex general>>
<<Simplificación de expresiones simbólicas>>
<<Filtrado de secuencias de transformaciones>>
<<Pinta un objeto en Jupyter>>
           
<<Definición de la clase [[Sistema]]>>
<<Definición de la clase [[Vector]]>>
<<Definición de la clase [[Matrix]]>>
<<Definición de la clase [[T]] (Transformación Elemental)>>
                       
<<Definición del vector nulo: [[V0]]>>
<<Definición de la matriz nula: [[M0]]>>
<<Definición de la matriz identidad: [[I]]>>

<<Definición del método [[particion]]>>
<<Definición del procedimiento de generación del conjunto clave para particionar>>
<<Definición de la clase [[SisMat]]>>
<<Definición de la clase [[BlockM]]>>

<<Tres métodos de eliminación por columnas>>
<<Tres métodos de eliminación por filas>>
<<Representación de un proceso de eliminación>>
<<Invirtiendo una matriz>>
<<La clase SubEspacio>>
<<La clase EAfin>>
<<Resolviendo un sistema homogéneo>>
<<Resolviendo un Sistema de Ecuaciones Lineales>>
<<Calculando el determinante>>
<<Diagonalizando una matriz por bloques triangulares (semejanza)>>
<<Diagonalizando ortogonalmente una matriz simétrica>>
<<Diagonalizando una matriz por congruencia>>
@
\end{codigo}

\begin{codigo}
<<Métodos auxiliares para usar coeficientes racionales cuando sea posible>>=
def fracc(a,b):
    """Transforma la fracción a/b en un número racional si ello es posible"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return sympy.Rational(a, b)
    else:
        return a/b
    
def numer(a,b):
    """Devuelve el numerador de a/b si la fracción es un número racional,
       si no devuelve a/b"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return fracc(a,b).p
    else:
        return a/b 

def denom(a,b):
    """Devuelve el denominador de a/b si la fracción es un número
       racional, si no devuelve 1"""
    if all( [ isinstance(i, (int, float, sympy.Rational) ) for i in (a,b) ] ):
        return fracc(a,b).q
    else:
        return 1
    
@ %def fracc numer denom
\end{codigo}

\begin{Notebook}
  \begin{center}
    Consulte el Notebook sobre el
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FNotebook.ipynb}{\textbf{uso de la librería \texttt{nacal}}}
    %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F03_UsoLibreria.ipynb}{\textbf{uso de nuestra librería para Mates 2}}
      en la carpeta
      \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2F}{``Notebooks''}
        en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks}.
        %\url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks}
  \end{center}
\end{Notebook}
\begin{Notebook}
  \begin{center}
    En el siguiente enlace:
    \medskip
    
    \url{https://github.com/mbujosab/nacal-Jupyter-Notebooks}
    \medskip

    puede ver Notebooks correspondientes a las distintas lecciones de
    mi curso de Álgebra Lineal (Matemáticas II), y los puede ejecutar
    online en
    \href{https://mybinder.org/v2/gh/mbujosab/nacal-Jupyter-Notebooks/master}{mybinder.org}
  \end{center}
\end{Notebook}

%Para empaquetar esta librería en el futuro: \url{https://packaging.python.org/tutorials/packaging-projects/}

\chapter{Algoritmos del curso}
\label{part:Algoritmos}

%\section{Eliminación}

En el curso usamos tres métodos de eliminación. La \emph{eliminación}
por columnas de izquierda a derecha encuentra una matriz
pre-escalonada (todos los componentes a la derecha de los pivotes son
cero), la \emph{eliminación Gaussiana} por columnas nos da una forma
escalonada \Mat{L} (al reordenar las columnas de la matriz
pre-escalonada), y la \emph{eliminación Gauss-Jordan} por columnas nos
da la forma escalonada reducida por columnas \Mat{R}, (los componentes
a derecha e izquierda de los pivotes son cero y cada pivote es igual a
1). Es decir, los últimos métodos modifican las matrices obtenidas con
los métodos anteriores:
\begin{itemize}
\item La eliminación encuentra los pivotes (matriz pre-escalonada). % y muestra las relaciones
                                            % de dependencia entre las
                                            % columnas de izquierda a
                                            % derecha.

\item La eliminación Gaussiana reordena las columnas de la matriz
  pre-escalonada para obtener una escalonada.
  % \begin{displaymath}
  %   \begin{bmatrix}0&1&1\\7&-3&0\\6&4&2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(-1\right)\mathbf{2}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&-3&3\\6&4&-2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(\frac{3}{7}\right)\mathbf{1}+\mathbf{2} \right]\\\left[\left(\frac{-3}{7}\right)\mathbf{1}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&0&0\\6&\frac{46}{7}&\frac{-32}{7}\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}1&0&0\\0&7&0\\\frac{46}{7}&6&\frac{-32}{7}\end{bmatrix}
  % \end{displaymath}

\item La eliminación Gauss-Jordan reduce la matriz escalonada.
  % \begin{center}
  %   \begin{math}
  %     \begin{bmatrix}0&1&1\\7&-3&0\\6&4&2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(-1\right)\mathbf{2}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&-3&3\\6&4&-2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(\frac{3}{7}\right)\mathbf{1}+\mathbf{2} \right]\\\left[\left(\frac{-3}{7}\right)\mathbf{1}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&0&0\\6&\frac{46}{7}&\frac{-32}{7}\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\mathbf{1}\rightleftharpoons\mathbf{2}\right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}1&0&0\\0&7&0\\\frac{46}{7}&6&\frac{-32}{7}\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(\frac{23}{16}\right)\mathbf{3}+\mathbf{1} \right]\\\left[\left(\frac{21}{16}\right)\mathbf{3}+\mathbf{2} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}1&0&0\\0&7&0\\0&0&\frac{-32}{7}\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(\frac{1}{7}\right)\mathbf{2}\right]\\\left[\left(\frac{-7}{32}\right)\mathbf{3}\right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}1&0&0\\0&1&0\\0&0&1\end{bmatrix}
  %   \end{math}
  % \end{center}
\end{itemize}

Pero antes veamos la operación de búsqueda de pivotes
\subsection*{Búsqueda de pivotes}
En las notas de clase llamamos {\em pivote} de una columna (no nula) a
su primer componente no nulo; y {\em posición de pivote} al índice de
la fila en la que está el pivote. Vamos a generalizar esta definición
y decir sencillamente que llamamos {\em pivote} de un [[Vector]] (no
nulo) a su primer componente no nulo; y {\em posición de pivote} al
índice de dicho componente (así podremos usar la definición de pivote
tanto si programamos el método de eliminación por filas como por
columnas).

Por conveniencia, el método [[ppivote]] nos indicará el \emph{primer
  índice} mayor que \texttt{k} de un componente no nulo del
[[Vector]].  Como por defecto [[k=0]], si no especificamos el valor de
[[k]], entonces [[ppivote]] nos devuelve la \emph{posición de pivote}
de un [[Vector]]. Si todos los componentes de índice mayor que [[k]]
son nulos, [[ppivote]] nos devuelve el valor cero. Así, si
\;$\Vect{a}=(0,\ 5,\ 0,\ 5)$,\; entonces
\begin{center}
  \Verb/ppivote(a)=2/;\qquad
  \Verb/ppivote(a,1)=2/;\qquad
  \Verb/ppivote(a,2)=4/;\qquad
  \Verb/ppivote(a,4)=0/.
\end{center}
Lo programaremos con una función auxiliar [[lambda]].~\footnote{véase
  documentación de Python.}

\subsubsection*{Búsqueda de nuevos pivotes}
Cada pivote debe estar situado en una columna diferente. Para lograr
que en todos los casos sea así, generamos el conjunto
[[colExcluida]] que contiene los índices de todas las columnas en
las que ya hemos encontrado un pivote. Inicialmente [[colExcluida]]
es un conjunto vacío; y cada vez que encontremos una columna con
pivote, su correspondiente índice [[p]] será incluido en este conjunto
con [[colExcluida.add(p)]]. De esta manera, para cada fila
buscaremos (con [[ppivote]]) un componente no nulo, y si dicho
componente se encuentra en una columna con pivote, buscaremos el
siguiente componente no nulo de la fila que esté en una columna no
ocupada por un pivote encontrado anteriormente. Si esto no es posible,
[[ppivote]] devolverá el valor [[0]] que no corresponde a ningún
índice de columna, por lo que habremos terminado de buscar.
\begin{codigo}[nobreak=true]
<<Definición del método auxiliar [[BuscaNuevoPivote]]>>=  
def BuscaNuevoPivote(self, r=0):
    ppivote = lambda v, k=0:\
              ( [i for i,c in enumerate(v, 1) if (c!=0 and i>k)] + [0] )[0]
    pp = ppivote(self, r)
    while pp in colExcluida:
        pp = ppivote(self, pp)
    return pp
@ %def BuscaNuevoPivote
\end{codigo}


\section{Operaciones empleadas las distintas variantes de eliminación}
\subsection{La operación de eliminación de componentes}
\label{sec:operacionesDeEliminacion}
La \textbf{eliminación} usa cada pivote para anular las componentes de
su fila situadas a su derecha. La eliminación Gauss-Jordan también
anula las componentes de su izquierda.

Indicaremos los componentes a eliminar con la función [[celim]] (que
definimos como una función auxiliar [[lambda]]):
\begin{itemize}
\item Para eliminar los componentes cuyo índice [[j]] es mayor que [[p]]
  (derecha del pivote):\quad \Verb/celim = lambda j: j > p/
% \item Para eliminar los componentes cuyo índice es
%   distinto de [[p]] (izda y dcha):\quad \Verb/elim = lambda j: j != p/
\item Para eliminar los componentes cuyo índice [[j]] es menor que [[p]]
  (izquierda del pivote):\quad \Verb/celim = lambda j: j < p/
\end{itemize}
Así, [[filter(celim, range(1,A.n+1))]] contendrá los índices de las
columnas sobre las que queremos operar.

\subsubsection{Usando únicamente transformaciones Tipo I} (Véase la
demostración de que toda matriz se puede pre-escalonar en las notas de
la asignatura). El siguiente ejemplo muestra las operaciones para una
matriz concreta:
\begin{displaymath}
  \begin{bmatrix}0&1&1\\7&-3&0\\6&4&2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(-1\right)\mathbf{2}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&-3&3\\6&4&-2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(\frac{3}{7}\right)\mathbf{1}+\mathbf{2} \right]\\\left[\left(\frac{-3}{7}\right)\mathbf{1}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&0&0\\6&\frac{46}{7}&\frac{-32}{7}\end{bmatrix}
\end{displaymath}
Con solo tres transformaciones elementales hemos pre-escalonado la
matriz. El coste de este método ha sido el uso de operaciones con
fracciones, ya que para eliminar el número $\HLa{b}$ usando el pivote
$\HLa{a\ne 0}$, la estrategia empleada ha sido:
\begin{displaymath}
  \HLa{b}-\left(\frac{b}{a}\right)\HLa{a}=0.
\end{displaymath}
En un paso se elimina $\HLa{b}$ restándole un múltiplo de $\HLa{a}$.
El método consiste en repetir, fila a fila el siguiente código:
\begin{codigo}[nobreak=true]
<<Uso del pivote para eliminar componentes con trasformaciones Tipo I>>=
Tr = T([ (-fracc(i|A|j, i|A|p), p, j) for j in filter(celim, range(1,A.n+1)) ])
@ 
\end{codigo}
donde [[i]] es el índice de la fila en la que se está trabajando para
eliminar componentes, [[p]] es el índice de la columna donde se
encuentra el pivote y [[j]] recorre la lista de índices
correspondientes a las columnas de los componentes a eliminar (tal
como se ha descrito la función [[celim]]), de manera que se define la
sucesión de transformaciones
\begin{displaymath}
  \TrE{\su{\frac{-a_{ij}}{a_{ip}}}{p}{j}},\quad
  \text{con $\pmb{j}$ recorriendo las columnas a la derecha del pivote (si eliminamos de izda a dcha)}
\end{displaymath}
donde\; [[i|A|j]]\; es el componente\; $a_{ij}$,\; a eliminar y\;
[[i|A|p]]\; es el pivote\; $a_{ip}$. Tras definir las trasformaciones
elementales [[Tr]], se apuntan y se aplican sobre las columnas.

\subsubsection{Usando transformaciones Tipo I y II para evitar las
  fracciones cuando sea posible.} Para escalonar una matriz cuyos
componentes son números enteros no es necesario trabajar con
fracciones. Por ejemplo
\begin{displaymath}
  \begin{bmatrix}0&1&1\\7&-3&0\\6&4&2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(-1\right)\mathbf{2}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&1&0\\7&-3&3\\6&4&-2\end{bmatrix}\xrightarrow{\underset{\begin{subarray}{c} \left[\left(7\right)\mathbf{2}\right]\\\left[\left(3\right)\mathbf{1}+\mathbf{2} \right]\\\left[\left(7\right)\mathbf{3}\right]\\\left[\left(-3\right)\mathbf{1}+\mathbf{3} \right]\end{subarray}}{\mathbf{\tau}}}\begin{bmatrix}0&7&0\\7&0&0\\6&46&-32\end{bmatrix}
\end{displaymath}
Con este procedimiento, aunque se realizan más transformaciones
elementales, se evita el uso de fracciones (siempre y cuando la matriz
sea entera).  La estrategia consiste en eliminar el número $\HLa{b}$
usando el pivote $a\ne0$ encadenando dos operaciones:
\begin{displaymath}
  -a(\HLa{b})\;+\;b(\HLa{a}).
\end{displaymath}
Es decir, multiplicamos $\HLa{b}$ por $-a$ y luego sumamos
$b\HLa{a}$. Con esta idea podemos aplicar la sucesión de pares de
transformaciones elementales Tipo II y Tipo I:
\begin{center}
  \Verb/  (-(i|A|p),    j)   # Tipo II /
  \hphantom{\qquad es decir,\;
    \begin{math}
      \TrE{\pr{-a_{ip}}{j}}\;
      \TrE{\su{a_{ij}}{p}{j}}.
    \end{math}}
  \\
  \Verb/  ( (i|A|j), p, j)   # Tipo I  /
  \qquad es decir,\;
  \begin{math}
    \TrE{\pr{-a_{ip}}{j}}\;
    \TrE{\su{a_{ij}}{p}{j}}.
  \end{math}
\end{center}
El problema de esta solución es que si $a=3$ y $b=3$, bastaría con
restar $b-a$; pero la solución de arriba calcularía $-3(b)+3(a)$, por
lo que todos los números de las columnas [[r]] y [[j]] se
multiplicarían por tres sin que ello sea realmente necesario, así que
podemos terminar con matrices pre-escalonadas de números
innecesariamente grandes.

Considere $a=6$ y $b=4$, como
\begin{math} \frac{b}{a}=\frac{2}{3}, \end{math}  para eliminar $b$
basta con la operación $-3(b)+ 2(a)$; es decir, basta con simplificar
la fracción $\frac{b}{a}$ y multiplicar $b$ por el denominador
(cambiado de signo) y $a$ por el numerador de la fracción
simplificada. El siguiente código usa está idea (donde si [[n]] es un
número racional, entonces [[numer]] nos da el numerador de la fracción
simplificada y [[denom]] el denominador\dots y si no es racional,
[[numer]] nos da $\frac{b}{a}$ y [[denom]] es igual a $1$.\; Véase
[[<<Métodos auxiliares para usar coeficientes racionales cuando sea posible>>]]).
% El método de eliminación consiste en repetir, fila a fila el siguiente
% código (que tras definir las trasformaciones elementales [[Tr]], las
% apunta y las aplica sobre las columnas de la matriz):
\begin{codigo}[nobreak=true]
<<Uso del pivote para eliminar componentes evitando dividir>>=
Tr = T( [ T( [ ( denom((i|A|j),(i|A|p)),    j),    \
               (-numer((i|A|j),(i|A|p)), p, j)  ] ) \
                              for j in filter(celim, range(1,A.n+1)) ] )
@ 
\end{codigo}

Pero si la matriz tiene componentes irracionales, no hay más remedio
que aplicar la estrategia
\begin{displaymath}
  \HLa{b}-\left(\frac{b}{a}\right)\HLa{a}=0.
\end{displaymath}
donde $a$ y/o $b$ son números irracionales (\dots o polinomios\dots o variables simbólicas).

\subsection{La operación de intercambio de columnas}
La eliminación Gaussiana reordena las columnas para obtener una matriz
escalonada. Para ello necesitamos el \textbf{intercambio} de
columnas. Escalonar la matriz supone que el orden de las columnas
depende de la posición de pivote de cada una de ellas (dejando las
columnas nulas al final). Así, el pivote más alto (que es el primero
que hemos encontrado, pues recorremos las filas de arriba a abajo) se
sitúa en la primera columna, el segundo en la segunda columna,
etc. Llamamos [[p]] al índice de la columna donde encontramos el
pivote, y [[r]] a la posición que debería ocupar dicha columna en la
matriz escalonada (y que coincide con el número de pivotes encontrados
hasta ese momento). Así, cuando se encuentra el primer pivote
([[r==1]]) la correspondiente columna se coloca el primera posición,
cuando se encuentra el segundo ([[r==2]]) la correspondiente columna
se coloca el segunda posición, etc.
\begin{codigo}%[nobreak=true]
<<Intercambio de columnas para escalonar>>=
Tr = T([ {p, r} ])
@ 
\end{codigo}

\subsection{La operación de normalización de los pivotes}
La eliminación Gauss-Jordan también elimina las componentes a la
izquierda de los pivotes (de manera similar a lo descrito en la
Sección~\ref{sec:operacionesDeEliminacion}) y normaliza los pivotes
para que todos sean iguales a ``$1$''. Para ello divide cada columna
no nula por el valor de su pivote. De nuevo [[i]] es el índice de la
fila en que se está trabajando, y [[p]] el índice de la columna donde
se encuentra el pivote, por lo que [[i|A|p]] es el pivote:
\begin{codigo}[nobreak=true]
<<Normalización del pivote para que sea igual a uno>>=
Tr = T([ (fracc(1, i|A|p), p) ])
@    
\end{codigo}

\subsection{Se anotan las transformaciones de cada operación y se
  aplican a las columnas.}

Tras realizar cualquiera de las tres operaciones descritas más arriba,
se ha generado una sucesión de transformaciones [[Tr]], cuya lista
concatenamos a una lista de [[transformaciones]] que más adelante se
guardan como un atributo de la correspondiente clase (si no se hubiera
definido ninguna transformación, se concatena una lista vacía). Por
último, antes de pasar a la siguiente fila de la matriz, se aplica
[[Tr]] sobre las \emph{columnas} de la [[Matrix]].
\begin{codigo}[nobreak=true]
<<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>=
transformaciones += [Tr]  if Tr.t else []
A & T( Tr )
@ 
\end{codigo}

\newpage
\section{Eliminación ``de izquierda a derecha'', Gaussiana y Gauss-Jordan}
\subsection{Primero evitando las fracciones\dots en la medida de lo
  posible}

Como a los estudiantes no les suele agradar el uso de fracciones, la
librería da preferencia a este modo de operar.

El método de eliminación evitando divisiones corresponde a la clase
[[Elim]]. En él se define la función [[celim]] para que se anulen los
componentes a la derecha de cada pivote. Como no hay reordenamiento,
una vez encontrado un pivote, el índice [[p]] de su columna se
incorpora al conjunto [[colExcluida]], para no buscar nuevos
pivotes en dicha columna. La operación empleada corresponde al %
[[<<Uso del pivote para eliminar componentes evitando dividir>>]].%

El argumento [[data]] es una [[Matrix]], o algo que permita
generar una [[Matrix]], pues %se operará sobre la matriz: %[[Matrix]] %
\Verb/ A = Matrix(data)/. % 
Si el argumento [[rep]] es distinto de cero, Jupyter representará los
pasos de eliminación (por defecto [[rep=0]]). 

El algoritmo recorre las filas de la matriz [[A]] (índice [[i]]). Para
cada fila, busca un nuevo pivote que esté situado en alguna columna no
ocupada por otros pivotes; [[p]] es el índice de la columna donde se
ha encontrado un pivote (si no se encuentra ninguno, [[p]] vale
cero). Cuando [[p]] es distinto de cero (i.e, cuando se ha encontrado
un pivote en la fila [[i]]):
\begin{itemize}
\item el contador de pivotes [[r]] suma uno más.
\item Se aplica la eliminación de los componentes indicados con [[celim]]
\item Se añade el índice [[p]] al conjunto [[colExcluida]]
\end{itemize}
Una vez se han recorrido todas las filas, se guarda la lista de
[[transformaciones]] aplicadas a las columnas como segundo componente
de la lista [[pasos]] (el segundo componente corresponderá a las
trasformaciones de las columnas). Para finalizar, %
[[<<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>]],%
\footnote{ por comodidad incluyo dos atributos más: [[TrF]] es la %
[[T]]transformación aplicada a las filas y [[TrC]] la aplicada a las
columnas.}  se guarda el atributo [[rango]] y se devuelve la matriz
transformada.
\begin{codigo}[nobreak=true]
<<Tres métodos de eliminación por columnas>>=
class Elim(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma pre-escalonada de Matrix(data)

           operando con las columnas (y evitando operar con fracciones). 
           Si rep es no nulo, se muestran en Jupyter los pasos dados"""
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        celim = lambda x: x > p
        A = Matrix(data);  r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Uso del pivote para eliminar componentes evitando dividir>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(p)
        pasos = [[], transformaciones]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix
        
@ %def Elim
\end{codigo}        
@

La clase [[ElimG]] corresponde a la eliminación Gaussiana y su código
es parecido al anterior. Las diferencias son:
\begin{itemize}
\item La matriz [[A]] está pre-escalonada: \Verb/ A = Elim(data) /.
\item No es necesario definir la función [[celim]], pues ahora no se
  anulan componentes (solo se intercambian columnas)
\item La operación empleada es el %
[[<<Intercambio de columnas para escalonar>>]]% 
\item Puesto que el primer pivote ocupa la primera columna, el segundo
  la segunda, etc.; ahora es el número de pivotes [[r]] encontrados
  el que se incluye en el conjunto [[colExcluida]]
\item Los pasos totales dados son la concatenación de los dados sobre
  las columnas al pre-escalonar ([[A.pasos[1]]]) y los intercambios de
  las columnas ([[T(transformaciones)]])
\end{itemize}
Todo lo demás es idéntico.
\begin{codigo}[nobreak=true]
<<Tres métodos de eliminación por columnas>>=
class ElimG(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma escalonada de Matrix(data)

           operando con las columnas (y evitando operar con fracciones). 
           Si rep es no nulo, se muestran en Jupyter los pasos dados"""
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        A = Elim(data);  r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Intercambio de columnas para escalonar>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(r)
        pasos = [ [], A.pasos[1]+[T(transformaciones)] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix

@ %def ElimG
\end{codigo}

La clase [[ElimGJ]] corresponde a la eliminación Gauss-Jordan y su
código es algo más complicado (no mucho). Las diferencias con los
anteriores son:
\begin{itemize}
\item La matriz [[A]] está escalonada:
\Verb/ A = ElimG(data)/
\item La función [[celim]], indica que se deben eliminar las
  componentes a la izquierda de cada pivote.
\item Se emplean dos operaciones.
  \begin{enumerate}
  \item Primero se recorren todas las filas de la matriz haciendo %
    [[<<Uso del pivote para eliminar componentes evitando dividir>>]] \\
    (después se guarda la lista de transformaciones en la variable [[transElimIzda]])
  \item A continuación se ``resetean'' las variables [[r]],
    [[transformaciones]] y [[columnOcupada]] y, por segunda vez, se
    recorren todas las filas para la aplicar la %
    [[<<Normalización del pivote para que sea igual a uno>>]]\\
    (¡con esta operación inevitablemente aparecen las fracciones!\dots
    aunque se han demorado hasta el último momento.)
  \end{enumerate}
\item Los pasos totales dados son la concatenación de los dados sobre
  las columnas al escalonar ([[A.pasos[1]]]), las eliminaciones de los
  componentes a la izquierda de los pivotes ([[transElimIzda]]) y las
  transformaciones para normalizar los pivotes
  ([[T(transformaciones)]]).
\end{itemize}
Todo lo demás es idéntico.
\begin{codigo} %[nobreak=true]
<<Tres métodos de eliminación por columnas>>=
class ElimGJ(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma escalonada reducida de Matrix(data)

           operando con las columnas (y evitando operar con fracciones  
           hasta el último momento). Si rep es no nulo, se muestran en 
           Jupyter los pasos dados"""
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        celim = lambda x: x < p
        A = ElimG(data);
        r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Uso del pivote para eliminar componentes evitando dividir>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(p)
                
        transElimIzda = transformaciones

        r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Normalización del pivote para que sea igual a uno>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(p)
                
        pasos = [ [], A.pasos[1] + transElimIzda  + [T(transformaciones)] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix

@ %def ElimGJ
\end{codigo}

\subsection{Si no evitamos las fracciones realizamos menos operaciones}
Las clases [[Elimr]], [[ElimrG]] y [[ElimrGJ]] hacen lo mismo, pero haciendo %
[[<<Uso del pivote para eliminar componentes con trasformaciones Tipo I>>]]

Muestro su código sin más explicaciones\dots
\begin{codigo}%[nobreak=true]
<<Tres métodos de eliminación por columnas>>=
class Elimr(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma pre-escalonada de Matrix(data)

           operando con las columnas. Si rep es no nulo, se muestran en 
           Jupyter los pasos dados"""
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        celim = lambda x: x > p
        A = Matrix(data);  r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Uso del pivote para eliminar componentes con trasformaciones Tipo I>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(p)
        pasos = [[], transformaciones]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix
        
@ %def Elimr
\end{codigo}        

\begin{codigo}%[nobreak=true]
<<Tres métodos de eliminación por columnas>>=
class ElimrG(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma escalonada de Matrix(data)

           operando con las columnas. Si rep es no nulo, se muestran en 
           Jupyter los pasos dados"""
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        A = Elimr(data);  r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Intercambio de columnas para escalonar>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(r)
        pasos = [ [], A.pasos[1]+[T(transformaciones)] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix

@ %def ElimrG
\end{codigo}

\begin{codigo}%[nobreak=true]
<<Tres métodos de eliminación por columnas>>=
class ElimrGJ(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma escalonada reducida de Matrix(data)

           operando con las columnas. Si rep es no nulo, se muestran en
           Jupyter los pasos dados"""
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        celim = lambda x: x < p
        A = ElimrG(data);
        r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Uso del pivote para eliminar componentes con trasformaciones Tipo I>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(p)                
        transElimIzda = transformaciones
        r = 0;  transformaciones = [];  colExcluida = set()
        for i in range(1,A.m+1):
            p = BuscaNuevoPivote(i|A); 
            if p:
                r += 1
                <<Normalización del pivote para que sea igual a uno>>
                <<Apuntamos las transformaciones [[Tr]] y las aplicamos sobre las \emph{columnas}>>
                colExcluida.add(p)                
        pasos = [ [], A.pasos[1] + transElimIzda  + [T(transformaciones)] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix

@ %def ElimrGJ
\end{codigo}

\subsection[Eliminación por filas]{Variante de los métodos de
  eliminación evitando usar fracciones y operando con las filas (como
  en la mayoría de manuales de Álgebra Lineal)}
Para esto no es
necesario programar nuevos algoritmos, basta operar con las columnas
de la matriz transpuesta y transponer el resultado. La única
dificultad está en la representación de los pasos, pues queremos ver
operaciones sobre las filas de la matriz, y no sobre las columnas de
su transpuesta. Para ello escribimos la secuencia de transformaciones
en el orden inverso (lo que requiere trasponer algunas sub-secuencias
de transformaciones elementales, [[~t]]); y las guardamos como
elemento de la lista [[pasos]] (pues el primer elemento corresponde a
las transformaciones de las filas).  El siguientes recuadros muestran
los tres métodos: Eliminación, Eliminación Gaussina y Eliminación
Gauss-Jordan.

\begin{codigo}[nobreak=true]
<<Tres métodos de eliminación por filas>>=
class ElimF(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma pre-escalonada de Matrix(data)

           operando con las filas (y evitando operar con fracciones). 
           Si rep es no nulo, se muestran en Jupyter los pasos dados"""
        A = Elim(~Matrix(data));     r = A.rango
        pasos = [ list(reversed([ ~t for t in A.pasos[1] ])), [] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(~A)
        self.__class__ = Matrix
        
@ %def ElimF
\end{codigo}

\begin{codigo}[nobreak=true]
<<Tres métodos de eliminación por filas>>=
class ElimGF(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma escalonada de Matrix(data)

           operando con las filas (y evitando operar con fracciones). 
           Si rep es no nulo, se muestran en Jupyter los pasos dados"""
        A = ElimG(~Matrix(data));    r = A.rango
        pasos = [ list(reversed([ ~t for t in A.pasos[1] ])), [] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(~A)
        self.__class__ = Matrix
        
@ %def ElimGF
\end{codigo}

\begin{codigo}[nobreak=true]
<<Tres métodos de eliminación por filas>>=
class ElimGJF(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve una forma escalonada reducida de Matrix(data)

           operando con las columnas (y evitando operar con fracciones  
           hasta el último momento). Si rep es no nulo, se muestran en 
           Jupyter los pasos dados"""
        A = ElimGJ(~Matrix(data));   r = A.rango
        pasos = [ list(reversed([ ~t for t in A.pasos[1] ])), [] ]
        pasos = [ filtradopasos(pasos[i]) for i in (0,1) ]
        <<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>
        self.rango = r
        super(self.__class__ ,self).__init__(~A)
        self.__class__ = Matrix
        
@ %def ElimGJF
\end{codigo}        

En el proceso de eliminación, muchas trasformaciones elementales
realmente son identidades (sumar 0 veces otro vector y multiplicar un
vector por 1).

A la hora de representar los pasos de eliminación, normalmente es
mejor ``filtar'' estos pasos innecesarios. Definimos un procedimiento
general que quita de una lista de abreviaturas aquellas que son
innecesarias en la representación. Si como argumento se le da una
lista de abreviaturas, devuelve una lista filtrada. Si como argumento
se le da una [[T]]ransformación, devuelve una [[T]]ransformación cuya
lista de abreviaturas está filtrada.
\begin{codigo}[nobreak=true]
<<Filtrado de secuencias de transformaciones>>=
def filtradopasos(pasos):
    abv = pasos.t if isinstance(pasos,T) else pasos
           
    p = [T([j for j in T([abv[i]]).t if (isinstance(j,set) and len(j)>1)\
               or (isinstance(j,tuple) and len(j)==3 and j[0]!=0)       \
               or (isinstance(j,tuple) and len(j)==2 and j[0]!=1) ])    \
                                             for i in range(0,len(abv)) ]

    abv = [ t for t in p if t.t] # quitamos abreviaturas vacías de la lista
    
    return T(abv) if isinstance(pasos,T) else abv

@ %def filtradopasos
\end{codigo}

\pagebreak

\section{Inversión de una matriz por eliminación Gaussiana}
Para invertir una matriz basta aplicar la eliminación
\emph{Gauss-Jordan} sobre las columnas de una matriz cuadrada
([[ElimrGJ]]). Si la matriz resulta ser de rango completo (Si
     [[R.rango == R.n]]), entonces los pasos dados en la eliminación
     \emph{Gauss-Jordan} aplicados sobre la matriz identidad del mismo
     orden nos dan la inversa.
\medskip

El siguiente código obtiene la inversa de una matriz siguiendo el
procedimiento anterior (pero demorando las operaciones con fracciones
hasta el último momento, [[ElimGJ]]), y muestra los pasos dados hasta
llegar a ella, o hasta llegar a una matriz singular
\begin{codigo}[nobreak=true]
<<Invirtiendo una matriz>>=
class InvMat(Matrix):
    def __init__(self, data, rep=0):
        """Devuelve la matriz inversa y los pasos dados sobre las columnas"""
        A          = Matrix(data)        
        if not A.es_cuadrada():  raise ValueError('Matrix no cuadrada')
        R          = ElimGJ(A)
        self.pasos = R.pasos 
        self.TrF   = R.TrF 
        self.TrC   = R.TrC 
        self.tex   = rprElim( BlockM([ [A], [I(A.n)] ]) , self.pasos)
        if R.rango < A.n:        raise ArithmeticError('Matrix singular')        
        Inversa    = I(A.n) & T(R.pasos[1])  
        super(self.__class__ ,self).__init__(Inversa)
        self.__class__ = Matrix
        if rep:
            display(Math(self.tex))

@
\end{codigo}


El siguiente código obtiene la inversa de una matriz pero operando con las filas.

\begin{codigo}[nobreak=true]
<<Invirtiendo una matriz>>=
class InvMatF(Matrix):
    def __init__(self, data, rep=0):
    	"""Devuelve la matriz inversa y los pasos dados sobre las filas"""
     	A          = Matrix(data)
        if A.m != A.n:
            raise ValueError('Matrix no cuadrada')
     	M          = ElimGJF(A)
     	self.pasos = M.pasos 
        self.TrF   = M.TrF 
        self.TrC   = M.TrC 
        self.tex   = rprElim( BlockM([ [A,I(A.m)] ]) , self.pasos)
        if M.rango < A.n:
            raise ArithmeticError('Matrix singular')        
        Inversa    = T(M.pasos[0]) & I(A.n)   
     	super(self.__class__ ,self).__init__(Inversa)
        self.__class__ = Matrix
        if rep:
            display(Math(self.tex))

@
\end{codigo}

El siguiente código obtiene la inversa de una matriz operando primero
sobre las filas hasta obtener una matriz escalonada y luego operando
sobre las columnas hasta obtener la identidad.
\begin{codigo}[nobreak=true]
<<Invirtiendo una matriz>>=
class InvMatFC(Matrix):
    def __init__(self, data, rep=0):
    	"""Devuelve la matriz inversa y los pasos dados sobre las filas y columnas"""
     	A          = Matrix(data)
        if A.m != A.n:
            raise ValueError('Matrix no cuadrada')
     	M          = ElimGJ(ElimGF(A))
     	self.pasos = M.pasos  
        self.TrF   = M.TrF 
        self.TrC   = M.TrC 
        self.tex   = rprElim(BlockM([[A,I(A.m)],[I(A.n),M0(A.m,A.n)]]),self.pasos)
        if M.rango < A.n:
            raise ArithmeticError('Matrix singular')        
        Inversa    = ( I(A.n) & T(M.pasos[1]) ) * ( T(M.pasos[0]) & I(A.n) )
    	super(self.__class__ ,self).__init__(Inversa)
        self.__class__ = Matrix
        if rep:
            display(Math(self.tex))

@
\end{codigo}

\pagebreak
\section{Resolución de un sistema de ecuaciones homogéneo}

El siguiente código devuelve el conjunto de soluciones de un sistema homogéneo \SEL{A}{x}{0}. Descripción de los atributos:
\begin{itemize}
\item [[sgen]] es un sistema generador del espacio nulo \nulls{A}. 
\item [[determinado]] indica si es cierto que el sistema es determinado (una única solución)
\item [[tex]] es la cadena de texto \LaTeX\ que permite representar los pasos dados para resolver el sistema.
\end{itemize}
\begin{codigo}[nobreak=true]
<<Resolviendo un sistema homogéneo>>=
class Homogenea:
    def __init__(self, data, rep=0):
    	"""Resuelve un Sistema de Ecuaciones Lineales Homogéneo
    
        y muestra los pasos para encontrarlo"""
        
     	A     = Matrix(data)
        <<Cálculo de [[L]] y de una [[base]] del espacio nulo de [[A]]>>
        
        self.sgen        = Sistema(base) if base else Sistema([ V0(A.n) ])
        self.determinado = (len(base) == 0)
        self.pasos       = L.pasos; 
        self.TrF         = L.TrF 
        self.TrC         = L.TrC 
        self.tex         = rprElim( BlockM([[A],[I(A.n)]]), self.pasos)
        self.enulo       = SubEspacio(self.sgen)
        
        if rep:
            display(Math(self.tex))
           
    <<Métodos de representación de la clase [[Homogenea]]>>   
           
@ %def Homogenea
\end{codigo}

La base la constituyen los vectores [[v]] de [[E]] que corresponden a
los vectores nulos de [[L]]:
\begin{codigo}[nobreak=true]
<<Cálculo de [[L]] y de una [[base]] del espacio nulo de [[A]]>>=
L     = Elim( A )  
E     = I(A.n) & T(L.pasos[1])
base  = [ v for j, v in enumerate(E, 1) if (L|j).es_nulo() ]
@ 
\end{codigo}

\pagebreak
\section{Resolución de un sistema de ecuaciones}
\begin{codigo}
<<Texto de ayuda de la clase [[SEL]]>>=
"""Resuelve un Sistema de Ecuaciones Lineales

mediante eliminación por columnas en la matriz ampliada y muestra
los pasos dados"""
@
\end{codigo}

\begin{codigo}[nobreak=true]
<<Resolviendo un Sistema de Ecuaciones Lineales>>=
class SEL:
    def __init__(self, A, b, rep=0):
        <<Texto de ayuda de la clase [[SEL]]>>
        A  = Matrix(A)
        MA = A.concatena(Matrix([-b])).apila(I(A.n+1))
        BM = {A.m,(A.m+A.n)} | MA | {A.n,A.n}
        
        L  = Elim( Matrix( 1|BM ) )
        
        <<Si no se anula la última columna: [[raise error]]>>
        <<Aplicamos los [[pasos]] de eliminación sobre la matriz ampliada y obtenemos la solución>>
    <<Métodos de representación de la clase [[SEL]]>>
              
@ %def SEL
\end{codigo}

Aplicamos los pasos sobre toda la matriz ampliada (más bien ``super
ampliada'', pues tiene una matriz identidad por debajo). Si el último elemento de la última columna es 

\begin{codigo}
<<Aplicamos los [[pasos]] de eliminación sobre la matriz ampliada y obtenemos la solución>>=
EA        = Matrix(MA) & T(L.pasos[1]) 
Normaliza = T([]) if (0|EA|0)==1 else T([( fracc(1,0|EA|0), EA.n )])
EA & Normaliza

BEA       = {A.m, (A.m+A.n)} | EA | {A.n}
          
K = Matrix(1|BEA|1);   E = Matrix(2|BEA|1);   S = Matrix(2|BEA|2)

self.solP  = S|0
base       = [ v for j, v in enumerate(E,1) if (K|j).es_nulo() ]
self.sgen  = Sistema(base) if base else Sistema([ V0(A.n) ])
self.eafin = EAfin(self.sgen, self.solP)

self.determinado = (len(base) == 0)
self.pasos       = [[], L.pasos[1]+[Normaliza] ] if Normaliza.t else [[], L.pasos[1]]
self.TrF         = T(self.pasos[0]) 
self.TrC         = T(self.pasos[1]) 
self.tex         = rprElim( BM, self.pasos )
if rep:
    display(Math(self.tex))           
@ 
\end{codigo}

\begin{codigo}
<<Si no se anula la última columna: [[raise error]]>>=
if (L|0).no_es_nulo():
    self.tex = tex( BM, L.pasos )
    raise ArithmeticError('No hay solución: Sistema incompatible')
@
\end{codigo}

\pagebreak
\section{Cálculo del determinante por eliminación Gaussiana}
\begin{codigo}
<<Texto de ayuda de la clase [[Determinante]]>>=
"""Calcula el determinante

mediante eliminación Gaussiana por columnas y muestra los pasos dados"""
@
\end{codigo}

\begin{codigo}[nobreak=true]
<<Calculando el determinante>>=
class Determinante:
    def __init__(self, data, rep=0):
        <<Texto de ayuda de la clase [[Determinante]]>>
        
        A  = Matrix(data)
        if not A.es_cuadrada():  raise ValueError('Matrix no cuadrada')
           
        <<Cálculo del determinante y representación de los pasos en Jupyter>>
        
        self.tex, self.valor, self.pasos = \
                                   calculoDet( A.BlockDiag([I(1)]) , ElimG(A).pasos )
        
        self.TrF   = T(self.pasos[0])
        self.TrC   = T(self.pasos[1])

    <<Métodos de representación de la clase [[Determinante]]>>

@ %def Determinante
\end{codigo}

\begin{codigo}
<<Cálculo del determinante y representación de los pasos en Jupyter>>=
def calculoDet(data, pasos, TexPasosPrev=[]):
    <<Definición del método [[PasosYEscritura]] que también calcula el valor del [[Determinante]]>>
    tex, valor, pasos = PasosYEscritura(data, pasos)
    if 'rep' in locals() and rep:
        display(Math(tex))
          
    return [tex, valor, pasos]
@ %def calculoDet
\end{codigo}


\begin{codigo}[nobreak=true] 
<<Métodos de representación de la clase [[Determinante]]>>=  
def __repr__(self):
    """ Muestra un Sistema en su representación Python """
    return 'Valor del determinante:  ' + repr (self.valor) 

def _repr_html_(self):
    """ Construye la representación para el entorno Jupyter Notebook """
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para representar un Sistema """
    return latex(self.valor)

@
\end{codigo}

        
\pagebreak
\section{Diagonalizando en bloques triangulares una matriz cuadrada por semejanza (Dentado)}
\begin{codigo}[nobreak=true]
<<Diagonalizando una matriz por bloques triangulares (semejanza)>>=
class Diagonaliza(Matrix):
    def __init__(self, A, espectro, Rep=0):
        <<Texto de ayuda para la clase [[Diagonaliza]]>>
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        D            = Matrix(A)
        if not D.es_cuadrada: raise ValueError('Matrix no es cuadrada')
        if not isinstance(espectro, list):
            raise ValueError('espectro no es una lista')
        if len(espectro)!=D.n:
            raise ValueError('número inadecuado de autovalores en la lista espectro')
        S            = I(D.n)
        Tex          = latex( BlockM( [[D], [S]] ) )
        pasosPrevios = [[],[]]
        selecc       = list(range(1,D.n+1))
        for lamda in espectro:
            m = selecc[-1]
            <<Restamos $\lambda\Mat{I}$>>
            TrCol = filtradopasos(ElimG(selecc|D|selecc).pasos[1])
            <<Aplicación de las transformaciones y sus inversas "{\em espejo}">>
            if m < D.n:
                transf = []; colExcluida = set(selecc)
                for i in range(m,D.n+1):
                    p = BuscaNuevoPivote(i|D);
                    if p:
                        TrCol = filtradopasos([ T([(-fracc(i|D|m, i|D|p), p, m)]) ])
                        <<Aplicación de las transformaciones y sus inversas "{\em espejo}">>
                        colExcluida.add(p)                        
            <<Sumamos $\lambda\Mat{I}$>>
            
            selecc.pop()
            
        if Rep:
            display(Math(Tex))
            
        espectro.sort(reverse=True)                
        self.espectro = espectro
        self.tex = Tex
        self.S   = S
        self.TrF = T(pasosPrevios[0])
        self.TrC = T(pasosPrevios[1])
        self.pasos = pasosPrevios
        super(self.__class__ ,self).__init__(D)
        self.__class__ = Matrix
                   
@ %def Diagonaliza
\end{codigo}

\begin{codigo}
<<Texto de ayuda para la clase [[Diagonaliza]]>>=
"""Diagonaliza por bloques triangulares una Matrix cuadrada 

Encuentra una matriz diagonal semejante mediante trasformaciones de sus
columnas y las correspondientes transformaciones inversas espejo de las
filas. Requiere una lista de autovalores (espectro), que deben aparecer
en dicha lista tantas veces como sus respectivas multiplicidades 
algebraicas. Los autovalores aparecen en la diagonal principal de la 
matriz diagonal. El atributo S de dicha matriz diagonal es una matriz 
cuyas columnas son autovectores de los correspondientes autovalores.
"""
@  
\end{codigo}

\begin{codigo}[nobreak=true]
<<Aplicación de las transformaciones y sus inversas "{\em espejo}">>=  
pasos           = [ [], TrCol ]
pasosPrevios[1] = pasosPrevios[1] + pasos[1]

Tex = rprElim( BlockM( [[D], [S]] ), pasos, Tex) if TrCol else Tex
D = D & T(pasos[1])
S = S & T(pasos[1])

pasos           = [ [T(pasos[1]).espejo()**-1] , []]
pasosPrevios[0] = pasos[0] + pasosPrevios[0]

Tex = rprElim( BlockM( [[D], [S]] ), pasos, Tex) if TrCol else Tex
D   = T(pasos[0]) & D
@ 
\end{codigo}

\begin{codigo}
<<Restamos $\lambda\Mat{I}$>>=
D = D-(lamda*I(D.n))
Tex += '\\xrightarrow[' + latex(lamda) + '\\mathbf{I}]{(-)}' \
                        + latex(BlockM( [[D], [S]] ))
@ 

<<Sumamos $\lambda\Mat{I}$>>=
D = D+(lamda*I(D.n))
Tex += '\\xrightarrow[' + latex(lamda) + '\\mathbf{I}]{(+)}' \
                        + latex(BlockM( [[D], [S]] ))
@ 
\end{codigo}

\subsection{Diagonalización ortogonal de una matriz simétrica}
\begin{codigo}[nobreak=true]
<<Diagonalizando ortogonalmente una matriz simétrica>>=
class DiagonalizaO(Matrix):
    def __init__(self, A, espectro, Rep=0):
        <<Texto de ayuda para la clase [[DiagonalizaO]]>>
        def ext(self):
            M = Matrix(BlockM([ [self, I(self.m)] ])).GS()
            l = [ j for j, v in enumerate(M, 1) if v.no_es_nulo() ]
            l = l[1:len(l)]+[l[0]]
            return (M|l).normalizada()

        D =Matrix(A)
        if not D.es_simetrica: raise ValueError('La matriz no es simétrica')
        S        = I(A.n)
        espectro = list(espectro);
        selecc   = list(range(1,D.n+1))
        for l in espectro:
            D = D - l*I(D.n)
            TrCol = ElimG(selecc|D|selecc).pasos[1]
            D = D + l*I(D.n)
            k       = len(selecc)
            nmenosk = (D.n)-k
            selecc.pop()

            q = ( I(k) & T(TrCol) )|0
            q = (sympy.sqrt(q*q)) * q
            Q = Matrix(BlockM([ \
                 [ext(Matrix([q])), M0(k, nmenosk)], \
                 [  M0(nmenosk, k),     I(nmenosk)]  ] )) if nmenosk \
                 else ext(Matrix([q]))
            S = S *Q     
            D = ~Q*D*Q
            
        self.Q = S
        espectro.sort(reverse=True)                
        self.espectro = espectro
        super(self.__class__ ,self).__init__(D)
        self.__class__ = Matrix
                   
@ %def DiagonalizaO
\end{codigo}

\begin{codigo}
<<Texto de ayuda para la clase [[DiagonalizaO]]>>=
""" Diagonaliza ortogonalmente una Matrix simétrica 

Encuentra una matriz diagonal semejante multiplicando por una matriz
ortogonal Q a la derecha y por la inversa (transpuesta) de Q por la
izquierda. Requiere una lista de autovalores (espectro), que deben
aparecer en dicha lista tantas veces como sus respectivas multiplicidades 
algebraicas. Los autovalores aparecen en la diagonal principal de la
matriz diagonal. El atributo Q de la matriz diagonal es la matriz
ortogonal cuyas columnas son autovectores de los correspondientes
autovalores. """
@  
\end{codigo}


\section{Diagonalización por congruencia}

\begin{codigo}
<<Texto de ayuda para la clase [[DiagonalizaC]]>>=
""" Diagonaliza por congruencia una Matrix simétrica (evitando dividir)

Encuentra una matriz diagonal congruente multiplicando por una matriz
invertible B a la derecha (y de números enteros si es posible) y por la 
transpuesta de B por la izquierda. No requiere conocer los autovalores. 
En general los elementos en la diagonal principal de la matriz diagonal 
no son autovalores, pero hay tantos elementos positivos en la diagonal 
como autovalores positivos (incluyendo la multiplicidad de cada uno), 
tantos negativos como autovalores negativos (incluyendo la multiplicidad
de cada uno), y tantos ceros como la multiplicidad algebraica del 
autovalor cero. """
@  
\end{codigo}


\begin{codigo}[nobreak=true]
<<Diagonalizando una matriz por congruencia>>=
class DiagonalizaC(Matrix):
    def __init__(self, data, Rep=0):
        <<Texto de ayuda para la clase [[DiagonalizaC]]>>
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        A     = Matrix(data);      colExcluida  = set()
        celim = lambda x: x > p;   pasosPrevios = [ [], [] ]
        Tex   = latex(A);   
        for i in range(1,A.n):
            p = BuscaNuevoPivote(i|A)
            #j = [k for k in list(range(i,A.n+1)) if ( i|A|k and not k|A|k )]
            j = [k for k,col in enumerate(A|slice(i,None), i) if (i|col and not k|col)]
            if not (i|A|i):
                if j:
                    Tr = T( (1, j[0], i) )
                    p = i
                    <<Aplicación de las transformaciones a las columnas y a las filas>>
                elif p:
                    Tr = T( {i, p} )
                    p = i
                    <<Aplicación de las transformaciones a las columnas y a las filas>>
            if p:
                <<Uso del pivote para eliminar componentes evitando dividir>>
                <<Aplicación de las transformaciones a las columnas y a las filas>>
            colExcluida.add(i)
            
        self.tex       = Tex
        self.pasos     = pasosPrevios
        self.TrF       = filtradopasos(T(self.pasos[0]))
        self.TrC       = filtradopasos(T(self.pasos[1]))
        self.B         = I(A.n) & T(pasosPrevios[1])
        
        if Rep:
            display(Math(Tex))
            
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix
                   
@ 
\end{codigo}

%        #self.positivos = sum([1 for c in A.diag() if c>0 ] )
%        #self.negativos = sum([1 for c in A.diag() if c<0 ] )
%        #self.nulos     = sum([1 for c in A.diag() if c==0] )
%
%            #print('Num de autovalores positivos: ' + str(self.positivos) + '\n')
%            #print('Num de autovalores nulos:     ' + str(self.nulos)     + '\n')
%            #print('Num de autovalores negativos: ' + str(self.negativos) + '\n')

\begin{codigo}[nobreak=true]
<<Aplicación de las transformaciones a las columnas y a las filas>>=
pasos = [ [], filtradopasos([Tr]) ]
pasosPrevios[1] = pasosPrevios[1] + pasos[1]
Tex = rprElim( A, pasos, Tex)
A = A & T(pasos[1])

pasos = [ filtradopasos([~Tr]) , []]
pasosPrevios[0] = pasos[0] + pasosPrevios[0]
Tex = rprElim( A, pasos, Tex)
A = T(pasos[0]) & A
@ 
\end{codigo}


\begin{codigo}
<<Texto de ayuda para la clase [[DiagonalizaCr]]>>=
""" Diagonaliza por congruencia una Matrix simétrica

Encuentra una matriz diagonal congruente multiplicando por una matriz
invertible B a la derecha y por la transpuesta de B por la izquierda. 
No requiere conocer los autovalores. En general los elementos en la
diagonal principal de la matriz diagonal no son autovalores, pero hay
tantos elementos positivos en la diagonal como autovalores positivos
(incluyendo la multiplicidad de cada uno), tantos negativos como
autovalores negativos (incluyendo la multiplicidad de cada uno), y tantos
ceros como la multiplicidad algebraica del autovalor cero. """
@  
\end{codigo}

\begin{codigo}[nobreak=true]
<<Diagonalizando una matriz por congruencia>>=
class DiagonalizaCr(Matrix):
    def __init__(self, data, Rep=0):
        <<Texto de ayuda para la clase [[DiagonalizaCr]]>>
        <<Definición del método auxiliar [[BuscaNuevoPivote]]>>
        A     = Matrix(data);      colExcluida  = set()
        celim = lambda x: x > p;   pasosPrevios = [ [], [] ]
        Tex   = latex(A);   
        for i in range(1,A.n):
            p = BuscaNuevoPivote(i|A)
            #j = [k for k in list(range(i,A.n+1)) if ( i|A|k and not k|A|k )]
            j = [k for k,col in enumerate(A|slice(i,None), i) if (i|col and not k|col)]
            if not (i|A|i):
                if j:
                    Tr = T( (1, j[0], i) )
                    p = i
                    <<Aplicación de las transformaciones a las columnas y a las filas>>
                elif p:
                    Tr = T( {i, p} )
                    p = i
                    <<Aplicación de las transformaciones a las columnas y a las filas>>
            if p:
                <<Uso del pivote para eliminar componentes con trasformaciones Tipo I>>
                <<Aplicación de las transformaciones a las columnas y a las filas>>
            colExcluida.add(i)
            
        self.tex       = Tex
        self.pasos     = pasosPrevios
        self.TrF       = T(self.pasos[0])
        self.TrC       = T(self.pasos[1])
        self.B         = I(A.n) & T(pasosPrevios[1])
        
        if Rep:
            display(Math(Tex))
            
        super(self.__class__ ,self).__init__(A)
        self.__class__ = Matrix
        
@ 
\end{codigo}

%        #self.positivos = sum([1 for c in A.diag() if c>0 ] )
%        #self.negativos = sum([1 for c in A.diag() if c<0 ] )
%        #self.nulos     = sum([1 for c in A.diag() if c==0] )
%
%            #print('Num de autovalores positivos: ' + str(self.positivos) + '\n')
%            #print('Num de autovalores nulos:     ' + str(self.nulos)     + '\n')
%            #print('Num de autovalores negativos: ' + str(self.negativos) + '\n')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Las clases \texttt{SubEspacio} y  \texttt{EAfin}}
\label{part:CodigoPrincipalSubespacios}

El conjunto de vectores \Vect{x} que resuelven el sistema
\SEL{A}{x}{0} es un subespacio de \R[n]; y el conjunto de vectores
\Vect{x} que resuelven el sistema \SEL{A}{x}{b} con
$\Vect{b}\ne\Vect{0}$ es un espacio afín de \R[n]. En este capítulo
vamos a definir objetos que representen estos subconjuntos de \R[n].

\section{La clase \texttt{SubEspacio} (de \R[m])}
La clase \texttt{[[SubEspacio]]} se puede instanciar tanto con un
[[Sistema]] de [[Vector]]es como con una [[Matrix]].
\medskip

En el primer caso, dado un [[Sistema]] de vectores, por ejemplo
\begin{displaymath}
  S=
  \left[
    \begin{pmatrix}0\\1\\0\end{pmatrix};\;
    \begin{pmatrix}2\\1\\3\end{pmatrix};\;
    \begin{pmatrix}2\\10\\3\end{pmatrix}
  \right],
\end{displaymath}
[[SubEspacio( S )]] corresponde al conjunto de combinaciones lineales
de los [[Vector]]es de dicho [[Sistema]], representado por las
siguientes ecuaciones \emph{paramétricas}:
\begin{displaymath}
  \left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^2,\; \boldsymbol{v}= \begin{bmatrix}0&2\\1&0\\0&3\end{bmatrix}\boldsymbol{p}\right. \right\}\; 
\end{displaymath}
donde el vector \Vect{p} es el vector de parámetros.
En el segundo caso, dada una [[Matrix]], por ejemplo
\begin{displaymath}
  \;\Mat{M}=\begin{bmatrix}-3&0&2\\6&0&-4\end{bmatrix},\;
\end{displaymath}
[[SubEspacio( M )]] corresponde al conjunto de [[Vector]]es que son
solución al sistema de ecuaciones
\begin{math}
  \;\MV{M}{v}=\Vect{0};\;
\end{math}
y que se puede representar con el sistema de ecuaciones \emph{cartesianas}:
\begin{displaymath}
  \left\{
    \boldsymbol{v}\in\mathbb{R}^3\
    \left|
      \ \begin{bmatrix}-3&0&2\end{bmatrix}\boldsymbol{v}=\boldsymbol{0}
    \right\}
  \right.
\end{displaymath}
En ambos ejemplos corresponden al mismo subespacio de \R[3]; y, de
hecho, la librería muestra ambos tipos de representación para cada
[[SubEspacio]]: las ecuaciones paramétricas a la izquierda y las
cartesianas a la derecha.
\begin{displaymath}
  \left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \exists\boldsymbol{p}\in\mathbb{R}^2,\; \boldsymbol{v}= \begin{bmatrix}0&2\\1&0\\0&3\end{bmatrix}\boldsymbol{p}\right. \right\}\; = \;\left\{ \boldsymbol{v}\in\mathbb{R}^3\ \left|\ \begin{bmatrix}-3&0&2\end{bmatrix}\boldsymbol{v}=\boldsymbol{0}\right.\right\}
\end{displaymath}
[[SubEspacio]] tiene
varios atributos.
\begin{itemize}
\item [[dim]]: dimensión del subespacio. En el ejemplo [[dim=2]].
\item [[Rm]]: indica el espacio vectorial \R[m] al que pertenece
  [[SubEspacio(S)]]. En el ejemplo anterior [[Rm=3]] puesto que es un
  subespacio de \R[3].
\item [[base]]: una base del subespacio (un [[Sistema]] de
  [[Vector]]es de [[Rm]]). Cuando [[dim==0]] base es un [[Sistema]]
  vacío.
\item [[sgen]]: Un [[Sistema]] de [[Vector]]es generador del
  subespacio. En particular será el sistema de vectores
  correspondiente a la [[Matrix]] de coeficientes empleada en la
  representación con ecuaciones paramétricas. En el ejemplo
  Cuando [[dim==0]], [[sgen]] contiene un vector nulo de [[Rm]] componentes.
  \begin{displaymath}
    \left[\begin{pmatrix}0\\1\\0\end{pmatrix};\;\begin{pmatrix}2\\0\\3\end{pmatrix};\right]
  \end{displaymath}
\item [[cart]]: [[Matrix]] de coeficientes empleada en la
  representación con las ecuaciones cartesianas. En el ejemplo
  \begin{displaymath}
    \begin{bmatrix}
      -3 & 0 & 2
    \end{bmatrix}.
  \end{displaymath}
\end{itemize}

\paragraph{La implementación} requiere encontrar un
[[Sistema]] base del [[SubEspacio]] columna de una [[Matrix]]
[[A]]. Lo haremos pre-escalonando una [[A]] con [[Elim]] (así evitamos
las fracciones en la medida de lo posible). También necesitaremos
encontrar un sistema generador del un espacio nulo de [[A]]. Lo
haremos con el método auxiliar [[SGenENulo]].
\begin{codigo}[nobreak=true]
<<Inicialización de la clase [[SubEspacio]]>>=
def __init__(self,data):
    """Inicializa un SubEspacio de Rn"""
    <<Método auxiliar [[SGenENulo]] que Encuentra un sistema generador del Espacio Nulo de A>>
    if not isinstance(data, (Sistema, Matrix)):
        raise ValueError(' Argumento debe ser un Sistema o Matrix ')
    if isinstance(data, Sistema):
        A          = Matrix(data)
        self.base  = Sistema([ c for c in Elim(A) if c.no_es_nulo() ])
        self.dim   = len(self.base)
        self.sgen  = self.base if self.base else Sistema([ V0(A.m) ])
        self.cart  = ~Matrix(SGenENulo(~A))
        self.Rn    = A.m
    if isinstance(data, Matrix):
        A          = data
        self.sgen  = SGenENulo(A)  
        self.dim   = 0 if self.sgen.es_nulo() else len(self.sgen)
        self.base  = self.sgen if self.dim else Sistema([])
        self.cart  = ~Matrix(SGenENulo(~Matrix(self.sgen)))
        self.Rn    = A.n
@ %def SubEspacio
\end{codigo}

Una base del espacio nulo está formada por los vectores de [[E]]
correspondientes a los vectores nulos de [[K]]
\begin{codigo}[nobreak=true]
<<Método auxiliar [[SGenENulo]] que Encuentra un sistema generador del Espacio Nulo de A>>=
def SGenENulo(A):
    """Encuentra un sistema generador del Espacio Nulo de A"""
    K = Elim(A);   E = I(A.n) & T(K.pasos[1])
    S = Sistema([ v for j, v in enumerate(E,1) if (K|j).es_nulo() ])
    return S if S else Sistema([V0(A.n)])
@ %%%def SGenENulo
\end{codigo}


Definimos un método que nos indique si es cierto que un [[SubEspacio]]
está contenido en otro ([[contenido_en]]). Si [[A]] y [[B]] son
[[SubEspacio]]s, la siguiente expresión 
\begin{center}
  \Verb/A.contenido_en(B)/
\end{center}
nos dirá si es cierto que [[A]] es un [[SubEspacio]] de [[B]] (fíjese
que como ``[[contenido_en]]'' no es un ``Método Mágico'' de Python, se
debe invocar escribiendo \Verb/A.contenido_en()/, donde [[A]] es un
[[SubEspacio]].

Para comprobar si un [[SubEspacio]] [[A]] está contenido en un
[[SubEspacio]] [[B]], basta verificar si todos los vectores del
sistema generador de [[A]] son solución de las ecuaciones cartesianas
de [[B]]. Si [[B]] es un [[EAfin]], entonces [[B.v]] debe ser nulo y
[[A]] debe estás contenido en [[B.S]].
\begin{codigo}[nobreak=true]
<<Métodos de la clase [[SubEspacio]]>>=
def contenido_en(self, other):
    """Indica si este SubEspacio está contenido en other"""
    self.verificacion(other)
    if isinstance(other, SubEspacio):
        return all ([ (other.cart*v).es_nulo() for v in self.sgen ])
    elif isinstance(other, EAfin):
        return other.v.es_nulo() and self.contenido_en(other.S)

@
%% La otra forma de ver si un subespacio está dentro de otra es por eliminación:        
% M = Matrix(BlockM([[Matrix(other.sgen), Matrix( self.sgen)]]))
% return True if (Elim(M).rango == other.dim) else False
\end{codigo}   
También definimos dos métodos (mágicos) que nos indican
\begin{itemize}
\item si dos [[SubEspacio]]s son iguales ([[__eq__]]), es decir, que
  [[A]] esta contenido en [[B]] y viceversa; o
\item si son distintos ([[__ne__]]), es decir, que no son iguales.
\end{itemize}
Así podemos usar las siguientes expresiones booleanas
\begin{center}
\Verb/A == B/
\quad y \quad
\Verb/A != B/
\end{center}

\begin{codigo}[nobreak=true]
<<Métodos de la clase [[SubEspacio]]>>=
def __eq__(self, other):
    """Indica si un subespacio de Rn es igual a otro"""
    self.verificacion(other)
    return self.contenido_en(other) and other.contenido_en(self)

def __ne__(self, other):
    """Indica si un subespacio de Rn es distinto de otro"""
    self.verificacion(other)
    return not (self == other)

@
\end{codigo}

Para que estos tres métodos funcionen es necesario un método auxiliar
que realice la [[verificacion]] de que los dos argumentos son
[[SubEspacio]]s o [[EAfin]]es del mismo espacio vectorial \R[m] (como
este método tampoco es mágico, se invoca con [[self.verificacion()]]).

\begin{codigo}[nobreak=true]
<<Métodos de la clase [[SubEspacio]]>>=
def verificacion(self,other):
    if not isinstance(other, (SubEspacio, EAfin)) or  not self.Rn == other.Rn: 
        raise \
         ValueError('Ambos argumentos deben ser subconjuntos de en un mismo espacio')

@ 
\end{codigo}

También definimos un método que nos devuelva la suma de dos
[[SubEspacio]]s de \R[m]: \quad \Verb/ A + B/. \; Para ello basta
concatenar los [[Sistema]]s en uno solo.
\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[SubEspacio]]>>=
def __add__(self, other):
    """Devuelve la suma de subespacios de Rn"""
    self.verificacion(other)
    return SubEspacio(Sistema(self.sgen.concatena(other.sgen)))

@ 
\end{codigo}

y definimos otro método que nos devuelva la intersección:\quad
\Verb/ A & B/. \; Para ello apilamos las matrices de las ecuaciones
cartesianas en una sola [[Matrix]] y obtenemos el [[SubEspacio]]
correspondiente. Si [[other]] es un [[EAfin]] llamamos al método de la
intersección entre un [[EAfin]] y un [[SubEspacio]].
\begin{codigo}[nobreak=true]
<<Métodos de la clase [[SubEspacio]]>>=
def __and__(self, other):
    """Devuelve la intersección de subespacios"""
    self.verificacion(other)
    if isinstance(other, SubEspacio):
        return SubEspacio( self.cart.apila(other.cart) )
    elif  isinstance(other, EAfin):
        return other & self

@
\end{codigo}    

Con [[~A]] obtendremos el complemento ortogonal del [[SubEspacio]]
[[A]], es decir, el [[Sistema]] formado por las filas (las columnas de
la transpuesta) de [[self.cart]]

\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[SubEspacio]]>>=
def __invert__(self):
    """Devuelve el complemento ortogonal"""
    return SubEspacio( Sistema( ~(self.cart) ) )

@
\end{codigo}
\noindent
y por último definimos un método que nos indique si un [[Vector]]
[[x]] pertenece a un [[SubEspacio]] [[A]], es decir, que indique si es cierta o no la siguiente expresión booleana
\begin{center}
  \Verb/ x in A /
\end{center}
Basta verificar que el vector es solución del sistema de ecuaciones cartesianas.
\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[SubEspacio]]>>=
def __contains__(self, other):
    """Indica si un Vector pertenece a un SubEspacio"""
    if not isinstance(other, Vector) or other.n != self.cart.n:
        raise ValueError\
              ('El Vector no tiene el número adecuado de componentes')
    return (self.cart*other == V0(self.cart.m))

@ 
\end{codigo}

\begin{codigo}[nobreak=true]
<<La clase SubEspacio>>=
class SubEspacio:
    <<Inicialización de la clase [[SubEspacio]]>>
    <<Métodos de la clase [[SubEspacio]]>>
    <<Métodos de representación de la clase [[SubEspacio]]>>

@  %def SubEspacio
\end{codigo}

\section{La clase \texttt{EAfin} (de \R[m])}
El conjunto de soluciones de un sistema de ecuaciones homogéneo
\SEL{A}{x}{0} forma un subespacio (que llamamos espacio nulo
\nulls{A}), pero el conjunto de soluciones de \SEL{A}{x}{b} cuando
$\Vect{b}\ne\Vect{0}$ es un \emph{espacio afín}.

Vamos a crear la clase [[EAfin]]. La definiremos como un par
$(\EV{S},\Vect{v})$ cuyo primer elemento, \EV{S}, sea un
[[SubEspacio]] (el conjunto de soluciones a \SEL{A}{x}{0}) y cuyo
segundo elemento, \Vect{v}, sea un vector del espacio afín (una
solución particular de \SEL{A}{x}{b}). En el atributo [[S]]
guardaremos el [[SubEspacio]] y en el atributo [[v]] el
[[Vector]]. Así, pues, para instanciar un [[EAfin]] usaremos dos
argumentos: el primero será un [[Sistema]] o [[Matrix]] con la que
formar el [[SubEspacio]], y el segundo será un [[Vector]].


Cuando $\Vect{v}\in\EV{S}$, el espacio afín es un subespacio (que por
tanto contiene al vector nulo). Así que si $\Vect{v}\in\EV{S}$ en el
atributo [[v]] guardaremos el vector nulo. Así, si consideramos el
sistema ``ampliado'' que contiene los vectores del sistema generador
de [[S]] primero, y [[v]] como último vector [[v]], y aplicamos el
método de eliminación de izquierda a derecha; el último vector tras la
eliminación pertenece al espacio afín, y será cero si
$\Vect{v}\in\EV{S}$.


\begin{codigo}[nobreak=true] 
<<Inicialización de la clase [[EAfin]]>>=
def __init__(self,data,v):
    """Inicializa un Espacio Afín de Rn"""
    self.S  = data if isinstance(data, SubEspacio) else SubEspacio(data)
    if not isinstance(v, Vector) or v.n != self.S.Rn:
         raise ValueError('v y SubEspacio deben estar en el mismo espacio vectorial')
    self.v  = Elim( self.S.sgen.concatena(Sistema([v]))) |0
    self.Rn = self.S.Rn
    
@ %def EAfin
\end{codigo}

\begin{codigo}[nobreak=true]
<<La clase EAfin>>=
class EAfin:
    <<Inicialización de la clase [[EAfin]]>>
    <<Métodos de la clase [[EAfin]]>>
    <<Métodos de representación de la clase [[EAfin]]>>
@  %def EAfin
\end{codigo}

Un vector \Vect{x} pertenece al espacio afín \EV{S} si verifica las
ecuaciones cartesianas, cuya matriz de coeficientes es
[[self.S.cart]], y cuyo vector del lado derecho es
[[(self.S.cart)*self.v]]. Así pues

\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[EAfin]]>>=
def __contains__(self, other):
    """Indica si un Vector pertenece a un EAfin"""
    if not isinstance(other, Vector) or other.n != self.S.cart.n:
        raise ValueError('Vector con un número inadecuado de componentes')
    return (self.S.cart)*other == (self.S.cart)*self.v

@ 
\end{codigo}

\begin{codigo}[nobreak=true]
<<Métodos de la clase [[EAfin]]>>=
def contenido_en(self, other):
    """Indica si este EAfin está contenido en other"""
    self.verificacion(other)
    if isinstance(other, SubEspacio):
         return self.v in other and self.S.contenido_en(other)
    elif isinstance(other, EAfin):
         return self.v in other and self.S.contenido_en(other.S)

@ 
\end{codigo}

\begin{codigo}[nobreak=true]
<<Métodos de la clase [[EAfin]]>>=
def __eq__(self, other):
    """Indica si un EAfin de Rn es igual a other"""
    self.verificacion(other)
    return self.contenido_en(other) and other.contenido_en(self)

def __ne__(self, other):
    """Indica si un subespacio de Rn es distinto de other"""
    self.verificacion(other)
    return not (self == other)

@
\end{codigo}

\begin{codigo}[nobreak=true]
<<Métodos de la clase [[EAfin]]>>=
def verificacion(self,other):
    if not isinstance(other, (SubEspacio, EAfin)) or  not self.Rn == other.Rn: 
        raise \
         ValueError('Ambos argumentos deben ser subconjuntos de en un mismo espacio')

@ 
\end{codigo}

La intersección es el conjunto de soluciones a ambos sistemas de
ecuaciones cartesianas. El modo más sencillo es unificar ambos
sistemas en uno solo: apilando las matrices de coeficientes por un
lado y concatenando los vectores del lado derecho por el otro.
\begin{codigo}[nobreak=true]
<<Métodos de la clase [[EAfin]]>>=
def __and__(self, other):
    """Devuelve la intersección de este EAfin con other"""
    self.verificacion(other)
    if isinstance(other, EAfin):
        M = self.S.cart.apila( other.S.cart )
        w = (self.S.cart*self.v).concatena( other.S.cart*other.v )
    elif isinstance(other, SubEspacio):
        M = self.S.cart.apila( other.cart )
        w = (self.S.cart*self.v).concatena( V0(other.cart.m) )                                                      
    try:
        S=SEL(M,w)
    except:
        print('Intersección vacía')
        return Sistema([])
    else:
        return S.eafin

@
\end{codigo}    


Con [[~A]] obtendremos el mayor [[SubEspacio]] perpendicular a [[A]].
\begin{codigo}[nobreak=true] 
<<Métodos de la clase [[EAfin]]>>=
def __invert__(self):
    """Devuelve el mayor SubEspacio perpendicular a self"""
    return SubEspacio( Sistema( ~(self.S.cart) ) )

@
\end{codigo}


\begin{codigo}[nobreak=true]
<<Métodos de representación de la clase [[EAfin]]>>=
def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def EcParametricas(self):
    """Representación paramétrica del SubEspacio"""
    return '\\left\\{ \\boldsymbol{v}\\in\\mathbb{R}^' \
      + latex(self.S.Rn) \
      + '\ \\left|\ \\exists\\boldsymbol{p}\\in\\mathbb{R}^' \
      + latex(max(self.S.dim,1)) \
      + ',\\; \\boldsymbol{v}= '\
      + latex(self.v) + '+' \
      + latex(Matrix(self.S.sgen)) \
      + '\\boldsymbol{p}\\right. \\right\\}' \

def EcCartesianas(self):
    """Representación cartesiana del SubEspacio"""
    return '\\left\\{ \\boldsymbol{v}\\in\\mathbb{R}^' \
      + latex(self.S.Rn) \
      + '\ \\left|\ ' \
      + latex(self.S.cart) \
      + '\\boldsymbol{v}=' \
      + latex(self.S.cart*self.v) \
      + '\\right.\\right\\}' \
    
def latex(self):
    """ Construye el comando LaTeX para un SubEspacio de Rn"""
    if self.v != 0*self.v:
         return self.EcParametricas() + '\\; = \\;' + self.EcCartesianas()
    else:
         return latex(self.S)
        
@ 
\end{codigo}

\chapter{Otros trozos de código}
\label{parte:TrozosCodigoSecundarios}

\section{Métodos de representación para el entorno Jupyter}
El método \texttt{html}, escribe el inicio y el final de un párrafo en
html y en medio del párrafo escribirá la cadena [[TeX]]; que contendrá
el código \LaTeX\ de las expresiones matemáticas que queremos que se
muestren en pantalla cuando usamos \href{https://jupyter.org/}{Jupyter
  Notebook}. En el navegador, la librería
\href{https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Typesetting%20Equations.html}{MathJax}
  de Javascript se encargará de convertir la expresión \LaTeX\ en la
  grafía correspondiente.
\begin{codigo}
<<Método html general>>=  
def html(TeX):
    """ Plantilla HTML para insertar comandos LaTeX """
    return "<p style=\"text-align:center;\">$" + TeX + "$</p>"
    
@
\end{codigo}
El método \texttt{latex} general, intentará llamar al método [[latex]]
particular del objeto que se quiere representar (para todos los
objetos de esta librería se define su método de representación). Si el
objeto no tiene definido el método [[latex]], entonces se emplea el
método [[latex]] de la librería
\href{https://www.sympy.org/en/index.html}{Sympy}\;
([[sympy.latex()]]). Además, se pide que el en tal caso, antes de
representar el objeto se simplifican las expresiones si ello es
posible. Así,
\begin{center}
  [[ Vector([ sympy.Rational(1.5, 3), fracc(2.4, 1.2), fracc(2, sympy.sqrt(2)) ], rpr='fila') ]]
\end{center}
será representado como
\begin{displaymath}
  \begin{pmatrix}\frac{1}{2},&2,&\sqrt{2}\end{pmatrix}
\end{displaymath}
%
%el objeto representado 
%
%convertirá en cadena de caracteres los
%inputs de tipo \texttt{str}, \texttt{float} o
%\texttt{int}~\footnote{resulta que para los tipos de datos
%  \texttt{int} y \texttt{float} no es posible definir un nuevo método
%  de representación. Afortunadamente la cadena de caracteres que
%  representa el número nos vale perfectamente en ambos casos (tanto
%  para los números enteros, \texttt{int}, como los números con
%  decimales, \texttt{float}).}, y en el resto de casos llamara al
%método \texttt{latex} de la clase desde la que se invocó a este método
%(es un truqui recursivo para que trate de manera parecida la
%expresiones en \LaTeX\ y los tipos de datos que corresponden a números
%\texttt{int} o \texttt{float}).
\begin{codigo}
<<Método latex general>>=
def latex(a):
    try:
        return a.latex()
    except:
        return sympy.latex(simplifica(a))
         
@ 
\end{codigo}
Con el método [[simplifica]] se devuelven las expresiones
simplificadas. Si el objeto es una tupla, lista o [[Sistema]], se
devuelve un objeto del mismo tipo, pero cuyos elementos han sido
simplificados. Si [[self]] es otro tipo de objeto, entonces se
``sympyfica'' con [[sympy.sympify(self)]], es decir, se transforma un
objeto de la librería
\href{https://www.sympy.org/en/index.html}{Sympy},\; para así poder
ser simplificado con el método [[sympy.simpify()]].
\begin{codigo}
<<Simplificación de expresiones simbólicas>>=
def simplifica(self):
    """Devuelve las expresiones simplificadas"""
    if isinstance(self, (list, tuple, Sistema)):
        return type(self)([ simplifica(e) for e in self ])
    else:
        return (sympy.sympify(self)).simplify()
    
@ %def simplifica
\end{codigo}


\begin{codigo}
<<Pinta un objeto en Jupyter>>=
def pinta(data):
    display(Math(latex(simplifica(data))))

@ %def pinta
\end{codigo}

\section{Completando la clase \texttt{Sistema}}
\label{sec:completandoSistema}
\subsection{Representación de la clase \texttt{Sistema}}
Necesitamos indicar a Python cómo representar los objetos de
tipo \texttt{Sistema}.

Los sistemas, son secuencias finitas de objetos que representaremos
con corchetes, separando los elementos por ``;''
\begin{displaymath}
  \Vect{v}=[v_1;\ \ldots;\ v_n;]
\end{displaymath}
Definimos tres representaciones distintas. Una para la línea de
comandos de Python de manera que ``abra'' el corchete ``\texttt{[}'' y
a continuación muestre \verb/self.lista/ (la lista de objetos)
separados por puntos y comas y se ``cierre'' el corchete
``\texttt{]}''. Por ejemplo, si la lista es \texttt{[a,b,c]}, Python
nos mostrará en la linea de comandos: \texttt{[a;\ b;\ c]}.

La representación en \LaTeX\ sigue el mismo esquema, pero los
elementos son mostrados en su representación \LaTeX\ (si la tienen) y
es usada a su vez por la representación html usada por el entorno
Jupyter.  \medskip

\begin{codigo}[nobreak=true] 
<<Métodos de representación de la clase [[Sistema]]>>=  
def __repr__(self):
    """ Muestra un Sistema en su representación python """
    return 'Sistema([' + \
        '; '.join( repr (e) for e in self ) + \
        ';])'

def _repr_html_(self):
    """ Construye la representación para el entorno jupyter notebook """
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para representar un Sistema """
    return '\\left[' + \
        ';\;'.join( latex(e) for e in self ) + \
        ';\\right]'

@
\end{codigo}

\subsection{Otros métodos de la clase \texttt{Sistema}}
Con el método [[sis]] obtendremos el [[Sistema]] correspondiente a
cualquier [[Sistema]] o subclase de [[Sistema]]. Así, si [[A]] es una
[[Matrix]], con [[A.sis()]] obtenemos el [[Sistema]] de [[Vectores]]
(columnas) asociado.
\begin{codigo}
<<Método para recuperar el [[Sistema]] de cualquier subclase de [[Sistema]]>>=
def sis(self):
    return Sistema(self.lista)

@                                                                
\end{codigo}

\begin{codigo}
<<Comprobación de que un [[Sistema]] es nulo>>=
def es_nulo(self):
    """Indica si es cierto que el Sistema es nulo"""
    return self==self*0

def no_es_nulo(self):
    """Indica si es cierto que el Sistema no es nulo"""
    return self!=self*0

@ 
\end{codigo}

\begin{codigo}
<<Comprobación de que todos los elementos de un [[Sistema]] son del mismo tipo>>=
def de_composicion_uniforme(self):
   """Indica si es cierto que todos los elementos son del mismo tipo"""
   return all(type(e)==type(self[0]) for e in self)
@ 
\end{codigo}

\begin{codigo}
<<Sustitución de un símbolo por un valor en un [[Sistema]]>>=
def subs(self, s,v):
    if isinstance(self, sympy.Basic):
        return sympy.S(self).subs(s,v)
    elif isinstance(self, Sistema):
        return type(self)([ sympy.S(e).subs(s,v) for e in self ])
    
@ 
\end{codigo}

\begin{codigo}
<<Junta una lista de [[Sistema]]s en un único [[Sistema]]>>=
def junta(self, l):
    """Junta una lista o tupla de Sistemas en uno solo concatenando las
    correspondientes listas de los distintos Sistemas"""
    l = l if isinstance(l, list) else [l]

    junta_dos = lambda x, other: x.concatena(other)
    reune     = lambda x: x[0] if len(x)==1 else junta_dos( reune(x[0:-1]), x[-1] )
    
    return reune([self] + [s for s in l])
    
@ %def junta
\end{codigo}


\newpage

\section{Completando la clase \texttt{Vector}}
\subsection{Representación de la clase \texttt{Vector}}

Necesitamos indicar a Python cómo representar los objetos de
tipo \texttt{Vector}.

Los vectores, son secuencias finitas de números que representaremos
con paréntesis, bien en forma de fila
\begin{displaymath}
  \Vect{v}=(v_1,\ldots,v_n)
\end{displaymath}
o bien en forma de columna
\begin{displaymath}
  \Vect{v}=\begin{pmatrix}v_1\\ \vdots \\ v_n\end{pmatrix}
\end{displaymath}
Definimos tres representaciones distintas. Una para la línea de
comandos de Python de manera que escriba \texttt{Vector} y a
continuación encierre la representación de \verb/self.sis/ (el
sistema de números), entre paréntesis. Por ejemplo, si la lista es
\texttt{[a,b,c]}, Python nos mostrará en la linea de comandos:
\texttt{Vector([a,b,c])}.

La representación en \LaTeX\ encierra un vector (en forma de fila o de
columna) entre paréntesis; y es usada a su vez por la representación
html usada por el entorno Jupyter.  \medskip
  
\begin{codigo}
<<Representación de la clase [[Vector]]>>=
def __repr__(self):
    """ Muestra el vector en su representación Python """
    return 'Vector(' + repr(self.lista) + ')'

def _repr_html_(self):
    """ Construye la representación para el entorno Jupyter Notebook """
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para representar un Vector"""
    if self.rpr == 'fila' or self.n==1:    
        return '\\begin{pmatrix}' + \
               ',&'.join([latex(e) for e in self]) + \
               ',\\end{pmatrix}' 
    else:
        return '\\begin{pmatrix}' + \
               '\\\\'.join([latex(e) for e in self]) + \
               '\\end{pmatrix}'
               
@ 
\end{codigo}


\subsection{Otros métodos para la clase \texttt{Vector}}

\begin{codigo}
<<Creación de una [[Matrix]] diagonal a partir de un [[Vector]]>>=
def diag(self):
    """Crea una Matrix diagonal cuya diagonal es self"""
    return Matrix([a*(I(self.n)|j) for j,a in enumerate(self, 1)])

@  
\end{codigo}

\begin{codigo}
<<Normalización de un [[Vector]]>>=
def normalizado(self):
    """Devuelve un múltiplo de un vector (no nulo) pero norma uno"""
    if self.es_nulo(): raise ValueError('Un vector nulo no se puede normalizar')

    return self * fracc(1,sympy.sqrt(self*self))
        
@ %def normalizado
\end{codigo}


\section{Completando la clase \texttt{Matrix}}
        
\subsection{Otras formas de instanciar una \texttt{Matrix}}

Si se introduce una lista (tupla) de listas o tuplas, creamos una
matriz fila a fila. Si se introduce un \texttt{SisMat}, se apilan sus
matrices concatenando las columnas para obtener una única matriz. Si
se introduce una \texttt{BlockM} se elimina el particionado y que crea
una única matriz.
\begin{codigo}
<<Creación del atributo [[lista]] cuando no tenemos una [[lista]] de [[Vector]]es>>=        
elif isinstance(data, SisMat):
    self.lista = (data|1).apila(data.lista[1:]).lista.copy() if len(data)>1 \
                                    else (data|1).lista.copy()

elif isinstance(data, BlockM):
    listmat = [Matrix(sismat) for sismat in data]
    self.lista = (listmat[0]).junta(listmat[1:]).lista.copy()

elif isinstance(lista[0], (list, tuple, Sistema)):
    <<Verificación de que todas las filas de la matriz tendrán la misma longitud>>
    self.lista  =  [ Vector( [ lista[i][j] for i in range(len(lista)) ] ) \
                                           for j in range(len(lista[0])) ].copy()

@                                               
\end{codigo}
\subsection{Códigos que verifican que los argumentos son correctos}
\begin{codigo}
<<Verificación de que todas las filas de la matriz tendrán la misma longitud>>=
if not all ( type(lista[0])==type(v) and len(lista[0])==len(v) for v in lista ):
    raise ValueError('no todo son listas, o no tienen la misma longitud!')

@ 

<<Verificación de que todas las columnas de la matriz tienen la misma longitud>>=
if not all ( isinstance(v, Vector)   and lista[0].n==v.n       for v in lista ):
    raise ValueError('no todo son vectores, o no tienen la misma longitud!')

@
\end{codigo}

\subsection{Representación de la clase \texttt{Matrix}}

Y como en el caso de los vectores, construimos los dos métodos de
presentación. Uno para la consola de comandos que escribe
\texttt{Matrix} y entre paréntesis la lista de listas (es decir la
lista de filas); y otro para el entorno Jupyter (que a su vez usa la
representación \LaTeX\ que representa las matrices entre corchetes
como en las notas de la asignatura). Si self.lista es una lista vacía,
se representa una matriz vacía.

\begin{codigo}
<<Representación de la clase [[Matrix]]>>=
def __repr__(self):
    """ Muestra una matriz en su representación Python """
    return 'Matrix(' + repr(self.lista) + ')'

def _repr_html_(self):
    """ Construye la representación para el  entorno Jupyter Notebook """
    return html(self.latex())
    
def latex(self):
    """ Construye el comando LaTeX para representar una Matrix """
    return '\\begin{bmatrix}' + \
           '  \\\\'.join(['&'.join([latex(e) for e in fila]) for fila in ~self]) + \
           '\\end{bmatrix}'
           
@   
\end{codigo}

\subsection{Otros métodos para la clase \texttt{Matrix}}

\begin{codigo}
<<Métodos útiles para la clase [[Matrix]]>>=
<<Comprobación de que una [[Matrix]] es cuadrada>>
<<Comprobación de que una [[Matrix]] es simétrica>>
<<Creación de un [[Vector]] a partir de la diagonal de una [[Matrix]]>>
<<Normalizado de las columnas (o filas) de una matriz>>
<<Apila una lista de [[Matrix]] con el mismo número de columnas en una única [[Matrix]]>>
<<Extiende una [[Matrix]] a lo largo de la diagonal con una lista de [[Matrix]]>>
<<Transforma una [[Matrix]] más una lista de [[Matrix]] en una [[BlockM]] diagonal>>
@ 
\end{codigo}

\begin{codigo}
<<Comprobación de que una [[Matrix]] es cuadrada>>=
def es_cuadrada(self):
    """Indica si es cierto que la Matrix es cuadrada"""
    return self.m==self.n
    
@ %def es_cuadrada
\end{codigo}

\begin{codigo}
<<Comprobación de que una [[Matrix]] es simétrica>>=
def es_simetrica(self):
    """Indica si es cierto que la Matrix es simétrica"""
    return self == ~self
    
@ %def es_simetrica
\end{codigo}

\begin{codigo}
<<Creación de un [[Vector]] a partir de la diagonal de una [[Matrix]]>>=
def diag(self):
    """Crea un Vector a partir de la diagonal de self"""
    return Vector([ (j|self|j) for j in range(1,min(self.m,self.n)+1)])

@
\end{codigo}

\begin{codigo}
<<Normalizado de las columnas (o filas) de una matriz>>=
def normalizada(self,o='Columnas'):
    if o == 'Columnas':
        if any( v.es_nulo() for v in self):
            raise ValueError('algún vector es nulo')
        return Matrix([ v.normalizado() for v in self])
    else:
        return ~(~self.normalizada())
        
@ %def normalizada
\end{codigo}


\begin{codigo}[nobreak=true]
<<Comprobación de que una [[Matrix]] es singular>>=
def es_singular(self):
    if not self.es_cuadrada():
        raise ValueError('La matriz no es cuadrada')
    return self.rg()<self.n
  
@ %def es_singular
\end{codigo}

\begin{codigo}[nobreak=true]
<<Comprobación de que una [[Matrix]] es invertible>>=
def es_invertible(self):
    if not self.es_cuadrada():
        raise ValueError('La matriz no es cuadrada')
    return self.rg()==self.n
  
@ %def es_singular
\end{codigo}

\begin{codigo}[nobreak=true]
<<Apila una lista de [[Matrix]] con el mismo número de columnas en una única [[Matrix]]>>=
def apila(self, l):
    """Apila una lista o tupla de Matrix con el mismo número de columnas
    es una única Matrix concatenando las respectivas columnas"""
    l = l if isinstance(l, list) else [l]
                                                               
    apila_dos = lambda x, other: ~((~x).concatena(~other))
    apila = lambda x: x[0] if len(x)==1 else apila_dos( apila(x[0:-1]), x[-1] )
    
    return apila([self] + [s for s in l])
    
@ %def apila
\end{codigo}

\begin{codigo}
<<Extiende una [[Matrix]] a lo largo de la diagonal con una lista de [[Matrix]]>>=
def ExtiendeDiag(self,lista):
    if not all(isinstance(m,Matrix) for m in lista): 
        return ValueError('No es una lista de matrices')
    Ext_dos = lambda x, y: Matrix(BlockM([[x,M0(x.m,y.n)],[M0(y.m,x.n),y] ]))
    ExtDiag     = lambda x: x[0] if len(x)==1 else Ext_dos( ExtDiag(x[0:-1]), x[-1] )
    return ExtDiag([self]+lista)
    
@ %def ExtiendeDiag
\end{codigo}

\begin{codigo}
<<Transforma una [[Matrix]] más una lista de [[Matrix]] en una [[BlockM]] diagonal>>=
def BlockDiag(self,lista):
    if not all(isinstance(m,Matrix) for m in lista): 
        return ValueError('No es una lista de matrices')
    
    lm = [e.m for e in [self]+lista]
    ln = [e.n for e in [self]+lista]
    return key(lm)|self.ExtiendeDiag(lista)|key(ln)
    
@ %def BlockDiag
\end{codigo}

\subsection{Otros métodos de la clase {\tt Matrix} que usan la eliminación}
Para ver la implementación de la eliminación, véase el
Capítulo~\ref{part:Algoritmos}.
\subsubsection{Formas pre-escalonada (\Mat{K}), escalonada (\Mat{L}),
  y escalonada reducida (\Mat{R}) y rango}
\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def K(self,rep=0):
    """Una forma pre-escalonada por columnas (K) de una Matrix"""
    return Elim(self,rep)
    
def L(self,rep=0): 
    """Una forma escalonada por columnas (L) de una Matrix"""
    return ElimG(self,rep)
    
def U(self,rep=0): 
    """Una forma escalonada por columnas (L) de una Matrix"""
    return ElimGF(self,rep)

def R(self,rep=0):
    """Forma escalonada reducida por columnas (R) de una Matrix"""
    return ElimGJ(self,rep)

def rg(self):
    """Rango de una Matrix"""
    return self.K().rango

@ 
\end{codigo}

\subsection{Otros métodos de la clase {\tt Matrix} que usan la eliminación
  y que son específicos de las matrices cuadradas}
\subsubsection{Potencias de una \texttt{Matrix} cuadrada}
Ahora podemos calcular la [[n]]-ésima potencia de una [[Matrix]].
Cuando [[n]] es un entero positivo; basta multiplicar la [[Matrix]]
por si misma [[n]] veces.

Si [[n]] es un entero negativo, entonces necesitamos calcular la
inversa de la [[n]]-ésima potencia; para ello usará el método de
eliminación Gaussiano que se describirá en el
Capítulo~\ref{part:Algoritmos}.

\begin{codigo}[nobreak=true] 
<<Potencia de una [[Matrix]]>>=
def __pow__(self,n):
    """Calcula la n-ésima potencia de una Matrix"""
    if not isinstance(n,int): raise ValueError('La potencia no es un entero')
    if not self.es_cuadrada:  raise ValueError('Matrix no es cuadrada')

    M = self if n else I(self.n)
    for i in range(1,abs(n)):
    	M = M * self

    return M.inversa() if n < 0 else M

@
\end{codigo}
%#    def MatrixInversa(self):
%#        if self.es_singular:  raise ValueError('Matrix singular')
%#        return I(self.n) & T(self.R().pasos[1])
          

\subsubsection{Inversa de una \texttt{Matrix}}

\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def inversa(self, rep=0):                                                               
    """Inversa de Matrix"""
    return InvMat(self,rep)

@ 
\end{codigo}


\subsubsection{Determinante}
Para calcular el determinante,
\begin{itemize}
\item Comprobamos si la matriz es cuadrada.
\item De la lista de abreviaturas de las transformaciones de las
  columnas usadas para obtener la forma escalonada reducida (\Mat{R})
  de la matriz ([[T(self.R().pasos[1]).t]]) seleccionamos las de
  longitud 2 (las correspondientes a los intercambios y a las
  transformaciones \emph{Tipo II}) para crear la lista [[A]] (de las
  abreviaturas las transformaciones relevantes para el cálculo del
  determinante).
\item Generamos una nueva lista [[m]] en la que por cada abreviatura
  [[tr]] de [[A]] correspondiente a un intercambio ([[set]]) incluimos
  un ``$-1$'' (un cambio de signo), por cada abreviatura
  correspondiente a un producto, incluimos el inverso del número por
  el que se multiplico cada columna ([[tr[0]]]).
\item Definimos recursivamente la función [[producto]] de todos los
  elementos de una lista.
\item Si la matriz es singular se devuelve un 0; y en caso contrario
  el [[producto]] de los elementos de la lista [[m]].
\end{itemize}

\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def determinante(self, rep=0):
    """Devuelve el valor del det. de Matrix"""
    return Determinante(self,rep).valor

@ %def determinante
\end{codigo}
%    #"""Devuelve el determinante de una matriz cuadrada"""
%    #if not self.es_cuadrada:  raise ValueError('Matrix no es cuadrada')
%    
%    #A = [ tr for tr in filter( lambda x: len(x)==2, T(self.R().pasos[1]).t ) ]
%    #m = [-1 if isinstance(tr,set) else fracc(1,tr[0]) for tr in A]
%    
%    #producto  = lambda x: 1 if not x else x[0] * producto(x[1:])
%    
%    #return 0 if self.rango() < self.n else producto(m)    

\subsubsection{Método de diagonalización por semejanza}

\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def diagonalizaS(self, espectro, rep=0):
    <<Texto de ayuda para la clase [[Diagonaliza]]>>
    return Diagonaliza(self, espectro, rep)

@ %def diagonalizaS
\end{codigo}

\subsubsection{Método de diagonalización ortogonal}

\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def diagonalizaO(self, espectro, rep=0):
    <<Texto de ayuda para la clase [[DiagonalizaO]]>>
    return DiagonalizaO(self, espectro)

@ %def diagonalizaO
\end{codigo}


\subsubsection{Método de Gram-Schmidt}
\begin{codigo}[nobreak=true]
<<Método Gram-Schmidt para ortogonalizar un sistema de Vectores>>=
def GS(self):
    """Devuelve una Matrix equivalente cuyas columnas son ortogonales

    Emplea el método de Gram-Schmidt"""
    A = Matrix(self)
    for n in range(2,A.n+1):
        A & T([ (-fracc((A|n)*(A|j),(A|j)*(A|j)), j, n) \
                for j in range(1,n) if (A|j).no_es_nulo() ])
    return A

@
\end{codigo}


\subsubsection{Método de diagonalización por congruencia}

Evitando dividir si es posible\dots entonces la matriz \Mat{B} será entera\dots
\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def diagonalizaC(self, rep=0):
    <<Texto de ayuda para la clase [[DiagonalizaC]]>>
    return DiagonalizaC(self, rep)

@ %def diagonalizaC
\end{codigo}

O con menos operaciones, a coste de que aparezcan fracciones\dots
\begin{codigo}[nobreak=true]
<<Métodos de [[Matrix]] que usan la eliminación>>=
def diagonalizaCr(self, rep=0):
    <<Texto de ayuda para la clase [[DiagonalizaCr]]>>
    return DiagonalizaCr(self, rep)

@ %def diagonalizaCr
\end{codigo}


% \subsubsection{Factorización $\Mat{AP}=\Mat{LU}$}
% Para calcular una factoriazación LU,
% \begin{codigo}[nobreak=true]
% Métodos de [[Matrix]] que usan la eliminación>>=
% def LU(self):
%     """Encuentra una factorización L*U de self*P

%     donde L es una Matrix triangular inferior, U una Matrix triangular
%     superior y P una Matrix permutación"""
%     P = I(self.n)  & T(ElimG(Matrix(Elim(self,1)),1).pasos[1])
%     L = Elim(self * ~P,1)
%     U = I(self.n) & T(L.pasos[1])**-1
%     return Sistema([Matrix(L),U,P])
    
% @
% \end{codigo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsubsection{Factorización $\Mat{AP}=\Mat{LDU}$}
% Para calcular una factoriazación LU,
% \begin{codigo}[nobreak=true]
% Métodos de [[Matrix]] que usan la eliminación>>=
% def LDU(self):
%     """Encuentra una factorización L*U de self*P

%     donde L es una Matrix triangular inferior, D una Matrix diagonal,
%     U una Matrix triangular superior y P una Matrix permutación"""
%     P = I(self.n)  & T(ElimG(Matrix(Elim(self))).pasos[1])
%     L = Elim(self * ~P)
%     U = I(self.n) & T(L.pasos[1])**-1
%     D = Matrix(L).diag().diag()
%     L = Matrix([(L|j)*fracc(1,j|D|j) if j|D|j else L|j for j in range(1,L.n+1)]) 
%     return Sistema([L,D,U,P])
    
% @
% \end{codigo}



\pagebreak[4]
\section{Vectores y Matrices especiales}

\begin{NotMat2}
  Los vectores cero $\Vect{0}$ y las matrices cero $\Mat{0}$ se pueden
  implementar como subclases de la clase \verb/Vector/ y \verb/Matrix/
  (pero tenga en cuenta que Python necesita conocer el número de
  componentes del vector y el orden de la matriz):
\end{NotMat2} [[V0]] es una subclase de [[Vector]] (por tanto hereda
los atributos de la clase [[Vector]]), pero el código inicia (y
devuelve) un objeto de su superclase, es decir, inicia y devuelve un
[[Vector]].
\begin{codigo}
<<Definición del vector nulo: [[V0]]>>=
class V0(Vector):
    def __init__(self, n ,rpr = 'columna'):
        """ Inicializa el vector nulo de n componentes"""
        super().__init__([0 for i in range(n)], rpr)
        self.__class__ = Vector

@ %def V0
\end{codigo}

Y lo mismo hacemos para matrices

\begin{codigo}
<<Definición de la matriz nula: [[M0]]>>=
class M0(Matrix):
    def __init__(self, m, n=None):
        """ Inicializa una matriz nula de orden n """
        n = m if n is None else n

        super().__init__([ V0(m) for j in range(n)])
        self.__class__ = Matrix

@ %def M0
\end{codigo}

También debemos definir la matriz identidad de orden $n$ (y sus filas
y columnas). En los apuntes de clase no solemos indicar expresamente
el orden de la matriz identidad (pues normalmente se sobrentiende por
el contexto). Pero esta habitual imprecisión no nos la podemos
permitir con el ordenador.

\begin{NotMat2}
    \begin{itemize}
    \item \Mat{I} (de orden $n$) es la matriz tal que
      \begin{math}
        \eleM{I}{i}{j}=
        \begin{cases}
          1&\text{si }j=i\\
          0&\text{si }j\neq i          
        \end{cases}.
      \end{math}
    % \item $\VectC[i]{I}=\VectF[i]{I}=%\e{i}{n}=
    %   (\delta_i^1,\ldots,\delta_i^n)$ donde
    %   $\delta_i^j=\left\{
    %     \begin{array}{cl}
    %       1&\text{si }j=i\\
    %       0&\text{si }j\neq i
    %     \end{array}
    %   \right.$      
    % \item \Mat{I} (de orden $n$) $=[\VectC[1]{I},\ldots,\VectC[n]{I}]$
    \end{itemize}  
\end{NotMat2}

\begin{codigo}
<<Definición de la matriz identidad: [[I]]>>=
class I(Matrix):
    def __init__(self, n):
        """ Inicializa la matriz identidad de tamaño n """
        super().__init__([[(i==j)*1 for i in range(n)] for j in range(n)])
        self.__class__ = Matrix

@ %def I
\end{codigo}

\newpage
\section{Completando la clase \texttt{T}}
\label{sec:completandoT}

\subsection{Otras formas de instanciar una \texttt{T}}
Si se instancia [[T]] usando otra [[T]]ransfomación elemental,
sencillamente se copia el atributo [[t]]. Si se instancia [[T]] usando
una lista (no vacía) de [[T]]ransfomaciones elementales,
%(aunque solo se verifica que el primer elemento de la lista es una [[T]])
el atributo [[t]] será la lista de abreviaturas resultante de
concatenar las abreviaturas de todas las [[T]]ransfomaciones
elementales de la lista empleada en la instanciación.
\begin{codigo}
<<Creación del atributo [[t]] cuando se instancia con otra [[T]] o lista de [[T]]s>>=
if isinstance(t, T):
    self.t = t.t

elif isinstance(t, list) and t and isinstance(t[0], T): 
	self.t = [val for sublist in [x.t for x in t] for val in CreaLista(sublist)]

@
\end{codigo}


\subsection{Representación de la clase \texttt{T}}
De nuevo construimos los dos métodos de presentación. Uno para la
consola de comandos que escribe \Verb/T/ y entre paréntesis la
abreviatura (una tupla o un conjunto) que representa la
transformación. Así,
\begin{itemize}
\item  \Verb/T( {1, 5} )/ \qquad: intercambio entre los vectores primero y quinto.
\item  \Verb/T( (6, 2) )/ \qquad: multiplica por seis el segundo vector.
\item  \Verb/T( (-1, 2, 3) )/\,: resta el segundo vector al tercero.
\end{itemize}
La otra representación es para el entorno Jupyter y replica la
notación usada en los apuntes de la asignatura:
\begin{displaymath}
  \begin{array}{|l||c|}
    \hline
    \text{Python} & \text{Representación en Jupyter} \\
    \hline\hline
    \text{\tt T( \{1, 5\} )}   & \underset{\left[\pe{1}{5}\right]}{\pmb{\tau}}\\\hline
    \text{\tt T( (6, 2) )}     & \underset{\left[\pr{6}{2}\right]}{\pmb{\tau}}                      \\\hline
    \text{\tt T( (-1, 2, 3) )} & \underset{\left[\su{-1}{2}{3}\right]}{\pmb{\tau}}          \\\hline
    %\text{\tt T( (6, 2) )}     & \underset{\left[(6)\mathbf{2}\right]}{\pmb{\tau}}                      \\\hline
    %\text{\tt T( (-1, 2, 3) )} & \underset{\left[(-1)\mathbf{2}+\mathbf{3}\right]}{\pmb{\tau}}          \\\hline
  \end{array}
\end{displaymath}
Los apuntes de la asignatura usan una notación matricial, y por tanto
es una notación que discrimina entre operaciones sobre las filas o las
columnas, situando los operadores a la izquierda o a la derecha de la
matriz. En este sentido, nuestra notación en Python hace lo
mismo. Así, en la siguiente tabla, la columna de la izquierda
corresponde a operaciones sobre las filas, y la columna de la derecha
a las operaciones sobre las columnas:
\begin{displaymath}
  \begin{array}{|r|r||l|l|}
    \hline
    \text{Mates II}&\text{Python} & \text{Mates II}&\text{Python}\\
    \hline\hline
    \TEIF{i}{j}{\Mat{A}}     & \text{{\tt T( \{i,j\} ) \& A}} &
    \TEIC{i}{j}{\Mat{A}}     & \text{{\tt A \& T( \{i,j\} ) }} \\ \hline
    \TEPF{a}{i}{\Mat{A}}     & \text{{\tt T( (a,i) ) \& A}}    &
    \TEPC{a}{j}{\Mat{A}}     & \text{{\tt A \& T( (a,j) ) }}   \\ \hline
    \TESF{a}{i}{j}{\Mat{A}} & \text{{\tt T( (a,i,j) ) \& A}}  &
    \TESC{a}{i}{j}{\Mat{A}} & \text{{\tt A \& T( (a,i,j) ) }} \\ \hline    
  \end{array}
\end{displaymath}
\paragraph{Secuencias de transformaciones.}
%Las dificultades surgen para denotar una secuencia de operaciones.
Considere las siguientes transformaciones
\begin{itemize}
\item multiplicar por 2 el primer vector, cuya abreviatura es:\qquad\quad\; \mbox{\Verb/ (2, 1) /}
\item intercambiar el tercer vector por cuarto, cuya abreviatura es:\quad \mbox{\Verb/ \{3, 4\} /}
\end{itemize}
Para indicar una secuencia que contiene ambas transformaciones,
usaremos una lista de abreviaturas:\; %
\mbox{\Verb/[(2,1), \{3,4\}]/}.\;
@
De esta manera, cuando componemos
ambas operaciones:\; \mbox{\Verb/ T( (2, 1) ) \& T( \{3, 4\} )/},
nuestra librería nos devuelve la trasformación composición de las dos
operaciones \textbf{en el orden en el que han sido escritas}:
\begin{center}
  al escribir \mbox{\Verb/ T( (2, 1) ) \& T( \{3, 4\} )/}
  \quad Python nos devuelve \quad
  \mbox{\Verb/T( [ (1, 2), \{3, 4\} ] )/}
\end{center}
Por tanto, si queremos realizar dichas operaciones sobre las columnas
de la matriz \Mat{A}, podemos hacerlo de dos formas: % de una en una
% (escribiendo las operaciones en el mismo orden en que queremos que se
% ejecuten y a la derecha de la matriz), o aplicando la transformación
% composición (descrita con la lista de operaciones en el orden en que
% queremos que se ejecuten) a la derecha de la matriz.
\begin{itemize}
\item \Verb/ A & T( (2, 1) ) & T( {3, 4} ) / \quad (indicando las transformaciones de una en una)
\item \Verb/ A & T( [(2, 1), {3, 4}] ) /    \quad (usando la transformación composición de todas ellas)
\end{itemize}
y si queremos operar sobre la filas hacemos exactamente igual, pero a
la izquierda de la matriz
\begin{itemize}
\item \Verb/ T( (2, 1) ) & T( {3, 4} ) & A/
\item \Verb/ T( [(2, 1), {3, 4}] ) & A/
\end{itemize}

\paragraph{Representación de una secuencia de transformaciones.}
\begin{displaymath}
  \begin{array}{|l||c|}
    \hline
    \text{Representación en la consola de Python} & \text{Representación en Jupyter} \\
    \hline\hline
    \text{ \tt T( [ (2, 1), (1, 3, 2) ] ) } &
    \underset{\delimitershortfall=-1pt
      \begin{subarray}{c}
        \\\left[\pr{2}{1}\right]
        \\\left[\su{1}{3}{2}\right]
      \end{subarray}}{\TrEE}
    \\\hline
  \end{array}
\end{displaymath}

\paragraph{Representación de transformaciones identidad.}
Si las transfomaciones multiplican un vector por 1, y suman un vector
nulo a otro vector, dichas transformaciones no cabian el sistema de
vectores. Lo habitual es que si un paso no modifica nada, que no se
represente, por ello se filtran los pasos con el procedimiento
[[<<Filtrado de secuencias de transformaciones>>]]; si, a resultas del
filtrado, la lista de abreviaturas es vacía entonces la representación
en \LaTeX{} es una cadena vacía (no se pinta ningún símbolo en
Júpyter). Si el atributo [[rpr]] es distinto de [['v']] la
representación en Jupiter se realiza en horizontal.

\begin{codigo}[nobreak=true]
<<Representación de la clase [[T]]>>=
def __repr__(self):
    """ Muestra T en su representación Python """
    return 'T(' + repr(self.t) + ')'

def _repr_html_(self):
    """ Construye la representación para el entorno Jupyter Notebook """
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para representar una Trans. Elem. """
    def simbolo(t):
        """Escribe el símbolo que denota una trasformación elemental particular"""
        if isinstance(t,set):
            return '\\left[\\mathbf{' + latex(min(t)) + \
              '}\\rightleftharpoons\\mathbf{' + latex(max(t)) + '}\\right]'
        if isinstance(t,tuple) and len(t) == 2:
            return '\\left[\\left(' + \
              latex(t[0]) + '\\right)\\mathbf{'+ latex(t[1]) + '}\\right]'
        if isinstance(t,tuple) and len(t) == 3:
            return '\\left[\\left(' + latex(t[0]) + '\\right)\\mathbf{' + \
              latex(t[1]) + '}' + '+\\mathbf{' + latex(t[2]) + '} \\right]'    

    if isinstance(self.t, (set, tuple) ):
        return '\\underset{' + simbolo(self.t) + '}{\\pmb{\\tau}}'

    elif self.t == []:
        return ' '

    elif isinstance(self.t, list) and self.rpr=='v':
        return '\\underset{\\begin{subarray}{c} ' + \
              '\\\\'.join([simbolo(i) for i in self.t])  + \
              '\\end{subarray}}{\\pmb{\\tau}}'

    elif isinstance(self.t, list):
        return '\\underset{' + \
               '}{\\pmb{\\tau}}\\underset{'.join([simbolo(i) for i in self.t]) + \
               '}{\\pmb{\\tau}}'
              
@ 
\end{codigo}


%    #elif isinstance(self.t, list):
%    #    return '\\,'.join([latex(T(i)) for i in self.t])

% \noindent
% Nótese que
% \begin{displaymath}
%   \TEPF{\lambda}{i}{\Mat{I}} =
%   \TEPC{\lambda}{i}{\Mat{I}} =
%   \EII{\lambda}{i}
% \end{displaymath}
% es una matriz simétrica, y que
% \begin{displaymath}
%   \TESF{\lambda}{i}{\HLa{j}}{\Mat{I}} =
%   \EI{\lambda}{\HLa{j}}{i}
%   \ne
%   \EI{\lambda}{i}{\HLa{j}} =
%   \TESC{\lambda}{i}{\HLa{j}}{\Mat{I}}.
% \end{displaymath}
% Por tanto \STEC[\TrEE]{\Mat{I}} es la transpuesta de
% \STEF[\TrEE]{\Mat{I}}.\; En general, la transpuesta de
% \STEC[\TrEE_1\TrEE_2\cdots\TrEE_k]{\Mat{I}} es
% \STEF[\TrEE_k\cdots\TrEE_2\TrEE_1]{\Mat{I}}.  Por ejemplo, si \Mat{A}
% es de orden $m\times n$, entonces
% \begin{displaymath}
%   \STEC
%   [\underset{\left[\pr{2}{1}\right]}{\TrEE}
%    \underset{\left[\su{1}{3}{2}\right]}{\TrEE}]
%   {\Mat{A}}
%   \;=\;
%   \Mat{A}\cdot\EII{2}{1}\EI{1}{3}{2},
%   \qquad
%   \text{donde $\EII{2}{1}=\TEPC{1}{2}{\Mat{I}}$
%     ,\; donde\;
%     $\EI{1}{3}{2}=\TESC{1}{3}{2}{\Mat{I}}$
%     y donde \Mat{I} es de orden $n$.}
% \end{displaymath}
% y
% \begin{displaymath}
%   \STEF
%   [\underset{\left[\su{1}{3}{2}\right]}{\TrEE}
%   \underset{\left[\pr{2}{1}\right]}{\TrEE}]
%   {\Mat{A}}
%   \;=\;
%   \EI{1}{2}{3}\EII{2}{1}\cdot\Mat{A},
%   \qquad
%   \text{donde $\EII{2}{1}=\TEPF{2}{1}{\Mat{I}}$
%     ,\; donde\;
%     $\EI{1}{2}{3}=\TESF{1}{3}{2}{\Mat{I}}$
%     y donde \Mat{I} es de orden $m$.}
% \end{displaymath}
% Así, 
% \begin{math}
%   \underset{\left[\pr{2}{1}\right]}{\TrEE}
%   \underset{\left[\su{1}{3}{2}\right]}{\TrEE}
% \end{math}
% \; no es el producto de matrices\dots\; ¡pero casi se puede
% interpretar como tal! Tan solo nos falta que las transformaciones
% actuen sobre una matriz.

% Por lo que, además de definir la inversa de una transformación
% elemental, también podremos definir algo parecido a la transpuesta
% de una transformación elemental.

%\pagebreak[4]
\section{Representación de los procesos de eliminación Gaussiana}
Cuando hemos encadenado varios procedimientos de eliminación,
deberíamos poder ver los pasos desde el principio hasta el final. Para
ello comprobamos si [[data]] fue obtenido mediante un proceso previo
de eliminación. El modo de saberlo es comprobar si [[data]] posee el
atributo [[pasos]].  El atributo [[tex]] guarda el código \LaTeX\ que
muestra el proceso completo, y se construye aplicando el método
[[PasosYEscritura]].  El atributo [[pasos]] guarda las listas de
abreviaturas de las transformaciones elementales empleadas. Por
comodidad añadimos dos atributos más: [[TrF]] es la
[[T]]transformación aplicada a las filas y [[TrC]] es la
[[T]]transformación aplicada a las columnas.
\begin{codigo}[nobreak=true]
<<Se guardan los atributos [[tex]] y [[pasos]] (y se muestran los pasos si se pide)>>=
pasosPrevios = data.pasos if hasattr(data, 'pasos') and data.pasos else [[],[]]
TexPasosPrev = data.tex   if hasattr(data, 'tex')   and data.tex   else []
self.tex = rprElim(data, pasos, TexPasosPrev)
pasos[0] = pasos[0] + pasosPrevios[0] 
pasos[1] = pasosPrevios[1] + pasos[1]
self.pasos = pasos 
self.TrF = T(pasos[0])
self.TrC = T(pasos[1])
if rep:
    display(Math(self.tex))                                                               
@

\end{codigo}

Cuando mostramos los pasos, es más legible mostrar únicamente los
que modifican la matriz (omitiendo sustituciones de una columna por
ella misma, productos de una columna por 1, o sumas de un vector nulo
a una columna). 

El atributo [[tex]] guardará el código \LaTeX\ que muestra el proceso
completo. Si ha habido transformaciones previas, la cadena de \LaTeX\
que permite su representación en el entorno Jupyter estará guardada en
la variable ([[TexPasosPrev]]), y a dicha cadena hay que añadir la
correspondiente cadena de \LaTeX\ que permita representar los nuevos
[[pasos]] dados como argumento de este método. Si [[TexPasosPrev]] es
vacío, la escritura comienza con la representación de [[data]]. A la
hora de representar los pasos hay que tener en cuenta si se dan sobre
las filas ([[l==0]]) o sobre las columnas ([[l==1]]). 

\begin{codigo}
<<Representación de un proceso de eliminación>>=
def rprElim(data, pasos, TexPasosPrev=[]):
    """Escribe en LaTeX los pasos efectivos y las sucesivas matrices"""
    A   = Matrix(data);  
    tex = latex(data) if not TexPasosPrev else TexPasosPrev
    for l in 0,1:
	if l==0:
	    for i in reversed(range(len(pasos[l]))):
                tex += '\\xrightarrow[' + latex(pasos[l][i]) + ']{}'
                if isinstance (data, Matrix):
                    tex += latex( pasos[l][i] & A )
                elif isinstance (data, BlockM):
                    tex += latex( key(data.lm)|(pasos[l][i] & A)|key(data.ln) )
	if l==1:
	    for i in range(len(pasos[l])):
                tex += '\\xrightarrow{' + latex(pasos[l][i]) + '}'
                if isinstance (data, Matrix):
                    tex += latex( A & pasos[l][i] )
                elif isinstance (data, BlockM):
                    tex += latex( key(data.lm)|(A & pasos[l][i])|key(data.ln) )
    return tex

@ %def rprElim
\end{codigo}

Este procedimento añadido es para ``pintar'' los pasos de eliminación.

\begin{codigo}
<<Representación de un proceso de eliminación>>=
def dispElim(self, pasos, TexPasosPrev=[]):
    display(Math(rprElim(self, pasos, TexPasosPrev)))

@ %def dispElim
\end{codigo}

El código es parecido a [[rprElim]], pero además calcula el determinante.

\begin{codigo}[nobreak=true]
<<Definición del método [[PasosYEscritura]] que también calcula el valor del [[Determinante]]>>=
def PasosYEscritura(data, p, TexPasosPrev=[]):
    """Escribe en LaTeX los pasos efectivos dados"""
    producto  = lambda x: 1 if not x else x[0] * producto(x[1:])
    A   = Matrix(data);  
    tex = latex(data) if not TexPasosPrev else TexPasosPrev    
    for l in 0,1:
	if l==0:
	    for i in reversed(range(len(p[l]))):
                S = [ tr for tr in filter( lambda x: len(x)==2, T(p[l][i]).t ) ]
                m = [-1 if isinstance(tr,set) else tr[0] for tr in S]
                d = T([ ( fracc(1, producto(m)) , A.n ) ]) if producto(m)!=1 else T([])
                p[1] = p[1] + filtradopasos([d])
                
                tex += '\\xrightarrow[' + latex(p[l][i]) + ']{' + latex(d) + '}'
                if isinstance (data, Matrix):
                    tex += latex( p[l][i] & A & d)
                elif isinstance (data, BlockM):
                    tex += latex( key(data.lm)|(p[l][i] & A & d)|key(data.ln) )
	if l==1:
	    for i in range(len(p[l])):
                S = [ tr for tr in filter( lambda x: len(x)==2, T(p[l][i]).t ) ]
                m = [-1 if isinstance(tr,set) else tr[0] for tr in S]
                d = T([ ( fracc(1, producto(m)) , A.n ) ]) if producto(m)!=1 else T([])
                p[0] = p[0] + filtradopasos([d])

                tex += '\\xrightarrow[' + latex(d) + ']{' + latex(p[l][i] ) + '}'
                if isinstance (data, Matrix):
                    tex += latex( d & A & p[l][i] )
                elif isinstance (data, BlockM):
                    tex += latex( key(data.lm)|(d & A & p[l][i])|key(data.ln) )
    Det = simplifica( producto( A.diag() ) )
    return [tex, Det, p]
@ 
\end{codigo}

\clearpage

\section{Representación de la resolución de sistemas de ecuaciones}
\begin{codigo}[nobreak=true]
<<Métodos de representación de la clase [[Homogenea]]>>=
def __repr__(self):
    """Muestra el Espacio Nulo de una matriz en su representación Python"""
    return 'Combinaciones lineales de (' + repr(self.sgen) + ')'

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para la solución de un Sistema Homogéneo"""
    if self.determinado:
        return '\\left\\{\ ' + latex(self.sgen|1) + '\ \\right\\}'
    else:
        return '\\mathcal{L}\\left(\ ' + latex(self.sgen) + '\ \\right)' # + latex(self.enulo)

@
\end{codigo}


\begin{codigo}[nobreak=true]
<<Métodos de representación de la clase [[SEL]]>>=
def EcParametricas(self):
    """Representación paramétrica del SubEspacio"""
    return '\\left\\{ \\boldsymbol{x}\\in\\mathbb{R}^' \
      + latex(self.eafin.Rn) \
      + '\ \\left|\ \\exists\\boldsymbol{p}\\in\\mathbb{R}^' \
      + latex(len(self.sgen)) \
      + ',\\; \\boldsymbol{x}= '\
      + latex(self.solP) + '+' \
      + latex(Matrix(self.sgen)) \
      + '\\boldsymbol{p}\\right. \\right\\}' \
   
def __repr__(self):
    """Muestra el Espacio Nulo de una matriz en su representación Python"""
    return repr(self.solP) + ' + Combinaciones lineales de (' + repr(self.sgen) + ')'

def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def latex(self):
    """ Construye el comando LaTeX para la solución de un Sistema Homogéneo"""
    if self.determinado:
        return '\\left\\{\ ' + latex(self.solP) + '\ \\right\\}'
    else:
        return self.EcParametricas()
@
\end{codigo}

\pagebreak[4]
\section{Completando la clase \texttt{SubEspacio}}
\subsection{Representación de la clase \texttt{SubEspacio}}
\begin{codigo}[nobreak=true]
<<Métodos de representación de la clase [[SubEspacio]]>>=
def _repr_html_(self):
    """Construye la representación para el entorno Jupyter Notebook"""
    return html(self.latex())

def EcParametricas(self):
    """Representación paramétrica del SubEspacio"""
    return '\\left\\{ \\boldsymbol{v}\\in\\mathbb{R}^' \
      + latex(self.Rn) \
      + '\ \\left|\ \\exists\\boldsymbol{p}\\in\\mathbb{R}^' \
      + latex(max(self.dim,1)) \
      + ',\\; \\boldsymbol{v}= '\
      + latex(Matrix(self.sgen)) \
      + '\\boldsymbol{p}\\right. \\right\\}' \
      #+ '\qquad\\text{(ecuaciones paramétricas)}'

def EcCartesianas(self):
    """Representación cartesiana del SubEspacio"""
    return '\\left\\{ \\boldsymbol{v}\\in\\mathbb{R}^' \
      + latex(self.Rn) \
      + '\ \\left|\ ' \
      + latex(self.cart) \
      + '\\boldsymbol{v}=\\boldsymbol{0}\\right.\\right\\}' \
      #+ '\qquad\\text{(ecuaciones cartesianas)}'
    
def latex(self):
    """ Construye el comando LaTeX para un SubEspacio de Rn"""
    return self.EcParametricas() + '\; = \;' + self.EcCartesianas()
        
@ 
\end{codigo}

\section{La clase \texttt{BlockM}. Matrices particionadas} % (o matrices por bloques)}
\emph{Las matrices particionadas no son tan importantes para seguir el
  curso, aunque si se usan en esta librería. Piense que cuando
  invierte una matriz o resuelve un sistema de ecuaciones, usa una
  matriz particionada (con dos bloques: una matriz arriba, y la matriz
  identidad con idéntico número de columnas debajo). Como esta
  librería replica lo que se ve en clase, es necesario definir las
  matrices particionadas.}  \emph{Si quiere, \textbf{puede saltarse
    esta sección}: el modo de particionar una matriz es sencillo y se
  puede aprender rápidamente con el siguiente Notebook}
\begin{notebook}
  \begin{center}
    Consulte el Notebook sobre el
    \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2FNotebook.ipynb}{\textbf{uso de la librería \texttt{nacal}}}
    %\href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F03_UsoLibreria.ipynb}{\textbf{uso de nuestra librería para Mates 2}}
      en la carpeta
      \href{https://mybinder.org/v2/gh/mbujosab/nacallib/master?filepath=doc%2FNotebooks%2F}{``Notebooks''}
        en \url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks}.
        %\url{https://github.com/mbujosab/nacallib/tree/master/doc/Notebooks}
  \end{center}
\end{notebook}
%\begin{notebook}
%  \begin{center}
%    Este Notebook es un ejemplo sobre el \href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F03_UsoLibreria.ipynb}{\textbf{uso de nuestra librería para Mates 2}}
%    en la carpeta
%    \href{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master?filepath=TutorialPython%2F}{``TutorialPython''}
%    en
%    \url{https://mybinder.org/v2/gh/mbujosab/LibreriaDePythonParaMates2/master}
%  \end{center}
%\end{notebook}
\bigskip

\subsection{La clase \texttt{SisMat}. Sistema de Matrices}
De manera auxiliar y para ayudar a una representación más clara de las
[[BlockM]] y del funcionamiento del operador selector de un
[[Sistema]] en el caso de las [[BlockM]], vamos a definir una nueva
subclase auxiliar de [[Sistema]], compuesto por matrices con el mismo
número de columnas. Lo denominaremos [[SisMat]] (sistema de matrices)
y lo representaremos entre paréntesis y con las [[Matrix]] dispuestas
unas encima de otras y separadas por lineas horizontales (algo así
como un vector en forma de columna cuyos elementos son matrices):
\begin{displaymath}
  \left(\begin{array}{ccc}1&2&1\\7&-3&0\\6&4&2\\ \hline 1&0&0\\0&1&0\\0&0&1\\\end{array}\right)
\end{displaymath}
Y si el sistema [[SisMat]] contiene una única [[Matrix]], también
pintamos los corchetes de la matriz para no confundir un [[SisMat]]
con una [[Matrix]]:
\begin{displaymath}
  \begin{pmatrix}\begin{bmatrix}1&2&1\\7&-3&0\\6&4&2\end{bmatrix}\\\end{pmatrix}
\end{displaymath}
Es decir, si está encerrado entre paréntesis es un [[SisMat]].

Para mayor comodidad, [[Matrix(B)]] donde [[B]] es una [[SisMat]]
apila las matrices de [[B]] en una única [[Matrix]].

Una vez definidos los [[SisMat]], definiremos las matrices por bloques
[[BlockM]] como listas de [[SisMat]] (cada [[SisMat]] será una columna
de matrices). Así, si [[A]] es una [[BlockM]], entonces [[A|1]]
selecciona un [[SisMat]] con las matrices de la primera columna de
[[A]] (con [[1|A]] generamos una [[BlockM]] cuyas [[SisMat]]s
contienen únicamente las [[Matrix]] de la primera fila de [[BlockM]]).

\begin{codigo}[nobreak=true]
<<Inicialización de la clase [[SisMat]]>>=
def __init__(self, data):
    """Inicializa un SisMat con una lista, tupla o Sistema de Matrix,
    (todas con el mismo número de columnas).
    """
    super().__init__(data)

    lista = Sistema(data).lista.copy()
           
    if isinstance(data[0], Matrix):
        
        <<Verificamos que todas las Matrix tienen el mismo número de columnas>>
        self.lista = lista.copy()
                                                                            
    self.n     = len(self)
           
    self.ln    = (self|1).n
    self.lm    = [matriz.m for matriz in self]

@
\end{codigo}


\begin{codigo}[nobreak=true]
<<Verificamos que todas las Matrix tienen el mismo número de columnas>>=
if not all( isinstance(m,Matrix) and m.n==lista[0].n for m in self):
    raise ValueError('O no todo son Matrix o no tienen el mismo número de columnas!')
@ 
\end{codigo}

Cuando el argumento del operador selector por la derecha es entero,
lista o slice, funciona como como con cualquier [[Sistema]]
genérico. Pero cuando el argumento es un \emph{conjunto}, se
particiona el sistema, de manera que se devuelve la [[BlockM]]
resultante de particionar las matrices por la derecha de las columnas
cuyos índices aparecen en el conjunto (manteniendo las particiones
horizontales)
\begin{codigo}[nobreak=true]
<<Operador selector por la derecha para la clase [[SisMat]]>>=
def __or__(self, j):
    <<Operador selector por la derecha cuando el argumento es entero, lista o slice>>        
    elif isinstance(j, set):
        return BlockM([ SisMat( [Mat|list(c) for Mat in self] ) \
                                    for c in particion(j, self.ln) ])

@
\end{codigo}

Cuando el argumento del operador selector por la izquierda es entero,
lista o slice, funciona como por la derecha. Pero cuando el argumento
es un \emph{conjunto}, se reparticiona [[SisMat]] por debajo de las
filas cuyos índices aparecen en el conjunto (manteniendo las
particiones horizontales). Para ello se unifica el [[SisMat]] en una
única [[Matrix]], que se trocea en submatrices por las filas indicadas
en el argumento [[i]].
\begin{codigo}[nobreak=true] 
<<Operador selector por la izquierda para la clase [[SisMat]]>>=
def __ror__(self,i):
    """Hace exactamente lo mismo que el método __or__ por la derecha 
    cuando es el argumento es int, list, tuple o slice. Cuando el 
    argumento es un conjunto se reparticiona por las filas indicadas por
    el conjunto"""
    if isinstance(i, (int, list, tuple, slice)):
        return self | i
    elif isinstance(i, set):
        return SisMat([ list(f)|Matrix(self) for f in particion(i, Matrix(self).m) ])
    
@ 
\end{codigo}

\begin{codigo}[nobreak=true]
<<Representación de la clase [[SisMat]]>>=
def __repr__(self):
    """ Muestra un SisMat en su representación Python """
    return 'SisMat(' + repr(self.lista) + ')'

def _repr_html_(self):
    """ Construye la representación para el entorno Jupyter Notebook """
    return html(self.latex())

@ 
\end{codigo}

\begin{codigo}[nobreak=true]
<<Representación de la clase [[SisMat]]>>=
def latex(self):
    """ Escribe el código de LaTeX para representar una SisMat """
    if self.n == 1:       
        return '\\begin{pmatrix}' + latex(self|1) + '\\end{pmatrix}'
        
    else:
        return \
          '\\left(' + \
          '\\begin{array}{' + self.ln*'c' + '}' + \
          '\\\\ \\hline '.join( ['\\\\'.join( ['&'.join( [latex(e) \
                 for e in fila ]) for fila in ~Mat ]) for Mat in self ]) + \
          '\\\\' + \
          '\\end{array}' + \
          '\\right)'

@  
\end{codigo}

\paragraph{La clase \texttt{SisMat}} junto con el listado de sus
métodos aparece en el siguiente recuadro:

\begin{codigo}[nobreak=true]
<<Definición de la clase [[SisMat]]>>=
class SisMat(Sistema):
    <<Inicialización de la clase [[SisMat]]>>
    <<Operador selector por la derecha para la clase [[SisMat]]>>
    <<Operador selector por la izquierda para la clase [[SisMat]]>>
    <<Representación de la clase [[SisMat]]>>
    
@ %def SisMat
\end{codigo}

\subsection{La clase \texttt{BlockM}. Matrices particionadas (o matrices por bloques)}
Las matrices por bloques o cajas $\blockmat{A}$ son tablas de matrices
de modo que todas las matrices de una misma fila comparten el mismo
número de filas, y todas las matrices de una misma columna comparten
el mismo número de columnas. Por ello al ``pegar'' todas ellas
obtenemos una gran matriz.

Aquí implementamos las matrices particionadas en la clase [[BlockM]],
pero lo hacemos de un modo ligeramente diferente: las [[BlockM]] serán
sistemas de [[SisMat]] con el mismo número de matrices, y tales que
las matrices $i$ésimas de dichos [[SisMat]] tengan el mismo número de
filas.

El argumento de inicialización es una lista de [[Sistemas]] de
matrices (o de [[SisMat]]s), cada elemento de la lista será una
columna de bloques (o submatrices con el mismo número de columnas).

Alternativamente, el argumento de inicialización puede ser una lista
de listas de matrices con el mismo número de filas. Cada lista de
matrices será una fila de bloques (o submatrices con el mismo número
de filas).

El atributo \verb/self.n/ contiene el número de [[SisMat]]s (columnas
de bloques o submatrices) y \verb/self.m/ contiene el número de
matrices de dichos [[SisMat]] (filas de bloques o
submatrices). Añadimos el atributo \verb/self.ln/, que es una lista
con el número de filas que tienen las submatrices de cada fila, y
\verb/self.lm/ con el número de columnas de las submatrices de cada
columna.  \medskip

\begin{codigo}[nobreak=true]
<<Inicialización de la clase [[BlockM]]>>=
def __init__(self, data):
    """Inicializa una BlockM con una lista, tupla, o Sistema: de SisMats 
    (serán las columnas de matrices) o bien de listas o tuplas de 
    matrices (filas de matrices)
    """
    super().__init__(data)

    lista = Sistema(data).lista
           
    if isinstance(lista[0], Sistema): 
        <<Verificación de que todos son Sistemas de matrices y de la misma longitud>>
        self.lista = [ SisMat(e) for e in lista ].copy()
                                                                 
    elif isinstance(data[0], (list, tuple)):
        <<Verificación de que todas son listas de matrices y de la misma longitud>>
        self.lista  =  [ SisMat([ lista[j][i] for j in range(len(lista))]) \
                                              for i in range(len(lista[0])) ].copy()
           
    self.m     = len(self|1)
    self.n     = len(self)
           
    self.lm    = (self|1).lm
    self.ln    = [sm.ln for sm in self]

@
\end{codigo}

\begin{codigo}[nobreak=true]
<<Verificación de que todos son Sistemas de matrices y de la misma longitud>>=
if not all ( isinstance(s, Sistema) and s.de_composicion_uniforme() and \
             isinstance(s|1, Matrix) and  len(s)==len(lista[0]) for s in lista ):
    raise ValueError('no son Sistemas de matrices, o no tienen la misma longitud!')

<<Verificación de que todas son listas de matrices y de la misma longitud>>=
if not all ( isinstance(s, (list,tuple)) and  isinstance(s[0], Matrix) and \
             all(type(e)==type(lista[0]) for e in lista) and \
             len(s)==len(lista[0]) for s in lista ):
    raise ValueError('no son listas de matrices, o no tienen la misma longitud!')

@ 
\end{codigo}

\paragraph{La clase \texttt{BlockM}} junto con el listado de sus
métodos aparece en el siguiente recuadro:

\begin{codigo}[nobreak=true]
<<Definición de la clase [[BlockM]]>>=
class BlockM(Sistema):
    <<Inicialización de la clase [[BlockM]]>>
    <<Operador selector por la derecha para la clase [[BlockM]]>>
    <<Operador selector por la izquierda para la clase [[BlockM]]>>
    <<Representación de la clase [[BlockM]]>>
    
@ %def BlockM
\end{codigo}



\subsection{Particionado de matrices}
Vamos a completar las capacidades de los operadores ``\texttt{i|}'' y
``\texttt{|j}'' sobre matrices. Hasta ahora, si los argumentos
\texttt{i} o \texttt{j} eran \emph{enteros} (\texttt{int}), se
seleccionaba una fila o una columna respectivamente; y si los
argumentos \texttt{i} o \texttt{j} eran \emph{listas o tuplas} de
índices, se generaba una submatriz con las filas o las columnas
indicadas.  \medskip

Aquí, si los argumentos \texttt{i} o \texttt{j} son \textrm{conjuntos}
de enteros, asumimos que dichos enteros indican las filas o columnas
por las que se debe particionar una [[Matrix]] según el siguiente
cuadro explicativo:
%(y más adelante también una [[BlockM]]).
\begin{NotMat2}
  \begin{itemize}
  \item Si $p\leq q\in\Nn$ denotaremos con $(p:q)$ a la secuencia
    $p,p+1,\ldots,q$, (es decir, a la lista ordenada de los números de
    $\{k\in\Nn| p\leq k\leq q\}$).
  \item Si $i_1,\ldots,i_r \in \Nn$ con $i_1<\ldots < i_r\leq m$ donde
    $m$ es el número de filas de $\Mat{A}$, entonces
    \elemL{\Mat{A}}{\{ i_1,\ldots, i_r \}} es la matriz de bloques
    \begin{displaymath}
      \elemL{\Mat{A}}{\{ i_1,\ldots, i_r \}}=
      \begin{bmatrix}
        \begin{array}{c}
          \elemL{\Mat{A}}{(1:i_1)}\phantom{\Big)}\\
          \hline
          \elemL{\Mat{A}}{(i_1+1:i_2)}\phantom{\Big)}\\
          \hline
          \vdots\\
          \hline
          \elemL{\Mat{A}}{(i_r+1:m)}\phantom{\Big)}\\
        \end{array}
      \end{bmatrix}
    \end{displaymath}
  \item Si $j_1,\ldots,j_s \in \Nn$ con $j_1<\ldots < j_s\leq n$ donde
    $n$ es el número de columnas de $\Mat{A}$, entonces
    \elemR{\Mat{A}}{\{ j_1,\ldots, j_s \}} es la matriz de bloques
    \begin{displaymath}
      \elemR{\Mat{A}}{\{ j_1,\ldots, j_s \}}=
      \begin{bmatrix}
        \begin{array}{c|c|c|c}
          \elemR{\Mat{A}}{(1:j_1)}\phantom{\Big)}&
          \elemR{\Mat{A}}{(j_1+1:j_2)}\phantom{\Big)}&
          \cdots&
          \elemR{\Mat{A}}{(j_s+1:n)}\phantom{\Big)}\\
        \end{array}
      \end{bmatrix}
    \end{displaymath}
  \end{itemize}
\end{NotMat2}

Comencemos por la partición de índices a partir de un conjunto y un número
(correspondiente al último índice).

\begin{codigo}[nobreak=true]
<<Definición del método [[particion]]>>=
def particion(s,n):
    """ genera la lista de particionamiento a partir de un conjunto y un número
    >>> particion({1,3,5},7)

    [[1], [2, 3], [4, 5], [6, 7]]
    """
    p = sorted(list(s | set([0,n])))
    return [ list(range(p[k]+1,p[k+1]+1)) for k in range(len(p)-1) ]
    
@ %def particion
\end{codigo}

y ahora el método de partición por filas y por columnas resulta
inmediato:

\begin{codigo}[nobreak=true]
<<Partición de una matriz por filas de bloques>>=
elif isinstance(i,set):
    return BlockM ([ [a|self] for a in particion(i,self.m) ])
    
@ 
\end{codigo}
\begin{codigo}[nobreak=true]
<<Partición de una matriz por columnas de bloques>>=
elif isinstance(j,set):
    return BlockM ([ [self|a for a in particion(j,self.n)] ])
    
@
\end{codigo}


Pero aún nos falta algo:
\begin{NotMat2}
  \begin{itemize}
  \item Si $i_1,\ldots,i_r \in \Nn$ con $i_1<\ldots < i_r\leq m$ donde
    $m$ es el número de filas de $\Mat{A}$ y $j_1,\ldots,j_s \in \Nn$
    con $j_1<\ldots < j_s\leq n$ donde $n$ es el número de columnas de
    $\Mat{A}$ entonces
    \begin{displaymath}
      \elemLR{\Mat{A}}{\{ i_1,\ldots, i_y \}}{\{ j_1,\ldots, j_s \}}
      =
      \begin{bmatrix}
        \begin{array}{c|c|c|c}
          \hphantom{_{+1}}\elemLR{\Mat{A}}{(1:i_1)}{(1:j_1)}\vphantom{\Big)}
          & \hphantom{_{i_i+}}\elemLR{\Mat{A}}{(1:i_1)}{(j_1+1:j_2)} & \cdots
          & \hphantom{_{i_i+}}\elemLR{\Mat{A}}{(1:i_1)}{(j_s+1:n)} \\
          \hline
          \elemLR{\Mat{A}}{(i_1+1:i_2)}{(1:j_1)}\vphantom{\Big)}
          & \elemLR{\Mat{A}}{(i_1+1:i_2)}{(j_1+1:j_2)} & \cdots
          & \elemLR{\Mat{A}}{(i_1+1:i_2)}{(j_s+1:n)} \\
          \hline
          \vdots & \vdots & \cdots & \vdots\\
          \hline
          \elemLR{\Mat{A}}{(i_k+1:m)}{(1:j_1)}\vphantom{\Big)}
          & \elemLR{\Mat{A}}{(i_k+1:m)}{(j_1+1:j_2)} & \cdots
          & \elemLR{\Mat{A}}{(i_k+1:m)}{(j_s+1:n)} \\
        \end{array}
      \end{bmatrix}
    \end{displaymath}
  \end{itemize}
\end{NotMat2}
es decir, queremos poder particionar una [[BlockM]].  Los casos
interesantes son cuando particionamos por el lado contrario por el que
se particionó la matriz inicial, es decir,
\begin{displaymath}
  \elemL{\Big(\elemR{\Mat{A}}{\{ j_1,\ldots, j_s \}}\Big)}{\{ i_1,\ldots, i_r \}}
  \qquad\text{ y }\qquad
  \elemR{\Big(\elemL{\Mat{A}}{\{ i_1,\ldots, i_r \}}\Big)}{\{ j_1,\ldots, j_s \}}
\end{displaymath}
que, por supuesto, debe dar el mismo resultado. 

Cuando el argumento del operador selector por la derecha es entero,
lista o slice, funciona como con cualquier [[Sistema]] genérico. Pero
cuando el argumento es un \emph{conjunto} y hay una única columna de
matrices (\verb/self.n == 1/), es decir, cuando [[BlockM]] contiene un
único [[SisMat]], se particiona dicho [[SisMat]] para obtener la
[[BlockM]] correspondiente.  El caso general (cuando el sistema
contiene más de un [[SisMat]]) se verá más tarde:
\begin{codigo}[nobreak=true]
<<Operador selector por la derecha para la clase [[BlockM]]>>=
def __or__(self, j):
    <<Operador selector por la derecha cuando el argumento es entero, lista o slice>>        
    elif isinstance(j, set):
        if self.n == 1:
            return  (self|1)|j 
                                
        <<Caso general de repartición por columnas>>

@
\end{codigo}
y hacemos lo mismo para particionar por filas cuando
\verb/self.m == 1/ (la matriz por bloques tiene una única fila):
\noindent

Falta implementar el caso general. Debemos decidir el
significado de reparticionar una matriz por el mismo lado por el que
ya ha sido particionada. Seguiremos un criterio práctico\dots eliminar
el anterior particionado y aplicar el nuevo:
\begin{eqnarray*}
  \elemL{\Big(\elemLR{\Mat{A}}{\{ i_1,\ldots, i_k \}}{\{ j_1,\ldots, j_s \}}\Big)}{\{ i'_1,\ldots, i'_r \}}
  &=&\elemLR{\Mat{A}}{\{ i'_1,\ldots, i'_r \}}{\{ j_1,\ldots, j_s \}}
  \\\\
  \elemR{\Big(\elemLR{\Mat{A}}{\{ i_1,\ldots, i_k \}}{\{ j_1,\ldots, j_s \}}\Big)}{\{ j'_1,\ldots, j'_r \}}
  &=&\elemLR{\Mat{A}}{\{ i_1,\ldots, i_k \}}{\{ j'_1,\ldots, j'_r \}}
\end{eqnarray*}
Para ello nos viene bien extraer el conjunto selector a partir del resultado:
\begin{codigo}[nobreak=true]
<<Definición del procedimiento de generación del conjunto clave para particionar>>=
def key(L):
    """Genera el conjunto clave a partir de una secuencia de tamaños
    número
    >>> key([1,2,1])

    {1, 3, 4}
    """
    return set([ sum(L[0:i]) for i in range(1,len(L)+1) ])   

@
\end{codigo}

Así, los  casos generales consisten en reparticionar de nuevo:
\begin{codigo}[nobreak=true]
<<Caso general de repartición por columnas>>=
elif self.n > 1: 
     return (key(self.lm) | Matrix(self)) | j

@
\end{codigo}


El operador selector por la izquierda es más sencillo, pues usa el operador selector por la izquierda de las [[SisMat]]:
\begin{codigo}[nobreak=true]
<<Operador selector por la izquierda para la clase [[BlockM]]>>=
def __ror__(self,i):
    if isinstance(i, (int)):
        return BlockM( [ [i|sm for sm in self] ] )
    
    if isinstance(i, (list,tuple,slice,set) ):        
        return BlockM( [i|sm for sm in self] )
    
@
\end{codigo}

\begin{observacion}
  El método \verb/__or__/ está definido para conjuntos \dots y da como
  resultado la unión de conjuntos.  Por tanto si \verb/A/ es una
  matriz, el resultado de \verb/{1,2}|({3}|A)/ es distinto del
  obtenido con \verb/({1,2}|{3})|A/. El primero da lo mismo que
  \verb/{1,2}|A/, mientras que el segundo nos da \verb/{1,2,3}|A/.
\end{observacion}

% ¿Deben extenderse el resto de funcionalidades a las matrices por cajas? \dots depende
% de las necesidades (por ahora, así dejamos las [[BlockM]]). 
\subsection{Representación de la clase \texttt{BlockM}}
A continuación definimos las reglas de representación para las
matrices por bloques. [[Matrix]] y [[BlockM]] son objetos
distintos. Los bloques se separan con lineas verticales y
horizontales; pero si hay un único bloque, no habrá ninguna línea
vertical u horizontal por medio de la representación de la
[[BlockM]]. Así, si una matriz por bloques tienen un único bloque,
pintaremos una caja alrededor para distinguirla de una matriz
ordinaria:
\begin{displaymath}
  \begin{bmatrix}1&2&1\\7&-3&0\end{bmatrix}
  \qquad\qquad
  \begin{array}{|c|}\hline \begin{bmatrix}1&2&1\\7&-3&0\end{bmatrix}\\ \hline \end{array}
\end{displaymath}


\begin{codigo}[nobreak=true]
<<Representación de la clase [[BlockM]]>>=
def __repr__(self):
    """ Muestra una BlockM en su representación Python """
    return 'BlockM(' + repr(self.lista) + ')'

def _repr_html_(self):
    """ Construye la representación para el  entorno Jupyter Notebook """
    return html(self.latex())

def latex(self):
    """ Escribe el código de LaTeX para representar una BlockM """
    if self.m == self.n == 1:       
        return \
          '\\begin{array}{|c|}' + \
          '\\hline ' + latex(Matrix(self)) + '\\\\ \\hline ' + \
          '\\end{array}'
    else:
        return \
          '\\left[' + \
          '\\begin{array}{' + '|'.join([n*'c' for n in self.ln])  + '}' + \
          '\\\\ \\hline '.join( ['\\\\'.join( ['&'.join( \
           [latex(e) for e in fila]) for fila in ~Mat]) for Mat in (self|{0}|1)]) + \
          '\\\\' + \
          '\\end{array}' + \
          '\\right]'

@ 
\end{codigo}


%\appendix
%\appendix
\chapter{Sobre este documento}
\label{part:SobreEsteDoc}
Con ánimo de que esta documentación sea más didáctica, en el
Capítulo~\ref{part:CodigoPrincipal} muestro las partes más didácticas del
código, y relego las otras al
Capítulo~\ref{parte:TrozosCodigoSecundarios}. Así puedo destacar cómo la
librería de Python es una implementación literal de las definiciones
dadas en mis notas de la asignatura de \mbox{Mates II}. Para lograr
presentar el código en un orden distinto del que realmente tiene en la
librería uso la herramienta
\href{https://en.wikipedia.org/wiki/Noweb}{noweb}. Una breve
explicación aparece en la siguiente sección\dots \bigskip

\subsection*{Literate programming con noweb}
\label{sec:LiterateProgramming}
Este documento está escrito usando
\href{https://en.wikipedia.org/wiki/Noweb}{noweb}. Es una herramienta
que permite escribir a la vez tanto código como su documentación. El
código se escribe a trozos o ``chunks'' como por ejemplo este:

\begin{codigo}[nobreak=true]
<<Chunk de ejemplo que define la lista [[a]]>>=
a = ["Matemáticas II es mi asignatura preferida", "Python mola", 1492, "Noweb"]
@
\end{codigo}
y este otro chunk:
\begin{codigo}[nobreak=true]
<<Segundo chunk de ejemplo que cambia el último elemento de la lista [[a]]>>=
a[-1] = 10
@ 
\end{codigo}

Cada chunk recibe un nombre (que yo uso para describir lo que hace el
código dentro del chunk). Lo ma\-ra\-vi\-llo\-so de este modo de
programar es que dentro de un chunk se pueden insertar otros
chunks. Así, podemos programar el siguiente guión de Python
(\texttt{EjemploLiterateProgramming.py}) que enumera los elementos de
una tupla y después hace unas sumas:
\begin{codigo}[nobreak=true]
%%Programa que enumera los elementos de una tupla y después hace unas sumas>>=
<<EjemploLiterateProgramming.py>>=
<<Chunk de ejemplo que define la lista [[a]]>>
<<Segundo chunk de ejemplo que cambia el último elemento de la lista [[a]]>>

for indice, item in enumerate(a, 1):
    print (indice, item)

<<Chunk final que indica qué tipo de objeto es [[a]] y hace unas sumas>>
@

\end{codigo}
Este modo de escribir el código permite destacar unas partes y pasar
por alto otras.  Por ejemplo, \emph{del chunk del recuadro de arriba
  me interesa que se vea el código del \HLa{bucle que permite enumerar
    los elementos de una lista}}. Lo demás es accesorio y se puede
consultar en los correspondientes chunks. Como el nombre de dichos
chunks es auto-explicativo, mirando el recuadro anterior es fácil
hacerse una idea de que hace el programa
``\texttt{EjemploLiterateProgramming.py}'' en su conjunto.

Fíjese que el número al final del nombre de cada chunk corresponde a
la página donde se puede consultar su código. Por ejemplo, el último
chunk de este ejemplo se encuentra en la
Página~\pageref{subsec:ultimoChunkEjemploLiterateProgramming} de este
documento.
\medskip

El código completo del ejemplo usado para explicar cómo funciona el
``Literate Programming'' queda así:

\begin{codigo}[nobreak=true]
\verbatiminput{nacal/EjemploLiterateProgramming.py}
\end{codigo}

\section{Secciones de código}\par\noindent
\nowebchunks
% \section{Function index}\par\noindent
% \nowebindex

\subsection*{Licencia}
<<Copyright y licencia GPL>>=
# Copyright (C) 2019 - 2020  Marcos Bujosa

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/
@ 

\subsection*{Último chunk del ejemplo de Literate Programming}
\label{subsec:ultimoChunkEjemploLiterateProgramming}

Este es uno de los trozos de código del ejemplo.

\begin{codigo}
<<Chunk final que indica qué tipo de objeto es [[a]] y hace unas sumas>>=
type(a)
2+2
3+20
@  
\end{codigo}


\end{document}
